# 统一部署运维系统中即时打包与预打包镜像的对比

## **说明：**

* docker体系中，服务的模板是镜像，从镜像启动容器作为服务；



### **即时打包镜像**:

* 优点：

  * 节省基础镜像空间
  * 可以后期修改打包过程(如修改启动参数等）

* 缺点：

  * **增加运维人员理解负担**：运维人员关注的应该是如何启动服务，升级服务，扩展服务； docker运行的服务的基础是镜像，镜像打包其实是一个中间过程，最终的服务模板其实是镜像，服务镜像制作的过程对于每个服务是不一样的，（如java的打包，web的打包，go的打包，甚至于同一种框架说产生的服务，其打包脚本可能都有区别），服务之间的差异性较大，而这些差异性对于运维人员来说，没有必要知道；
  * **因非高频动作引入太多复杂度**： 
    * 不同服务的镜像制作流程差异非常大，如果将各种服务的打包过程定义到部署运维系统中，并提供可视化的界面，需要针对每一种类型的服务提供
      * 各自的基础镜像；
      * 增量打包脚本；
      * 打包参数提取及参数配置界面开发制作；
      * 打包后镜像的可用性自动验证代码编写；
      * 更新（包括基础镜像更新，打包脚本更新，配置参数等的后期更新）
  * **不利于服务版本管理**： 由于最终将运行的服务镜像制作过程后移到了运维系统使用人员手中，镜像打包的版本标记可能失去控制，不利于后期的版本升级，回退，扩展操作，后期有问题时，开发也要花费一定时间厘清版本（当然可以通过引入额外的机制来解决，不过又引入了复杂度）

  

### **预打包镜像**：

* 优点
  * **服务可用性及一致性保证**：
    * 服务提供者直接提供服务镜像，可在镜像打包后进行测试确认，保证镜像工作符合开发人员预期；
    * 没有中间过程，运行的镜像一定是经过服务提供的开发人员认可的，后期有问题无疑义；
  * **镜像版本统一管理**：
    * 服务提供者可以控制镜像版本，可以较好的控制服务的升级，回退及扩展；
* 缺点：
  * 镜像大小相较于即时打包是直接提供成果物的方式可能会大一些；



