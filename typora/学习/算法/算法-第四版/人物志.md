# 计算机科学人物志

## 前言

发现书中提到的人名，有时一搜索，会发现可能还有更多故事，所以专门起个文档进行记录。

## Edsger Wybe Dijkstra

*总结： 学物理，然后需要使用计算机，所以后面二选一，专门搞计算机。然后当时没有没有程序员这个职业，所以琢磨着软件开发的方法论，提出了结构化编程的概念。*

### 简介

> [艾兹赫尔·戴克斯特拉 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/艾兹赫尔·戴克斯特拉)
>
> [埃德格斯·迪克斯特拉 - 维基百科 (wikipedia.org)](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra)
>
> **艾兹赫尔·韦伯·戴克斯特拉**（[荷兰语](https://zh.wikipedia.org/wiki/荷蘭語)：Edsger Wybe Dijkstra，荷兰语发音：[[ˈɛtsxər ˈʋibə ˈdɛikstra\]](https://zh.wikipedia.org/wiki/Help:荷蘭語國際音標) （[![关于这个音频文件](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Loudspeaker.svg/11px-Loudspeaker.svg.png)](https://zh.wikipedia.org/wiki/File:Dijkstra.ogg) [聆听](https://upload.wikimedia.org/wikipedia/commons/8/85/Dijkstra.ogg)），1930年5月11日－2002年8月6日），又译**艾兹赫尔·韦伯·迪杰斯特拉**，生于[荷兰](https://zh.wikipedia.org/wiki/荷蘭)[鹿特丹](https://zh.wikipedia.org/wiki/鹿特丹)，[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)家，是荷兰第一位以程序为专业的科学家。[[1\]](https://zh.wikipedia.org/wiki/艾兹赫尔·戴克斯特拉#cite_note-1)曾在1972年获得[图灵奖](https://zh.wikipedia.org/wiki/图灵奖)，之后，他还获得1974年AFIPS Harry Goode Memorial Award、1989年ACM SIGCSE计算机科学教育教学杰出贡献奖。
>
> 2002年，在他去世前不久，艾兹赫尔获得了ACM PODC（分布式计算原理）最具影响力论文奖，以表彰他在分布式领域中关于程序计算自稳定的贡献。为了纪念他，这个每年一度奖项也在此后被更名为“Dijkstra奖”。
>
> 他曾经提出“[GOTO有害论](https://zh.wikipedia.org/wiki/Goto#对于goto使用的批评)”，[信号量](https://zh.wikipedia.org/wiki/信号量)和[PV原语](https://zh.wikipedia.org/w/index.php?title=PV原语&action=edit&redlink=1)（passeren vrijgeven），解决了有趣的“[哲学家就餐问题](https://zh.wikipedia.org/wiki/哲学家就餐问题)”。

他的贡献包括：

- 提出了目前在[离散数学](https://zh.wikipedia.org/wiki/离散数学)中应用广泛的[最短路径算法](https://zh.wikipedia.org/wiki/Dijkstra算法)（Dijkstra's Shortest Path First Algorithm）
- 为解决[操作系统](https://zh.wikipedia.org/wiki/操作系统)中资源分配问题，提出[银行家算法](https://zh.wikipedia.org/wiki/银行家算法)。

计算科学创始一代最具影响力的人物之一[，[2\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Wirth2005-2)[[3\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Wirth2008-3)[[5\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-LLamport2002-5)[[6\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Lamport_(2015)-6)[[12\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-FOOTNOTELaplante1996-12)[[13\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-FOOTNOTELaplante2008-13) Dijkstra 帮助塑造了作为工程师和[理论家](https://en.wikipedia.org/wiki/Theoretical_computer_science)的新学科。 [[14\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Dijkstra_bio-14)[[15\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-15)他的基本贡献涵盖计算科学的不同领域，包括[编译器结构](https://en.wikipedia.org/wiki/Compiler_construction)、[操作系统](https://en.wikipedia.org/wiki/Operating_system)、[分布式系统](https://en.wikipedia.org/wiki/Distributed_system)、顺序和并发编程、编程范式和方法、[编程语言研究](https://en.wikipedia.org/wiki/Programming_language_research)、程序设计、程序开发、程序验证、软件工程原理、图形算法以及计算机编程和计算机科学的哲学基础。他的许多论文都是新研究领域的来源。现在计算机科学中标准的几个概念和问题首先由迪克斯特拉或他创造的熊名来识别。



### 重要贡献

#### 结构化编程

创造了“结构化编程”这个词语。

#### 并发计算

[并发计算](https://en.wikipedia.org/wiki/Concurrent_computing)的学术研究始于20世纪60年代，Dijkstra（1965年）被誉为该领域的第一篇论文，它识别和解决了[相互排斥](https://en.wikipedia.org/wiki/Mutual_exclusion)的问题。 [[5\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-LLamport2002-5)[[26\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-26)他也是[分布式计算](https://en.wikipedia.org/wiki/Distributed_computing)原理研究的早期先驱之一。他在[并发](https://en.wikipedia.org/wiki/Concurrency_(computer_science))性、[信号、](https://en.wikipedia.org/wiki/Semaphore_(programming))相互排斥、[僵局](https://en.wikipedia.org/wiki/Deadlock)（致命拥抱）、[在图形中寻找最短路径](https://en.wikipedia.org/wiki/Shortest_path_problem)、[容错](https://en.wikipedia.org/wiki/Fault-tolerance)性、[自我稳定](https://en.wikipedia.org/wiki/Self-stabilization)等基础性工作构成了分布式计算领域赖以建立的许多支柱。2002年去世前不久，他因在程序计算的自我稳定方面所从事的工作，获得了[ACM](https://en.wikipedia.org/wiki/Association_for_Computing_Machinery) PODC在分布式计算领域[的影响力论文奖](https://en.wikipedia.org/wiki/PODC_Influential-Paper_Award)。这一年度奖项于次年更名为[迪克斯特拉奖](https://en.wikipedia.org/wiki/Dijkstra_Prize)（分布式计算的埃德格斯·迪克斯特拉奖）。



### 传记

#### 经历

埃德格斯·迪克斯特拉出生于[鹿特丹](https://en.wikipedia.org/wiki/Rotterdam)。他的父亲是一位化学家，曾任[荷兰化学学会会长](https://en.wikipedia.org/wiki/Dutch_Chemical_Society)。他在一所中学教化学，后来又当了校长。他的母亲是数学家，但从来没有一份正式的工作。 [[28\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-28)[[29\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-MacTutor.bio-29)

迪克斯特拉曾考虑从事法律工作，并希望代表荷兰参加[联合国](https://en.wikipedia.org/wiki/United_Nations)会议。然而，1948年毕业后，在父母的建议下，他学习了数学和物理，然后在[莱顿大学](https://en.wikipedia.org/wiki/University_of_Leiden)学习[了理论物理](https://en.wikipedia.org/wiki/Theoretical_physics)。 [[14\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Dijkstra_bio-14)

在20世纪50年代初，[电子计算机](https://en.wikipedia.org/wiki/Electronic_computers)是一种新奇事物。迪克斯特拉偶然发现了他的职业生涯，通过他的主管A.Haantjes教授，他遇到了[阿姆斯特丹数学中心](https://en.wikipedia.org/wiki/Centrum_Wiskunde_%26_Informatica)计算部主任[阿德里亚安·范·维恩加登](https://en.wikipedia.org/wiki/Adriaan_van_Wijngaarden)，他为迪克斯特拉提供了一份工作：1952年3月，他正式成为荷兰第一位"程序员"。 [[14\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Dijkstra_bio-14)

一段时间以来，迪克斯特拉一直致力于物理学，每周三天都在[莱顿](https://en.wikipedia.org/wiki/Leiden)从事物理学研究。然而，随着对计算的接触增加，他的注意力开始转移。正如他回忆的那样：[[30\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-ewd340-30)

> 经过三年的编程，我和当时[在阿姆斯特丹数学中心](https://en.wikipedia.org/wiki/Centrum_Wiskunde_%26_Informatica)当老板的[范·维恩加登](https://en.wikipedia.org/wiki/Adriaan_van_Wijngaarden)进行了讨论，只要我活着，我就会感激他。关键是，我本来应该同时在莱顿大学学习理论物理的，当我发现这两个活动越来越难结合时，我必须下定决心，要么停止编程，成为一名真正、可敬的[理论物理学家](https://en.wikipedia.org/wiki/Theoretical_physicist)，要么只用最少的努力才把我的物理研究正式完成，然后成为......[程序员](https://en.wikipedia.org/wiki/Programmer)？但是，这是一个可敬的职业吗？毕竟，什么是[编程](https://en.wikipedia.org/wiki/Computer_programming)？作为智力上受人尊敬的学科，健全的知识体在哪里？我记得我是如何羡慕我的硬件同事的，当被问及他们的专业能力时，他们至少可以指出，他们知道真空管、放大器和其他的一切，而我觉得，当面对这个问题时，我会袖手旁观。我满怀疑虑地敲了敲范·维恩加登的办公室门，问他我是否可以"跟他说话一会儿"：几个小时后我离开他的办公室时，我是另一个人。因为在耐心地倾听了我的问题之后，他同意，直到那一刻，编程学科还不多，但他接着悄悄地解释，自动计算机在这里停留，我们才刚刚开始，我是不是可以成为未来几年里被召唤使编程成为可敬的学科的人之一？这是我人生的转折点，我尽快正式完成了物理研究。
>
> •埃德格斯·迪克斯特拉，谦逊程序员（EWD340），ACM[的通讯](https://en.wikipedia.org/wiki/Communications_of_the_ACM)

当迪克斯特拉在1957年与玛丽亚（里亚）C.德贝茨结婚时，他被要求作为结婚仪式的一部分来陈述他的职业。他说，他是一名程序员，这是当局不能接受的，当时在荷兰没有这种职业。 [[30\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-ewd340-30)[[31\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-31)

1959年，他获得[阿姆斯特丹大学的](https://en.wikipedia.org/wiki/University_of_Amsterdam)博士学位，论文题目是"与自动计算机通信"，专门描述了为荷兰开发的第一台商用计算机[——Electrologica X1](https://en.wikipedia.org/wiki/Electrologica_X1)设计的[组装语言](https://en.wikipedia.org/wiki/Assembly_language)。他的论文主管是范·维恩加登。 [[16\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Apt,_Krzysztof_R._2002-16)



### 对计算科学的开创性贡献和影响

在他作为计算科学家的四十多年里，Dijkstra在[计算科学](https://en.wikipedia.org/wiki/Computing_science)的许多领域做出了许多开创性的贡献，包括[编译器建设](https://en.wikipedia.org/wiki/Compiler_construction)、[操作系统](https://en.wikipedia.org/wiki/Operating_system)、[并发计算（并](https://en.wikipedia.org/wiki/Concurrent_computing)[发编程](https://en.wikipedia.org/wiki/Concurrent_programming)）、[分布式计算](https://en.wikipedia.org/wiki/Distributed_computing)、[编程范式](https://en.wikipedia.org/wiki/Programming_paradigm)和[方法、](https://en.wikipedia.org/wiki/Programming_methodology)[编程语言研究](https://en.wikipedia.org/wiki/Programming_language_research)、[程序设计](https://en.wikipedia.org/wiki/Software_design)、[程序开发](https://en.wikipedia.org/wiki/Software_development)、[程序验证](https://en.wikipedia.org/wiki/Program_verification)、[软件工程原理](https://en.wikipedia.org/wiki/History_of_software_engineering)、[算法设计](https://en.wikipedia.org/wiki/Algorithm_design)以及[计算机编程和计算机科学的哲学基础](https://en.wikipedia.org/wiki/Philosophy_of_computer_science)。此外，Dijkstra对[计算机科学的教学](https://en.wikipedia.org/wiki/On_the_Cruelty_of_Really_Teaching_Computer_Science)以及[学术计算科学](https://en.wikipedia.org/wiki/Theoretical_computer_science)与[软件产业](https://en.wikipedia.org/wiki/Software_industry)之间的关系也非常感兴趣。

他的主要开创性贡献（包括想法、发明和创新）包括：

- **概念、方法、 原理和理论**： 迪克斯特拉-佐内维尔德[ALGOL 60](https://en.wikipedia.org/wiki/ALGOL_60)[编译器](https://en.wikipedia.org/wiki/Compiler)（第一个完整的工作ALGOL 60编译器），[呼叫堆栈](https://en.wikipedia.org/wiki/Call_stack)，[并发](https://en.wikipedia.org/wiki/Concurrency_(computer_science))，[并发编程](https://en.wikipedia.org/wiki/Concurrent_programming)，[合作顺序过程](https://en.wikipedia.org/wiki/Cooperating_sequential_processes)，[关键部分](https://en.wikipedia.org/wiki/Critical_section)，[致命的拥抱](https://en.wikipedia.org/wiki/Deadly_embrace)（[死锁](https://en.wikipedia.org/wiki/Deadlock)），[餐饮哲学家问题](https://en.wikipedia.org/wiki/Dining_philosophers_problem)，[荷兰国旗问题](https://en.wikipedia.org/wiki/Dutch_national_flag_problem)，[故障 耐受系统](https://en.wikipedia.org/wiki/Fault-tolerant_system)，[无门编程](https://en.wikipedia.org/wiki/Goto-less_programming)，[守卫命令语言](https://en.wikipedia.org/wiki/Guarded_Command_Language)（[守卫命令](https://en.wikipedia.org/wiki/Guard_(computer_science))），[软件架构](https://en.wikipedia.org/wiki/Software_architecture)的[分层结构](https://en.wikipedia.org/wiki/Abstraction_layer)，[抽象水平](https://en.wikipedia.org/wiki/Abstraction_layer)，[多读编程](https://en.wikipedia.org/wiki/Multithreaded_programming)，[相互排斥](https://en.wikipedia.org/wiki/Mutual_exclusion)*（mutex*或*[锁](https://en.wikipedia.org/wiki/Lock_(computer_science))*），[生产者-消费者问题](https://en.wikipedia.org/wiki/Producer–consumer_problem)（[有限制的缓冲问题](https://en.wikipedia.org/wiki/Bounded_buffer_problem)），[程序系列](https://en.wikipedia.org/wiki/Software_product_line)，[谓词变压器语义](https://en.wikipedia.org/wiki/Predicate_transformer_semantics)，[过程同步](https://en.wikipedia.org/wiki/Synchronization_(computer_science)#Thread_or_process_synchronization)，[自我稳定分布系统](https://en.wikipedia.org/wiki/Self-stabilizing_system)[（自我稳定](https://en.wikipedia.org/wiki/Self-stabilization)），[信号灯](https://en.wikipedia.org/wiki/Semaphore_(programming))，[分离的关注](https://en.wikipedia.org/wiki/Separation_of_concerns)，[睡眠理发师问题](https://en.wikipedia.org/wiki/Sleeping_barber_problem)，[结构分析](https://en.wikipedia.org/wiki/Structured_analysis)，[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)，[多程序系统](https://en.wikipedia.org/wiki/THE_multiprogramming_system)，[无限的非确定性](https://en.wikipedia.org/wiki/Unbounded_nondeterminism)，[最弱的先决条件微积分](https://en.wikipedia.org/wiki/Weakest_precondition_calculus)
- **算法**：[迪克斯特拉的算法](https://en.wikipedia.org/wiki/Dijkstra's_algorithm)， [DJP算法](https://en.wikipedia.org/wiki/DJP_algorithm)，[迪克斯特拉-肖尔滕算法](https://en.wikipedia.org/wiki/Dijkstra-Scholten_algorithm)，[德克的算法](https://en.wikipedia.org/wiki/Dekker's_algorithm)（通用），[银行家的算法，](https://en.wikipedia.org/wiki/Banker's_algorithm)[平滑索，](https://en.wikipedia.org/wiki/Smoothsort)[分流码算法](https://en.wikipedia.org/wiki/Shunting-yard_algorithm)，[三色标记算法](https://en.wikipedia.org/wiki/Tracing_garbage_collection#tri-color_marking)，[并发算法](https://en.wikipedia.org/wiki/Concurrent_algorithm)，[分布式算法](https://en.wikipedia.org/wiki/Distributed_algorithm)，[死锁预防算法](https://en.wikipedia.org/wiki/Deadlock_prevention_algorithms)，[相互排斥算法](https://en.wikipedia.org/wiki/Mutual_exclusion)，[自我稳定算法](https://en.wikipedia.org/wiki/Self-stabilization)

### 算法工作

另见：[最短路径问题](https://en.wikipedia.org/wiki/Shortest_path_problem)、[图形算法](https://en.wikipedia.org/wiki/Graph_algorithms)、[并发算法](https://en.wikipedia.org/wiki/Concurrent_algorithm)、[相互排除算法](https://en.wikipedia.org/wiki/Mutual_exclusion)、[死锁预防算法](https://en.wikipedia.org/wiki/Deadlock_prevention_algorithms)、[分布式算法](https://en.wikipedia.org/wiki/Distributed_algorithm)、[自我稳定算法](https://en.wikipedia.org/wiki/Self-stabilizing_algorithm)、[排序算法](https://en.wikipedia.org/wiki/Sorting_algorithms)和[解析算法](https://en.wikipedia.org/wiki/Parsing_algorithms)

[![Dijkstra's algorithm runtime](https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Dijkstra_Animation.gif/220px-Dijkstra_Animation.gif)](https://en.wikipedia.org/wiki/File:Dijkstra_Animation.gif)

迪克斯特拉的算法它选择距离最低的未访问顶点，计算通过它到每个未访问邻居的距离，并在变小时更新邻居的距离。马克访问 （设置为红色） 时， 完成与邻居。

Dijkstra 的算法工作（尤其是[图形算法](https://en.wikipedia.org/wiki/Graph_algorithms)、[并发算法](https://en.wikipedia.org/wiki/Concurrent_algorithm)和[分布式算法](https://en.wikipedia.org/wiki/Distributed_algorithms)）在计算科学的许多领域都发挥着重要作用。据[莱斯利·兰波特](https://en.wikipedia.org/wiki/Leslie_Lamport)（Leslie Lamport）（2002年）称，Dijkstra"以1965年CACM论文《并发编程控制中问题的解决方案》开始了并发和[分布式算法](https://en.wikipedia.org/wiki/Distributed_algorithms)领域，其中他首先陈述并解决了相互排斥的问题。正如兰波特所解释的，"那篇论文大概就是[PODC](https://en.wikipedia.org/wiki/PODC)存在的原因（...）。时至今日，它仍然是该领域最具影响力的报纸。它没有获得[PODC 有影响力的论文奖](https://en.wikipedia.org/wiki/PODC_Influential-Paper_Award)，这反映了并发算法和分布式算法之间的人工分离，这种分离在 Dijkstra 的工作中从未存在过。 [[5\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-LLamport2002-5)

1959年，Dijkstra发表了一篇3页的文章"关于图形连接中的两个问题的说明"，[该算法](https://en.wikipedia.org/wiki/Algorithm)在任意两个给定节点之间的图形中找到最短的路径，现在称为[Dijkstra的算法](https://en.wikipedia.org/wiki/Dijkstra's_algorithm)。它对未来40年的影响摘自[Mikkel Thorup](https://en.wikipedia.org/wiki/Mikkel_Thorup)的文章，"线性时间具有正整数权重的非定向单源最短路径"（1999年）：自1959年以来，SSSP（单源最短路径）中针对一般定向和非定向图形的所有理论发展都基于Dijkstra的算法。迪克斯特拉的算法用于SPF，[最短路径第一](https://en.wikipedia.org/wiki/Shortest_Path_First)，这是用于路由协议[OSPF](https://en.wikipedia.org/wiki/Open_Shortest_Path_First)和[IS-IS。](https://en.wikipedia.org/wiki/IS-IS)许多作者都对Dijkstra的算法进行了各种修改，他们使用[启发式法](https://en.wikipedia.org/wiki/Heuristic_(computer_science))来减少[最短路径搜索](https://en.wikipedia.org/w/index.php?title=Shortest_path_search&action=edit&redlink=1)的运行时间。最常用的启发式算法之一是[A*搜索算法](https://en.wikipedia.org/wiki/A*_search_algorithm)（1968年[斯坦福大学研究所的](https://en.wikipedia.org/wiki/SRI_International)[彼得·哈特](https://en.wikipedia.org/wiki/Peter_E._Hart)、[尼尔斯·尼尔森](https://en.wikipedia.org/wiki/Nils_John_Nilsson)和[伯特拉姆·拉斐尔](https://en.wikipedia.org/wiki/Bertram_Raphael)首次描述[）[35\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-nilsson-35)的主要目标是通过减少搜索空间来缩短运行时间。1956年，迪克斯特拉[在阿姆斯特丹的数学中心](https://en.wikipedia.org/wiki/Centrum_Wiskunde_%26_Informatica)做[程序员](https://en.wikipedia.org/wiki/Computer_programmer)，演示一台名为ARMAC的新[计算机](https://en.wikipedia.org/wiki/Computer)的功能时，想到了[最短的路径问题](https://en.wikipedia.org/wiki/Shortest_path_problem)。他的目标是选择一个问题和一个答案（将由计算机产生），非计算的人可以理解。他设计了[最短的路径算法](https://en.wikipedia.org/wiki/Dijkstra's_algorithm)在大约20分钟内没有纸和笔的帮助，后来实施ARMAC为荷兰64个城市稍微简化的交通地图（使6位足以代表城市的算法）。 [[29\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-MacTutor.bio-29)正如他在2001年发表的一次采访中回忆的那样：[[36\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-36)

> 从鹿特丹到[格罗宁根](https://en.wikipedia.org/wiki/Groningen)的最短旅行方式是什么？这是我在大约二十分钟内设计的[最短路径的算法](https://en.wikipedia.org/wiki/Shortest_path_problem)。一天早上，我和年轻的未婚妻在阿姆斯特丹购物，累了，我们坐在咖啡馆的露台上喝杯咖啡，我只是想着我是否能做到这一点，然后我设计了最短路径的算法。正如我所说，这是一个二十分钟的发明。事实上，它发表在59年，晚了三年。出版物还是可读的，其实挺不错的。它这么好的一个原因是，我设计它没有铅笔和纸。后来我了解到，没有铅笔和纸的设计的好处之一是，你几乎被迫避免所有可以避免的复杂性。最终，这个算法成为我名声的基石之一，令我大为惊讶。
>
> -埃德格斯·迪克斯特拉，在接受菲利普·弗兰纳，ACM 53（8），2001年通讯采访。

一年后，他从在研究所下一台计算机上工作的硬件工程师身上遇到了另一个问题：尽量减少连接机器后面板上的引脚所需的电线数量。作为解决方案，他重新发现了被称为[Prim](https://en.wikipedia.org/wiki/Prim's_algorithm)[的最小跨树算法的算法](https://en.wikipedia.org/wiki/Minimum_spanning_tree)。[普里姆的算法](https://en.wikipedia.org/wiki/Prim's_algorithm)最初是由[捷克](https://en.wikipedia.org/wiki/Czech_people)数学家[沃伊特奇·贾内克](https://en.wikipedia.org/wiki/Vojtěch_Jarník)于1930年开发的。 [[37\]，](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-37)后来由[罗伯特·普里姆](https://en.wikipedia.org/wiki/Robert_C._Prim)于1957年（38[岁）](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-38)和迪克斯特拉于1959年独立重新发现并重新出版。 [[39\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-39)因此，它有时也被称为[DJP算法](https://en.wikipedia.org/wiki/DJP_algorithm)。 [[40\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-pr02-40)

1961年，Dijkstra在[《数学中心](https://en.wikipedia.org/wiki/Mathematisch_Centrum)》报告中首次描述了[分流码算法](https://en.wikipedia.org/wiki/Shunting-yard_algorithm)，这是一种解析[修复符号中](https://en.wikipedia.org/wiki/Infix_notation)指定的数学表达的方法。 [[41\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-41)它可用于以[反向波兰符号](https://en.wikipedia.org/wiki/Reverse_Polish_notation)（RPN） 或[抽象语法树](https://en.wikipedia.org/wiki/Abstract_syntax_tree)（AST） 生成输出。该[算法](https://en.wikipedia.org/wiki/Algorithm)被命名为*分流场*算法，因为它的操作类似于[铁路分流场](https://en.wikipedia.org/wiki/Classification_yard)。分流码算法通常用于实现[操作员优先分析器](https://en.wikipedia.org/wiki/Operator-precedence_parser)。

1962年或1963年，Dijkstra提出了n过程[相互排除](https://en.wikipedia.org/wiki/Mutual_exclusion)算法[的信号波](https://en.wikipedia.org/wiki/Semaphore_(programming))机制[（Dekker算法的](https://en.wikipedia.org/wiki/Dekker's_algorithm)概括），这可能是第一个同时出版的[算法](https://en.wikipedia.org/wiki/Concurrent_algorithm)，并引入了算法研究的新领域。他还发现了[僵局](https://en.wikipedia.org/wiki/Deadlock)问题，并提出了[银行家的算法](https://en.wikipedia.org/wiki/Banker's_algorithm)，[以防止僵局](https://en.wikipedia.org/wiki/Deadlock_prevention_algorithms)。

1974年，Dijkstra提出了三种[自我稳定](https://en.wikipedia.org/wiki/Self-stabilization)算法，用于在戒指上相互排斥。这项工作被认为是第一次介绍和展示自我稳定的概念。 [[42\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-FOOTNOTEDolev200016-42)

在20世纪70年代中期，Dijkstra（与其他作者一起）在[垃圾收集](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))研究中引入了两个有用的抽象（变体和收集器）。变异器提取执行计算的过程，包括分配新的存储单元。收集器是自动回收垃圾的过程。此外，本文还对增量垃圾收集的基本*[三色标记](https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking)*进行了正式化。 [[43\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-43)[[44\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-44)

20世纪80年代初，迪克斯特拉和[卡雷尔·肖尔滕](https://en.wikipedia.org/wiki/Carel_S._Scholten)提出了用于检测[分布式系统](https://en.wikipedia.org/wiki/Distributed_systems)终止的[迪克斯特拉-肖尔滕算法](https://en.wikipedia.org/wiki/Dijkstra–Scholten_algorithm)。

1981年，Dijkstra开发出了[平滑索，](https://en.wikipedia.org/wiki/Smoothsort)一种[基于比较的](https://en.wikipedia.org/wiki/Comparison_sort)[分拣算法](https://en.wikipedia.org/wiki/Sorting_algorithm)和堆[索](https://en.wikipedia.org/wiki/Heapsort)的变异。

### 编程方法的作用和结构化编程运动的诞生

*主要文章：*[软件危机](https://en.wikipedia.org/wiki/Software_crisis)*、*[编程方法](https://en.wikipedia.org/wiki/Programming_methodology)*、*[无 Goto 编程](https://en.wikipedia.org/wiki/Goto-less_programming)*和*[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)

Dijkstra的论点是，如果只允许在纪律严明的高层结构，如[如果当时](https://en.wikipedia.org/wiki/Conditional_(computer_programming))的声明和[循环](https://en.wikipedia.org/wiki/While_loop)，从线性控制流的偏离是更清楚的。这种方法被发展成[结构化的编程运动](https://en.wikipedia.org/wiki/Structured_programming)，他的1972年的书名，与[托尼·霍尔](https://en.wikipedia.org/wiki/Tony_Hoare)和[奥勒-约翰·达尔](https://en.wikipedia.org/wiki/Ole-Johan_Dahl)合著。被许多人视为计算机编程史上的第一次重大运动，结构化编程在20世纪70年代成为新的编程正统观念。

[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)通常被视为"无程序编程"。但正如贝特朗·迈耶所指出的，"正如第一本关于这个主题的书——迪克斯特拉、达尔和霍尔的*结构化编程*]所展示的那样，结构化编程不仅仅是控制结构和[goto。](https://en.wikipedia.org/wiki/Goto)它的主要信息是，编程应被视为基于数学严谨性的科学学科。 [[25\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Meyer2009p188-25) [作为一种编程范式](https://en.wikipedia.org/wiki/Category:Structured_programming_languages)，结构化编程 （ 特别是在 20 世纪 70 年代和 80 年代 ） 极大地影响了许多现代[编程语言](https://en.wikipedia.org/wiki/Programming_languages)的诞生，如[Pascal、[2\]](https://en.wikipedia.org/wiki/Pascal_(programming_language))[[3\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Wirth2008-3)[[60\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-60) C、Modula-2 和[Ada。](https://en.wikipedia.org/wiki/Ada_(programming_language)) [[61\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-61) [Fortran 77](https://en.wikipedia.org/wiki/Fortran_77)版本融合了结构化编程的概念，于 1978 年发布。[C++](https://en.wikipedia.org/wiki/C%2B%2B)语言是流行的[结构化编程语言](https://en.wikipedia.org/wiki/Category:Structured_programming_languages) [C](https://en.wikipedia.org/wiki/C_(programming_language))的扩展和增强版本（另见：基于[C 的编程语言列表](https://en.wikipedia.org/wiki/List_of_C-based_programming_languages)）。由于C++是从一种更传统的[结构化语言](https://en.wikipedia.org/wiki/Category:Structured_programming_languages)发展而来，它是一种"[混合语言](https://en.wikipedia.org/wiki/Multi-paradigm_programming_language)"，而不是一种纯粹的[面向对象的编程](https://en.wikipedia.org/wiki/Object-oriented_programming)语言。 [[62\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-62)

Dijkstra的论点是，如果只允许在纪律严明的高层结构，如[如果当时](https://en.wikipedia.org/wiki/Conditional_(computer_programming))的声明和[循环](https://en.wikipedia.org/wiki/While_loop)，从线性控制流的偏离是更清楚的。这种方法被发展成[结构化的编程运动](https://en.wikipedia.org/wiki/Structured_programming)，他的1972年的书名，与[托尼·霍尔](https://en.wikipedia.org/wiki/Tony_Hoare)和[奥勒-约翰·达尔](https://en.wikipedia.org/wiki/Ole-Johan_Dahl)合著。被许多人视为计算机编程史上的第一次重大运动，结构化编程在20世纪70年代成为新的编程正统观念。

[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)通常被视为"无程序编程"。但正如贝特朗·迈耶所指出的，"正如第一本关于这个主题的书——迪克斯特拉、达尔和霍尔的*结构化编程*]所展示的那样，结构化编程不仅仅是控制结构和[goto。](https://en.wikipedia.org/wiki/Goto)它的主要信息是，编程应被视为基于数学严谨性的科学学科。 [[25\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Meyer2009p188-25) [作为一种编程范式](https://en.wikipedia.org/wiki/Category:Structured_programming_languages)，结构化编程 （ 特别是在 20 世纪 70 年代和 80 年代 ） 极大地影响了许多现代[编程语言](https://en.wikipedia.org/wiki/Programming_languages)的诞生，如[Pascal、[2\]](https://en.wikipedia.org/wiki/Pascal_(programming_language))[[3\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Wirth2008-3)[[60\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-60) C、Modula-2 和[Ada。](https://en.wikipedia.org/wiki/Ada_(programming_language)) [[61\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-61) [Fortran 77](https://en.wikipedia.org/wiki/Fortran_77)版本融合了结构化编程的概念，于 1978 年发布。[C++](https://en.wikipedia.org/wiki/C%2B%2B)语言是流行的[结构化编程语言](https://en.wikipedia.org/wiki/Category:Structured_programming_languages) [C](https://en.wikipedia.org/wiki/C_(programming_language))的扩展和增强版本（另见：基于[C 的编程语言列表](https://en.wikipedia.org/wiki/List_of_C-based_programming_languages)）。由于C++是从一种更传统的[结构化语言](https://en.wikipedia.org/wiki/Category:Structured_programming_languages)发展而来，它是一种"[混合语言](https://en.wikipedia.org/wiki/Multi-paradigm_programming_language)"，而不是一种纯粹的[面向对象的编程](https://en.wikipedia.org/wiki/Object-oriented_programming)语言。 [[62\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-62)

[哈兰·米尔斯](https://en.wikipedia.org/wiki/Harlan_Mills)在他的文章《*结构化编程：回顾与展望*》（1986年）中写道："Edsger W. Dijkstra 1969年的*结构化编程*文章引发了十年来对编程技术的强烈关注，这些技术从根本上改变了人类对[软件开发](https://en.wikipedia.org/wiki/Software_development)的期望和成就。在这十年备受关注之前，编程被视为一项私人的解谜活动，即编写计算机指令以作为程序工作。在这十年之后，编程可以被视为一项基于数学的公开活动，将规格重组为程序。以前，挑战在于让程序运行，然后让程序进一步调试以做正确的事。之后，程序可以预期运行和做正确的事情，很少或根本没有调试。以前，人们普遍认为，任何大型程序都不可能无差错。之后，许多大小程序运行了一年或更年，没有检测到任何错误。由于工业实践的惰性，这些期望和成就并不普遍。但是，它们已经足够成熟，足以预示软件开发的根本性变革。

由Edwin D. Reilly主编*的《计算机科学简明百科全书*》（2004年）指出，"**结构化编程的主要贡献是将编程技术提升到一种艺术和更多的科学的程度，以及证明精心构建的程序可以成为具有足够文学价值的创造性作品，值得人类阅读，而不仅仅是通过计算机阅读**。“



### 软件工程诞生之初的程序设计与开发研究[[编辑](https://en.wikipedia.org/w/index.php?title=Edsger_W._Dijkstra&action=edit&section=12)]

另见：[软件工程史](https://en.wikipedia.org/wiki/History_of_software_engineering)、[软件架构](https://en.wikipedia.org/wiki/Software_architecture)和[关注分离史](https://en.wikipedia.org/wiki/Separation_of_concerns)

Dijkstra 关于[编程方法（](https://en.wikipedia.org/wiki/Programming_methodology)尤其是结构化编程运动）的理念有助于为[软件工程](https://en.wikipedia.org/wiki/Software_engineering)专业学科（特别是软件设计和开发）的诞生和发展奠定基础，使程序员能够组织和管理日益复杂的软件项目。 [[64\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-FOOTNOTEBroyDenert2002[[Category:Wikipedia_articles_needing_page_number_citations_from_September_2020]][[[Wikipedia:Citing_sources|page needed]]]-64)[[65\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-FOOTNOTEHenderson2009[[Category:Wikipedia_articles_needing_page_number_citations_from_September_2020]][[[Wikipedia:Citing_sources|page needed]]]-65)在 20 世纪 60 年代末， 迪克斯特拉讨论了计划家庭的概念。在20世纪70年代中期，[大卫·帕纳斯](https://en.wikipedia.org/wiki/David_Parnas)等人澄清了这个想法，并展示了如何将其应用于软件工程原理。

[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)运动的兴起导致许多其他*[结构化](https://en.wikipedia.org/wiki/Structured_analysis)*的方法应用于[软件设计](https://en.wikipedia.org/wiki/Software_design)。[结构分析](https://en.wikipedia.org/wiki/Structured_analysis)和[结构化设计](https://en.wikipedia.org/wiki/Structured_design)技术是结构化编程概念和技术以及模块化设计早期思想的产生。[拉里·康斯坦丁](https://en.wikipedia.org/wiki/Larry_Constantine)的[耦合](https://en.wikipedia.org/wiki/Coupling_(computer_programming))概念（在模块之间尽量减少）和[凝聚力](https://en.wikipedia.org/wiki/Cohesion_(computer_science))（在模块内最大化），[大卫·帕纳斯](https://en.wikipedia.org/wiki/David_Parnas)[的信息隐藏](https://en.wikipedia.org/wiki/Information_hiding)技术，以及[抽象的数据类型](https://en.wikipedia.org/wiki/Abstract_data_types)，强化了模块化原则。 [[66\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-66)开发了一些采用[结构化概念的](https://en.wikipedia.org/wiki/Structured_analysis)工具和方法，如[结构设计](https://en.wikipedia.org/wiki/Structured_Design)、[杰克逊的结构化编程](https://en.wikipedia.org/wiki/Jackson_Structured_Programming)、[罗斯](https://en.wikipedia.org/wiki/Douglas_T._Ross)[的结构分析和设计技术](https://en.wikipedia.org/wiki/Structured_Analysis_and_Design_Technique)（SADT）、[尤顿的结构化方法](https://en.wikipedia.org/wiki/Edward_Yourdon#Yourdon_Structured_Method)、[结构化系统分析和设计方法](https://en.wikipedia.org/wiki/Structured_Systems_Analysis_and_Design_Method)（SSADM） 以及詹姆斯·马丁的[信息技术工程](https://en.wikipedia.org/wiki/Information_technology_engineering)。[软件指标](https://en.wikipedia.org/wiki/Software_metrics)领域通常被认为是 20 世纪 70 年代结构化编程运动对[软件工程](https://en.wikipedia.org/wiki/Software_engineering)的直接影响。

[关注](https://en.wikipedia.org/wiki/Separation_of_concerns)（SoC）是[软件工程](https://en.wikipedia.org/wiki/Software_engineering)的基本原则之一，是将[计算机程序](https://en.wikipedia.org/wiki/Computer_program)分成不同部分的设计原则，因此每个部分都解决了一个单独[的问题](https://en.wikipedia.org/wiki/Concern_(computer_science))。Dijkstra在1974年的论文《关于科学思想的作用》中提出了*["关注分离](https://en.wikipedia.org/wiki/Separation_of_concerns)*"一词。



### 并发计算（并发编程）[[编辑](https://en.wikipedia.org/w/index.php?title=Edsger_W._Dijkstra&action=edit&section=14)]

主要文章：[并发 （计算机科学），](https://en.wikipedia.org/wiki/Concurrency_(computer_science))[并发计算](https://en.wikipedia.org/wiki/Concurrent_computing)，[并发编程](https://en.wikipedia.org/wiki/Concurrent_programming)，[并发算法](https://en.wikipedia.org/wiki/Concurrent_algorithm)，[餐饮哲学家问题](https://en.wikipedia.org/wiki/Dining_philosophers_problem)，[相互排斥](https://en.wikipedia.org/wiki/Mutual_exclusion)，[信号 （编程）](https://en.wikipedia.org/wiki/Semaphore_(programming))和[合作顺序过程](https://en.wikipedia.org/wiki/Cooperating_sequential_processes)

> 虽然[并发程序](https://en.wikipedia.org/wiki/Concurrent_programming)执行已考虑多年，[但并发计算机科学](https://en.wikipedia.org/wiki/Concurrency_(computer_science))始于埃德斯格·迪克斯特拉1965年开创性的论文，该论文提出了[相互排斥](https://en.wikipedia.org/wiki/Mutual_exclusion)问题。(...)需要研究的第二个基本并发编程问题是生产者与消费者的同步。这种[形式的同步](https://en.wikipedia.org/wiki/Synchronization_(computer_science))在最早的计算机的硬件级别上使用，但 Dijkstra 在 1965 年首次将其确定为并发问题，但直到 1968 年才在该配方中发布。(...)[分布式系统](https://en.wikipedia.org/wiki/Distributed_system)之后，[并发算法](https://en.wikipedia.org/wiki/Concurrent_algorithm)的下一个主要步骤是研究[容错性](https://en.wikipedia.org/wiki/Fault_tolerance)。第一次对容错性进行科学考察的是迪克斯特拉1974年关于[自我稳定](https://en.wikipedia.org/wiki/Self-stabilization)的开创性论文。然而，正如有时发生在超前工作时的情况一样，该论文很少受到关注，基本上被遗忘了十年。(...)在随后的几十年中，人们对并发系统的兴趣有了巨大的增长，特别是在分布式系统方面。回顾这一领域的起源，最突出的是埃德斯格·迪克斯特拉所扮演的基本角色，而这一历史正是他所奉献的。
>
> •[莱斯利·兰波特](https://en.wikipedia.org/wiki/Leslie_Lamport)，*图灵讲座： 并发计算机科学： 早年*（2015年6月）[[6\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Lamport_(2015)-6)

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Rail-semaphore-signal-Dave-F.jpg/170px-Rail-semaphore-signal-Dave-F.jpg)](https://en.wikipedia.org/wiki/File:Rail-semaphore-signal-Dave-F.jpg)

一个[信号（](https://en.wikipedia.org/wiki/Semaphore_(programming))[荷兰](https://en.wikipedia.org/wiki/Dutch_language)语：*塞恩帕尔*），在迪克斯特拉的原始论文中使用的术语。 [[71\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-71) 20 世纪 60 年代初，Dijkstra 提出了第一个并发过程的同步机制，即其两个操作[的信号信号，P](https://en.wikipedia.org/wiki/Semaphore_(programming))和 V。

在1965年的一篇长达一页的论文中，迪克斯特拉介绍了n进程中的"[相互排斥](https://en.wikipedia.org/wiki/Mutual_exclusion)问题"，并讨论了解决该问题的办法。这可能是第一次发布[并发算法](https://en.wikipedia.org/wiki/Concurrent_algorithm)。 [[6\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Lamport_(2015)-6)[[16\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-Apt,_Krzysztof_R._2002-16)本文还提出了"[关键部分](https://en.wikipedia.org/wiki/Critical_section)"的概念，标准是现在。作为[并发计算](https://en.wikipedia.org/wiki/Concurrent_computing)领域的先驱[，Per Brinch Hansen](https://en.wikipedia.org/wiki/Per_Brinch_Hansen)认为 Dijkstra*的合作顺序过程*（1965 年）是并发编程中[的第一篇经典论文](https://en.wikipedia.org/wiki/List_of_important_publications_in_concurrent,_parallel,_and_distributed_computing)。正如布林奇·汉森所指出的，"迪克斯特拉为抽象并发编程奠定了概念基础"。 [[72\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-FOOTNOTEBrinch_Hansen20028-72)

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Mutual_exclusion_example_with_linked_list.png/220px-Mutual_exclusion_example_with_linked_list.png)](https://en.wikipedia.org/wiki/File:Mutual_exclusion_example_with_linked_list.png)

两个过程同时修改链接列表并导致冲突的简单示例。Dijkstra在1965年题为"*解决并发编程控制中的问题"的*开创性论文中首次发现并解决了[相互排斥](https://en.wikipedia.org/wiki/Mutual_exclusion)的要求，并被誉为[并发算法](https://en.wikipedia.org/wiki/Concurrent_algorithm)研究的第一个课题。

1968年，迪克斯特拉发表了他的开创性论文《[合作顺序过程](https://en.wikipedia.org/wiki/Cooperating_sequential_processes)》，这是一篇70页的文章，起源于[并发编程](https://en.wikipedia.org/wiki/Concurrent_programming)领域。他在其中讨论了[相互排斥](https://en.wikipedia.org/wiki/Mutual_exclusion)[的概念](https://en.wikipedia.org/wiki/Mutex)和令人满意的解决办法应满足的标准。他还纠正了1965年论文中遗漏的历史观点，将[第一个已知的正确解决相互排斥问题的办法](https://en.wikipedia.org/wiki/Dekker's_algorithm)包括在内，这两个过程是西奥[多鲁斯·德克](https://en.wikipedia.org/wiki/Theodorus_Dekker)所为。迪克斯特拉随后概括了[德克对](https://en.wikipedia.org/wiki/Dekker's_algorithm)n 流程的解决方案。 [[73\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-73)[[74\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-74)此外，他提出了第一个并发过程[的同步机制](https://en.wikipedia.org/wiki/Synchronization_(computer_science))[，[75\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-75) [信号灯](https://en.wikipedia.org/wiki/Semaphore_(programming))及其两个操作，P 和 V。他还确定了"[死锁](https://en.wikipedia.org/wiki/Deadlock)问题"（称为"[致命拥抱](https://en.wikipedia.org/wiki/Deadly_embrace)问题"）[76]，并提出了一个优雅[的"银行家算法](https://en.wikipedia.org/wiki/Banker's_algorithm)"，[以防止僵局](https://en.wikipedia.org/wiki/Deadlock_prevention_algorithms)。 僵局检测和预防成为并发方案编制领域的常年研究问题。

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/220px-An_illustration_of_the_dining_philosophers_problem.png)](https://en.wikipedia.org/wiki/File:An_illustration_of_the_dining_philosophers_problem.png)

餐饮哲学家问题的例证

[餐饮哲学家问题是](https://en.wikipedia.org/wiki/Dining_philosophers_problem)一个示例问题，经常用于[并发](https://en.wikipedia.org/wiki/Concurrency_(computer_science))算法设计，以说明[同步](https://en.wikipedia.org/wiki/Synchronization_(computer_science))问题和解决这些问题的技术。它最初是由Dijkstra在1965年制定的，作为学生考试练习，以计算机[竞争访问](https://en.wikipedia.org/wiki/Resource_contention)[磁带驱动器](https://en.wikipedia.org/wiki/Tape_drive)外设的形式提出。不久之后，[托尼·霍尔](https://en.wikipedia.org/wiki/Tony_Hoare)给出了问题目前的配方。 [[77\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-77) [睡眠理发师问题](https://en.wikipedia.org/wiki/Sleeping_barber_problem)也归因于迪克斯特拉。

米歇尔·雷纳尔 （2012） 写道， "自从 E.W. Dijkstra（1965 年）的早期作品引入了相互排斥问题、过程概念、信号对象、[最弱先决条件](https://en.wikipedia.org/wiki/Weakest_precondition)的概念和[守卫命令](https://en.wikipedia.org/wiki/Guarded_commands)（以及其他许多贡献）以来，[同步](https://en.wikipedia.org/wiki/Synchronization_(computer_science))不再是技巧目录，而是具有自身概念、机制和技术的计算科学领域，其结果可应用于许多领域。这意味着过程同步必须成为任何计算机科学课程的主要主题。 [[78\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-78)

John W. McCormick 等人（2011 年）指出，"埃德格斯·迪克斯特拉（1968 年）首次引入了[并发程序](https://en.wikipedia.org/wiki/Concurrent_program)作为编写[并行程序](https://en.wikipedia.org/wiki/Parallel_program)而不考虑基础硬件的手段的概念。[Moti](https://en.wikipedia.org/wiki/Moti_Ben-Ari) Ben-Ari（1982 年）用三句话优雅地概括了 Dijkstra 的想法："并发编程是编程符号和表达潜在并行性以及解决由此产生的同步和通信问题的技术的名称。实施并行是计算机系统（硬件和软件）中的一个主题，基本上独立于并发编程。并发编程很重要，因为它提供了一个抽象的环境，在这种环境中，可以研究并行性，而不会陷入实施细节的泥潭。 [[79\]](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra#cite_note-79)



### 个人感想

1. 父亲是化学家及老师，母亲是数学家。然后他自己学的数学和物理。后来做物理论文的时候接触了计算机科学，最终发现自己更加喜欢计算机科学，于是把物理论文完成之后就开始了计算机科学生涯；
2. 