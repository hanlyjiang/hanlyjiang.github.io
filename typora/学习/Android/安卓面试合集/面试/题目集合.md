

![image-20211010113936845](images/image-20211010113936845-3837178.png)



## 蔡绍朋

### java集合

**Java集合类型：**

* Collection
  * Set：
    * 无法包含重复元素
  * List
    * 有序集合
    * 无法包含重复元素
  * Queue
    * 持有一些待处理的元素
    * 一般是FIFO（先进先出的）
    * 一端操作
  * Deque
    * 可以FIFO，也可以LIFO（后进先出）
    * 可以双端操作
* Map
  * 映射键值对
  * SortedMap

## View绘制流程

[Android App性能评测分析－流畅度篇 - StarryFan - 博客园 (cnblogs.com)](https://www.cnblogs.com/cloudiest/p/8485711.html)

一秒60次，16ms一次。

Android系统每隔16ms发出VSYNC（垂直同步）信号，触发GPU对UI进行渲染，如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候由于还没有准备好，就无法进行更新任何内容，那么用户在32ms内看到的会是同一帧画面（卡顿现象），即丢帧现象。

内容输出到帧缓存中，垂直同步的时候从其中取出绘制到屏幕上面，如果16ms内没有准备好，那么就不会刷新屏幕，出现掉帧。



[Java中HashMap底层原理源码分析_张康的博客-CSDN博客](https://blog.csdn.net/csdn15698845876/article/details/79495340?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&spm=1001.2101.3001.4242)



## 内存泄漏

### leak canary 原理

> https://cloud.tencent.com/developer/article/1675655

**RefWatcher**

**RefWatcher 会使用 WeakRefrence 持有那些被销毁的对象，使用一个随机key，标示被销毁的对象。**

LeakCanary 中当一个 Activity 需要被回收时，就将其包装到一个 WeakReference 中，并且在 WeakReference 的构造器中传入自定义的 ReferenceQueue。

然后给包装后的 WeakReference 做一个标记 Key，并且在一个强引用 Set 中添加相应的 Key 记录。

最后主动触发 GC，遍历自定义 ReferenceQueue 中所有的记录，并根据获取的 Reference 对象将 Set 中的记录也删除

**经过上面 3 步之后，还保留在 Set 中的就是：应当被 GC 回收，但是实际还保留在内存中的对象，也就是发生泄漏了的对象。**

* 记录WeakRefrerence
* 对应时机触发GC
* 检测Ref是否还存在

> 引用类型说明：
>
> * 弱引用：没有强引用之后，就可以清除了
>   * 软引用：没有强引用之后，还可以保存，直到需要内存（OOM之前清除），一般可以用作内存缓存。





## HashMap 红黑树

红黑树： https://zhuanlan.zhihu.com/p/79980618

HashMap底层实现原理：https://blog.csdn.net/weixin_49822811/article/details/113804402

红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:

1. 每个节点都有红色或黑色
2. 树的根始终是黑色的 (黑土地孕育黑树根， )
3. 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，**并没有说不能出现连续的黑色节点**）
4. 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点

瞬间懵逼？**了解一下印象就行**，开始玩魔方都是要照着魔方公式一点点玩的，多玩几次就熟悉了。红黑树也一样，红黑树有两大操作:

1. recolor (重新标记黑色或红色)
2. rotation (旋转，这是树达到平衡的关键)

