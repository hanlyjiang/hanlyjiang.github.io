# Android开发中的AOP技术

> [Android开发中的AOP技术 - 简书 (jianshu.com)](https://www.jianshu.com/p/c40528c8df17)

> 如需转载请评论或简信，并注明出处，未经允许不得转载

## 目录

![img](https://upload-images.jianshu.io/upload_images/10992781-9f0807f25857bda0.png?imageMogr2/auto-orient/strip|imageView2/2/w/739/format/webp)

## 前言

AOP的中文解释是面向切面编程，是一种**编程范式**

> 面向过程编程 、面向对象编程、函数式编程、事件驱动编程这些都是属于编程范式

## OOP与AOP的区别

OOP（面向对象编程）针对业务处理过程的**实体及其属性和行为进行抽象封装**，以获得更加清晰高效的逻辑单元划分

AOP（面向切面编程）则是针对业务处理过程中的切面进行提取，它所面对的是**处理过程中的某个步骤**，以获得逻辑过程中各部分之间低耦合性的隔离效果。AOP解决的**特定**问题，不是解决所有问题。（也就是说它和OOP不是竞争关系，而是互补的关系）

我们在软件开发时经常提一个词叫做“业务逻辑”，我们的代码主要就是实现某种特定的业务逻辑。但是我们往往不能专注于业务逻辑，比如我们写业务逻辑代码的同时，还要写埋点、日志等等通用化的功能，而且每个业务功能都要和这些业务功能混在一起，不仅开发起来不舒服，而且也会增加代码的复杂度。传统的面向对象编程中，每个单元就是一个类，而类似于埋点这方面的问题，它们通常不能集中在一个类中处理因为它们横跨多个类，这就导致了代码无法重用，可维护性差而且产生了大量代码冗余，这是我们不愿意看到的

总的来说，AOP的出现是为了**将业务性需求和功能性需求分离开来，并将这些功能集中起来，放到一个统一的地方来控制和管理**

![img](https://upload-images.jianshu.io/upload_images/10992781-cf8e100c612608ba.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

本系列的文章将带你一步步理解AOP的思想，并帮助你在实际项目中使用它，从而提升代码质量和工作效率

## AOP术语

- **连接点（Joinpoint）**

程序执行的某个特定位置：如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。连接点由两个信息确定：**第一是用方法表示的程序执行点；第二是用相对点表示具体的方位**

- **切点（Pointcut）**

每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物。AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而**切点相当于查询条件**。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点

- **增强（Advice）**

增强是织入到目标类连接点上的一段程序代码

- **目标对象（Target）**

被织入增强逻辑的类。如果没有AOP，目标业务类需要自己实现所有逻辑，而在AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用AOP动态织入到特定的连接点上

- **织入（Weaving）**

织入是将增强添加对目标类具体连接点上的过程。AOP像一台织布机，将目标类、增强或引介通过AOP这台织布机天衣无缝地编织到一起。根据不同的实现技术，AOP有三种织入的方式：

a、**编译期织入**，这要求使用特殊的Java编译器

b、**类装载期织入**，这要求使用特殊的类装载器

c、**动态代理织入**，在运行期为目标类添加增强生成子类的方式

Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入

- **代理（Proxy）**

一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类

- **切面（Aspect）**

切面由切点和增强（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义，切面可以看做是一个切点的管理中心

## 常用AOP实现方式

之前说了AOP是一种编程范式，也就是一种方法论，而实现AOP则需要一些技术手段。一般就是采用一些**注入代码**的方式，那么**要在什么时候什么地方注入代码呢**？根据android编译执行流程来看，不同的时期都有机会可以注入代码。我们来看下面这张图

![img](https://upload-images.jianshu.io/upload_images/10992781-6fa2827d2a2dc8d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

### APT

APT （`Annotation Processing Tool` ）即注解处理器，是一种处理注解的工具，确切的说它是 javac 的一个工具，它用来在编译时扫描和处理注解。注解处理器以 Java 代码（ 或者编译过的字节码）作为输入，生成 .java 文件作为输出。简单来说就是在编译期，通过注解生成 .java 文件。使用的 `Annotation` 类型是 `SOURCE`

代表框架：DataBinding、Dagger2、ButterKnife、EventBus3、DBFlow、AndroidAnnotation

特点：

1. 只能生成.java文件，而**不能在现有类中插入代码**
2. 可以通过`javapoet`来简化.java的生成操作
3. 会在运行时产生一些代理类的缓存，增加了内存的负担，所以在选择这些框架的时候要根据自己的实际项目谨慎选择

详细介绍：[手把手教你实现仿ButterKnife依赖注入框架](https://www.jianshu.com/p/40c62ebf53e0)

### AspectJ

AspectJ是一个代码生成框架，它扩展了Java语言，定义了AOP语法，所以它有一个**专门的编译器用来生成遵守Java字节编码规范的Class文件**

特点：

1. 代码侵入性较低
2. 可以在.java文件被编译成.class的过程中，**在连接点的前后插入目标代码**
3. 使用较为简单
4. 除了 hook 之外，还可以为目标类添加变量，接口，也有抽象，继承等各种更高级的玩法
5. 无法兼容Lambda语法
6. 无法织入第三方库

详细介绍：[Android AOP — AspectJ的使用](https://www.jianshu.com/p/8582f896d136)

### Javassist

Javassist 是一个编辑字节码的框架，作用是修改编译后的 class 字节码，ASM也有这个功能，不过 Javassist 的 Java 风格 API 要比 ASM 更容易上手

既然是修改编译后的 class 字节码，首先我们得知道什么时候编译完成，并且我们要在 .class文件被转为 .dex 文件之前去做修改。在 Gradle Transfrom 这个 api 出来之前，想要监听项目被打包成 .dex 的时机，就必须自定义一个 Gradle Task，插入到 predex 或者 dex 之前，在这个自定义的 Task 中使用 Javassist 或者 ASM 对 class 字节码进行操作。而 Transform 更为方便，我们不再需要插入到某个Task前面。Tranfrom 有自己的执行时机，一经注册便会自动添加到 Task 执行序列中，且正好是 class 被打包成dex之前

代表框架：热修复框架HotFix 、Savior（InstantRun）

详细介绍：[待完善](https://www.jianshu.com/p/c40528c8df17)

特点：

1. 直接操作修改编译后的字节码，直接绕过了java编译器，所以可以做很多突破限制的事情，例如，跨 dex 引用，解决热修复中 CLASS_ISPREVERIFIED 问题
2. 相对ASM易上手

### ASM

ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。说白了asm是直接通过字节码来修改class文件

代表框架：一些主流的无埋点框架

特点：

1. 直接操作修改编译后的字节码
2. 学习成本高，需要掌握JVM指令
3. 小巧轻便、性能好，效率比Javassist高

> 这里介绍一个小技巧：如果你对JVM指令不是特别熟，但是现在希望用到ASM框架，那么也没有任何问题，你可以将你希望生成的代码进行反编译，就可以拿到对应的JVM指令

详细介绍：[待完善](https://www.jianshu.com/p/c40528c8df17)

### 动态代理模式

动态代理是Java语言中非常经典的一种设计模式，它可以直接给某一个目标(被代理 对象)对象(实现了某个或者某些接口)生成一个代理对象，而不需要代理类存在

代表框架：Retrofit、Spring

特点：

1. 动态代理模式是运行时的织入方式，用到了反射技术，所以性能相对会差一点
2. 动态代理模式与静态代理模式原理是一样的，只是它没有具体的代理类，直接通过反射生成了一个代理对象
3. jdk提供一个Proxy类可以直接给实现接口类的对象直接生成代理对象 API

详细介绍：[待完善](https://www.jianshu.com/p/c40528c8df17)

## AOP的运用场景

- **参数校验和判空**

系统之间在进行接口调用时，往往是有入参传递的，入参是接口业务逻辑实现的先决条件，有时入参的缺失或错误会导致业务逻辑的异常，大量的异常捕获无疑增加了接口实现的复杂度，也让代码显得雍肿冗长，因此提前对入参进行验证是有必要的，可以提前处理入参数据的异常，并封装好异常转化成结果对象返回给调用方，也让业务逻辑解耦变得独立

- **Android API23+的权限控制**

避免到处都是申请权限和处理权限的代码

- **无埋点**

分离业务代码和统计代码

- **安全控制**

比如全局的登录状态流程控制

- **日志记录**

侵入性更低更利于管控的日志系统

- **事件防抖**

防止View被连续点击触发多次事件

- **性能统计**

检测方法耗时其实已经有一些现成的工具，比如 trace view。痛点是这些工具使用起来都比较麻烦，效率低下，而且无法针对某一个块代码或者某个指定的sdk进行查看方法耗时。可以采用 AOP 思想对每个方法做一个切点，在执行之后打印方法耗时

- **事务处理**

声明方法，为特定方法加上事务，指定情况下（比如抛出异常）回滚事务

- **异常处理**

替代防御性的 try-Catch

- **缓存**

缓存某方法的返回值，下次执行该方法时，直接从缓存里获取

- **软件破解**

使用 Hook 修改软件的验证类的判断逻辑