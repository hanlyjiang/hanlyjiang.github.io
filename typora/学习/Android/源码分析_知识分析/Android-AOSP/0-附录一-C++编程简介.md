# C++简介

为分析Android源码时，有很多CPP的代码，所以我们需要了解一些基础的C++知识。



## 待了解的

* C++的继承，多继承，单继承
* virtual 
* 方法重载

## C++知识目录

下面按照C++ Primer Plus 第六版的目录列出了C++的知识结构，本文将采取用到再补充的形式，只对部分概念先行记录。

* **基础知识**
  * main函数
  * 注释
  * 预处理器
  * iostream
  * 头文件
  * 命名空间
  * 基础常用语句
    * cout
    * cin
  * 变量
  * 常量
  * 运算符
    * 运算符优先级和结合性
    * 求模运算
* **数据类型**
  * 基本类型
    * 整型：short，int，long，long long
    * 无符号整型
    * 整型字面量
    * char
    * bool
    * 浮点类型
    * 类型转换
  * 复合类型
    * 数组
    * 字符串及string类
    * 结构
    * 共用体
    * 枚举
    * 指针和自由存储空间
    * 类型组合
    * 模板类（数组替代品）
* **控制流语句，分支逻辑和表达式**
  * for循环
  * while循环
  * do while循环
  * 基于范围的for循环（C++11）
  * 示例
    * 循环和文本输入
    * 嵌套循环和二位数组
  * if 语句
    * if else 
    * if else if else
  * 逻辑表达式
    * OR
    * AND
    * NOT
  * `?:` 运算符
  * switch 语句
  * break 和 continue 语句
  * 应用示例
    * 字符函数库 cctype
    * 读取数字的循环
    * 简单文件输入/输出

* **编程模块-函数**
  * 函数定义：原型及调用
  * 函数参数及参数按值传递
  * 函数指针
  * 应用示例：
    * 数组作为参数
    * 二维数组作为参数
    * C风格字符串作为参数/返回值
    * 函数与string
    * 函数与array
    * 递归
  * 引用变量
  * 默认参数
  * 函数重载
  * 函数模板
* **内存模型及命名空间**
  * 单独编译
  * 存储持续性、作用和链接性
  * 名称空间
* **对象和类**
  * 类基础
    * 面向对象编程
    * 类是什么？
    * 构造函数和析构函数
    * this指针
    * 对象数组
    * 类作用域
    * 抽象数据类型
  * 运算符重载
  * 友元
  * 类的自动转换和强制类型转换
    * 转换函数
    * 转换函数和友元函数
  * 类和动态内存分配
    * 动态内存
    * 改进后的新String类
    * 在构造函数中使用new应注意的事项
    * 返回对象说明（const与非const返回对象）
    * 使用指向对象的指针
    * 应用示例
      * 队列模拟
      * 复习各种技术
  * 类继承
    * 继承，基类和派生类
    * 多态
    * 静态联编和动态联编
    * 访问控制-protected
    * 抽象基类
    * 继承和动态内存分配
    * 总结
      * 类设计回顾
* **C++ 中的代码重用**
  * 包含对象成员的类
  * 私有继承
  * 多重继承
  * **类模板**
    * 定义及使用
    * 模块的多功能性及具体化
    * 成员模板
    * 模板作为参数
    * 模板类和友元
* **友元、异常和其他**
  * 友元
  * 嵌套类
  * 异常
  * RTTI
  * 类型转换运算符
* **string类和标准模板库**
  * string类
  * 智能指针模板类
  * 标准模板库
    * vector
  * 泛型编程
    * 迭代器
    * 容器种类及关联容器
  * 函数对象
    * 函数符
    * 函数适配器
  * 算法
    * 算法组
    * STL和string类
* **输入、输出和文件**
  * C++输入及输出介绍
    * 流和缓存区
    * 流、缓存出和iostream文件
    * 重定向
  * count输出
  * cin输入
  * 文件输入和输出
  * 内核格式化
* **C++ 11**
  * C++11是什么
  * 新类型
  * 统一的初始化
  * 声明
  * 智能指针
  * 异常规范修改
  * 作用域内枚举
  * 模版和STL的修改
  * 右值引用
  * 移动语义
  * 新的类功能
    * 特殊的成员函数
    * 默认的方法和禁用的方法
    * 委托构造函数
    * 继承构造函数
    * 管理虚方法override和final
  * Lambda函数
    * 比较函数指针、函数符和Lambda函数
  * 包装器
  * 可变参数模板
  * C++11新增加的其他功能
    * 并行编程
    * 新增的库
    * 低级编程
    * 杂项
  * 语言变化
    * Boost项目
    * TRI



## 基础知识

> * main函数
> * 注释
> * 预处理器
> * iostream
> * 头文件
> * 命名空间
> * 基础常用语句
>   * cout
>   * cin
> * 变量
> * 常量
> * 运算符
>   * 运算符优先级和结合性
>   * 求模运算

接下来将优先介绍：

* 预处理器
* 命名空间

### 预处理器

#### 概览

```cpp
#include <iostream>

int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout << "Hello, World!\n";
    return 0;
}
```

上方的 `#` 开头的就是预处理器

* CPP使用了和C一样的预处理器，会在进行主编译之前对源文件进行处理。
* 程序员无需进行任何操作，编译程序会自动运行这些预处理指令。
* 上方示例中 `#include <iostream>`，预处理器会将iostream的文件内容添加到程序中组合成一个复合文件，然后进行编译。

#### C的预处理指令介绍

C语言建立在适当的关键字、表达式、语句以及使用它们的规则上。然而，C标准不仅描述C语言，还描述如何执行C预处理器、C标准库有哪些函数，以及详述这些函数的工作原理。

C预处理器在程序执行之前查看程序(故称之为预处理器)。根据程序中的预处理器指令，预处理器把符号缩写替换成其表示的内容。预处理器可以包含程序所需的其他文件，可以选择让编译器查看哪些代码。预处理器并不知道C。==基本上它的工作是把一些文本转换成另外一些文本==。

预处理器开始处理的逻辑如下：

1. 在预处理之前，编译器需要对程序源码进行一些翻译处理
   * 首先将源代码中出现的字符映射到源字符集。
   * 定位每个反斜杠后面跟着的换行符的实例，并删除它们 - 把两个物理行转换成一个逻辑行。（预处理表达式的长度必须是一个逻辑行，这里是在为预处理器做准备）
   * 将文本划分成预处理记号序列、空白序列和注释序列。（记号是由空格、制表符或换行符分隔的项），编译器兼用一个空格字符替换每一条注释。
2. 现在程序已经准备好进入预处理阶段了。预处理器查找一行中以#号开始的预处理指令，然后进行处理。

下面对C中定义的各个预处理器指令进行介绍。

#### `#define` - 定义明示常量-宏

* 预处理处理范围：以#号作为一行的开始，直到后面的第一个换行符。（逻辑行）
* 构成：`#define 宏 替换列表/替换体`
  * 宏名称中不允许有空格，且必须遵循C变量命名规则。宏可以表示任何字符串，甚至可以表示整个C表达式。
* 预处理规则：一旦预处理器在程序中找到宏的示实例后，就会用替换体代替该宏(也有例外）。
* 编译器在编译期对所有的常量表达式(只包含常量的表达式)求值，预处理器不做计算，不对表达式求值，它只进行替换



##### 在 #define 中使用参数

在#define中使用参数可以创建外形和作用与函数类似的类函数宏。带有参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆 括号中可以有一个或多个参数，随后这些参数出现在替换体中

<img src="https://gitee.com/hanlyjiang/image-repo/raw/master/imgs/20210405183844.png" alt="image-20210405183844239" style="zoom:50%;" />

##### 使用宏参数创建字符串：#运算符

在字符串中使用#将参数作为可替换的记号（而不是普通文本）

如下示例中，可以看到`#x`不再是直接输出，而是被替换为宏函数的参数：

```c
#include <stdio.h>

#define PSQR(x) printf("The square of " #x " is %d.\n",((x)*(x)))

int main(void){
    int y = 5;
    PSQR(y);
    PSQR(2 + 4);
    return 0;
}

```

输出：

```shell
The square of y is 25.
The square of 2 + 4 is 36.
```

##### 预处理器黏合剂：##运算符

`##`运算符可用于类函数宏的替换部分，及对象宏的替换部分，可以将两个记号组合成一个记号。

看如下示例：

```c
#include <stdio.h>

#define XNAME(n) x ## n
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);

int main(void)
{
    int XNAME(1) = 14;   // 变成 int x1 = 14;
    int XNAME(2) = 20;  // 变成 int x2 = 20;
    int x3 = 30;

    PRINT_XN(1);      // 变成 printf("x1 = %d\n", x1);
    PRINT_XN(2);      // 变成 printf("x2 = %d\n", x2);
    PRINT_XN(3);      // 变成 printf("x3 = %d\n", x3); 
    return 0;
}

```

输出：

```
x1 = 14
x2 = 20
x3 = 30
```



##### 变参宏:`...`和`__VA_ARGS__`

一些函数接受数量可变的参数，通过报宏参数列表中最后的参数写成省略号，可以实现一样的功能。

`__VA_ARGS__`可用在替换部分中，表明省略号代表的参数。

如下示例：

```c
#include <stdio.h>

#include <math.h>
#define PR(X, ...) printf("Message " #X ": " __VA_ARGS__)

int main(void)
{
    double x = 48;
    double y;
    y = sqrt(x);
    PR(1, "x = %g\n", x);
    PR(2, "x = %.2f, y = %.4f\n", x, y);
    return 0;
}
```

输出如下：

```shell
Message 1: x = 48
Message 2: x = 48.00, y = 6.9282
```

##### 宏和函数的选择

* 使用宏比普通函数复杂一些，稍有不慎会产生奇怪的副作用。
* 宏和函数的选择实际上是时间和空间的权衡；
  * 宏生成内联代码，即在程序中生成语句，如果调用20次宏，即在程序中插入20行代码。而如果调用20次函数，程序中还是只有一份函数语句的副本，所以节省了空间。
  * 不过使用函数时，程序的控制必须跳转到函数内部，随后再返回主调程序，则比内联代码花费更多时间。
  * 宏的另外一个优点是，不用担心变量类型。（因为宏处理的是字符串）
* 对于简单的函数，通常应该使用宏



### 文件包含： `#include`

当预处理器发现`#include` 指令时，会查看后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的`#include`指令。这相当于把被包含文件的全部内容输入到源文件#include指令所在的位置。`#include`指令有两种形式:

```c
#include <stdio.h>     ←文件名在尖括号中

#include "mystuff.h"   ←文件名在双引号中
```

* 在 UNIX 系统中，尖括号告诉预处理器在标准系统目录中查找该文件。 双引号告诉预处理器首先在当前目录中(或文件名中指定的其他目录)查找该文件，如果未找到再查找标准系统目录:

* 集成开发环境(IDE)也有标准路径或系统头文件的路径。许多集成开发环境提供菜单选项，指定用尖括号时的查找路径。在 UNIX 中，使用双引号意味着先查找本地目录，但是具体查找哪个目录取决于编译器的设定。有些编译器会搜索源代码文件所在的目录，有些编译器则搜索当前的工作目录，还有些搜索项目文件所在的目录。
* ANSI C不为文件提供统一的目录模型，因为不同的计算机所用的系统不同。
* 包含一个大型头文件不一定显著增加程序的大小。在大部分情况下，头
  文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中
  的材料。
* 通常， 应该用`#ifndef`和`#define`防止多重包含头文件

### 其他指令

#### #undef

`#undef`指令用于“取消”已定义的`#define`指令。也就是说，假设有如下定义:

`define LIMIT 400 `

然后，下面的指令: 

`#undef LIMIT`

将移除上面的定义。现在就可以把LIMIT重新定义为一个新值。即使原来没有定义LIMIT，取消LIMIT的定义仍然有效。如果想使用一个名称，又不确定之前是否已经用过，为安全起见，可以用`#undef` 指令取消该名字的定义。

#### 条件编译

可以使用其他指令创建条件编译(conditinal compilation)。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息(或代码) 块。

##### **#ifdef**、**#else**和**#endif**指令

```c
#ifdef MAVIS
#include "horse.h"     // 如果已经用#define定义了 MAVIS，则执行下面的指令
#define STABLES 5
#else
#include "cow.h"      //如果没有用#define定义 MAVIS，则执行下 面的指令
#define STABLES 15
#endif
```

\#ifdef指令说明，如果预处理器已定义了后面的标识符(MAVIS)，则执行#else或#endif指令之前的所有指令并编译所有C代码(先出现哪个指令就执行到哪里)。如果预处理器未定义MAVIS，且有#else指令，则执行 #else和#endif指令之间的所有代码。

##### **#ifndef**指令

\#ifndef指令与#ifdef指令的用法类似，也可以和#else、#endif一起使用， 但是它们的逻辑相反。#ifndef指令判断后面的标识符是否是未定义的，常用 于定义之前未定义的常量

```c
/* arrays.h */ 
#ifndef SIZE 
#define SIZE 100
#endif
```

\#ifndef指令通常用于防止多次包含一个文件

```c
/* things.h */
#ifndef THINGS_H_
#define THINGS_H_
/* 省略了头文件中的其他内容*/
#endif
```

> 如何确保待测试的标识符没有在别处定义? 通常标准库使用如下规则生成带测试定义：文件名作为标识符、使用大写字母、用下划线字符代替文件名中的点字符、用下划线字符做前缀或后缀(可能使用两条下划线)。
>
> 标准库一般类似如下写法`#ifndef _STDIO_H`，自行开发时，可以移除开头的_符号，就如上面例子中一样。

##### **#if**和**#elif**指令

\#if指令很像C语言中的if。#if后面跟整型常量表达式，如果表达式为非零，则表达式为真。可以在指令中使用C的关系运算符和逻辑运算符:

```c
#if defined (IBMPC) 
#include "ibmpc.h" 
#elif defined (VAX) 
#include "vax.h" 
#elif defined (MAC) 
#include "mac.h" 
#else
#include "general.h"
#endif
```

#### 预定义宏

C标准规定了一些预定义宏:

<img src="https://gitee.com/hanlyjiang/image-repo/raw/master/imgs/20210405192052.png" alt="image-20210405192052737" style="zoom: 33%;" />

#### #line 和 #error

`#line`指令重置`__LINE__`和`__FILE__`宏报告的行号和文件名。可以这样使用#line:

```c
#line 1000          // 把当前行号重置为1000
#line 10 "cool.c"   // 把行号重置为10，把文件名重置为cool.c
#error 指令让预处理器发出一条错误消息，该消息包含指令中的文本。 如果可能的话，编译过程应该中断。可以这样使用#error指令:
#if __STDC_VERSION__ != 201112L 
#error Not C11
#endif
```

编译以上代码生成后，输出如下：

```shell
$ gcc newish.c
newish.c:14:2: error: #error Not C11
$ gcc -std=c11 newish.c
$
```

#### #pragma

在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些设置。#pragma把编译器指令放入源代码中。例如，在开发C99时，标准被称为C9X，可以使用下面的编译指示(pragma)让编译器支持C9X:

```c
#pragma c9x on
```

#### 泛型选择（C11）

在程序设计中，泛型编程(generic programming)指那些没有特定类 型，但是一旦指定一种类型，就可以转换成指定类型的代码。例如，C++在 模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代 码。C没有这种功能。然而，C11新增了一种表达式，叫作泛型选择表达式 (generic selection expression)，可根据表达式的类型(即表达式的类型是 int、double 还是其他类型)选择一个值。

泛型选择表达式不是预处理器指 令，但是在一些泛型编程中它常用作#define宏定义的一部分。 下面是一个泛型选择表达式的示例:

`_Generic(x, int: 0, float: 1, double: 2, default: 3)`

### 名称空间

在C++中，名称可以时变量、函数、结构、枚举、类以及类和结构的成员。当随着项目的增大，名称相互冲突的可能性也将增加，使用多个厂商的类库时，可能导致名称冲突。例如，两个库可能都定义了名为List、Tree和Node的类，但定义的方式不兼容。用户希望使用一个库的List类，然后使用另外一个库的Tree类。C++使用名称空间工具问题解决这种名称冲突问题。



首先需要了解几个概念：声明区域及潜在作用域

**声明区域：**是可以在其中进行声明的区域。如，可以在函数外面声明全局变量，对于这种变量，器声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明所在的代码块。

**潜在作用域：**变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用区域比声明区域小，这是由于变量必须定义后才能使用。

变量对程序而言的可见范围被称之为作用域。

#### 传统的C++名称空间

C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个区域都可以声明名称，这些名称独立语在其他声明区域中声明的名称。在一个函数中声明的局部变量不会于在另外一个函数中声明的局部变量发生冲突。

#### 新的名称空间特性

C++新增了一种功能，即通过定义一种新的声明区域来创建命名的名称空间。

这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。

#### 创建名称空间

使用 namespace 关键字可以创建名称空间，名称空间可以是全局的，也可以位于另外一个名称空间中，当不能位于代码块中。

```c
namespace Jill {
    double bucket(double n){...}
    double fetch;
    void get();
    int pal;
    struct Hill {...} ;
}
```

除了用用户定义的名称空间外，还存在另外一个名称空间--全局名称空间。它对应于文件级声明区域，因此前面说的全局变量现在被描述为位于全局名称空间中。

名称空间是开放的-可以把名称加入到已有的名称空间中，如下：

```c
namespace Jill {
    char * goose(const char *);
}
```

也可以在原文件后面或者另外一个文件中再次使用名称空间来提供之前声明过的方法的代码实现：

```c
namespace Jill {
 	void get(){
        ...
    }   
}
```

#### 使用名称空间

名称空间可使用如下方法使用：

* 作用域解析运算符 `::`
* using 声明和 using编译指令：
  * 不希望每次使用名称时都使用作用域解析符进行限定，可以通过这两种机制来简化对名称空间的使用
  * using 声明使特定的标识符可用
  * using 编译指令使得整个名称空间可用
* 一般来说，using声明比使用using编译指令更加安全，这是由于它只导入指定的名称，如果该名称与局部名称发生冲突，编译器将发出指示。using编译指令导入所有名称，包括可能并不需要的名称，如果和局部名称发生冲突，则局部名称将覆盖空间名称版本，而编译器并不会发出警告。另外名称的开放性意味着名称空间的名称可能分散在多个地方，着使得难以准确知道添加了哪些名称。

**作用域解析运算符使用示例：**

```c
#include <iostream>

int main(int argc, const char * argv[]) {
    std::cout << "Hello, World!\n";
    return 0;
}
```

**using声明使用示例：**

```c
#include <iostream>
using std::cout;
using std::endl;

int main(int argc, const char * argv[]) {

//    using namespace std;
    cout << "Hello, World!\n" << endl;
    return 0;
}
```

**using 编译指令使用示例：**

```c
#include <iostream>

int main(int argc, const char * argv[]) {
	// 使用命名空间，可以省略 cout前面的 std::
    using namespace std;
    cout << "Hello, World!\n" << endl;
    return 0;
}
```



## 对象和类

