## Thread API

主要介绍Thread类的几个API接口。

### 概览

我们主要关注如下API：

* start： 启动
* (static)sleep：等待指定时间，期间不释放线程锁
* join：等待直到当前线程结束或者到指定时间；
* interrupt： 中断线程，如果当前线程正阻塞在wait及join，sleep等可中断方法中，那么中断状态将会并清除，然后线程接受到一个InterruptedException
* interrupted: 测试当前线程是否中断，并清除中断标识。
* isInterrupted：仅检测是否中断，不清除中断标识；
* isAlive：判断线程是否活着



我们重点介绍 sleep，join两个方法

### sleep

```java
Object lock = currentThread().lock;
// The native sleep(...) method actually performs a special type of wait, which may return
// early, so loop until sleep duration passes.
synchronized (lock) {
    while (true) {
        // native sleep 方法
        sleep(lock, millis, nanos);

        long now = System.nanoTime();
        long elapsed = now - start;

        if (elapsed >= duration) {
            break;
        }

        duration -= elapsed;
        start = now;
        millis = duration / nanosPerMilli;
        nanos = (int) (duration % nanosPerMilli);
    }
}
```

### join 

join 某个线程A，会使当前线程B进入等待，直到线程A结束生命周期，或者到指定时间间隔到达；

==实际上等于线程B调用A对象的wait方法。==不过加了个A线程是否活着的条件判断。A线程结束时，自动notify。

下面是Android的 Join 实现，可以看到，分为两种情况：

* 如果没有指定时间，那么会通过一个锁对象的wait方法一直等到线程结束；

```java
private final Object lock = new Object();

// BEGIN Android-changed: Synchronize on separate lock object not this Thread.
// public final synchronized void join(long millis)
public final void join(long millis)
throws InterruptedException {
    synchronized(lock) {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (millis == 0) {
        while (isAlive()) {
            // JDK 的实现就是直接调用Thread对象的wait方法
            lock.wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            // JDK 的实现就是直接调用Thread对象的wait方法
            lock.wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
    }
}
```

#### 几个问题：

* wait 期间，线程是否在活动？
* notify方法由谁调用？在线程结束的时候native成做了处理，会调用notify方法；
  * [join线程执行结束之后，并没有看到哪里有notify方法，请问此时谁去唤醒等待池中的线程_phubing-CSDN博客](https://blog.csdn.net/qq_26975307/article/details/81666471)
  * [Java 并发编程：线程间的协作(wait/notify/sleep/yield/join) - liuxiaopeng - 博客园 (cnblogs.com)](https://www.cnblogs.com/paddix/p/5381958.html)

### isAlive

可以看到，如果native侧的对象如果销毁了，则线程就不是alive的了。

```java
/**
* Reference to the native thread object.
*
* <p>Is 0 if the native thread has not yet been created/started, or has been destroyed.
*/
private volatile long nativePeer;

// Android-changed: Provide pure Java implementation of isAlive().
public final boolean isAlive() {
    return nativePeer != 0;
}
```

### 问题

#### sleep 和 wait 

* sleep 使得当前线程进入指定毫秒数的休眠，暂停执行，虽然给定了一个休眠时间，但是最终要以系统的定时器和调度器的精度为准，休眠有一个重要的特性，就是其不会放弃monitor锁的所有权；（也就是说，如果获取了锁，然后休眠，其他等待该锁释放的线程也无法获得锁，也就是仍然会阻塞）。

* wait 则是用于等待通知机制，调用wait之后，将会使当前线程释放锁，直到其他线程通知调用notify方法才；

> 用wait()、notify()以及notifyAll()时需要注意的细节，如下:
>
>  1）使用wait()、notify()和notifyAll()时需要先对调用对象加锁。
>
>  2）调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。 
>
> 3）notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。 
>
> 4）notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。 
>
> 5）从wait()方法返回的前提是获得了调用对象的锁。 从上述细节中可以看到，等待/通知机制依托于同步机制，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。

### 总结

可以看到，join 方法实际上也是基于wait/notify的等待机制。所以我们应该再了解下Object上的几个方法；



## 线程间通信

线程中通信的涉及内容：

* volatile 和 synchronized 关键字
* 等待通知机制（`wait`/`notify`）
* Thread.join（实际上还是等待通知机制）
* ThreadLocal-线程局部变量

### volatile

修饰字段变量，告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性；



### synchronized 关键字

用于修饰方法活着代码块，确保多个线程在同一个时刻，只能有一个线程处于**方法**或者**同步块**中，它保证了线程对变量访问的可见性和排它性；

* 同步块的实现使用了 monitorenter 和 monitorexit 指令
* 同步方法依靠修饰符上的 ACC_SYNCHORONIZED 来完成

本质上是对一个对象的监视器进行获取，而这个获取过程是排它的，也就是同一个时刻只能有一个线程获取到由synchronized 所保护对象的监视器；执行同步方法或者同步块的代码前，需要先获取对象的监视器，没有获取到的线程会被阻塞在

