<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>源码分析 on 清水池塘</title><link>https://hanlyjiang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><description>Recent content in 源码分析 on 清水池塘</description><generator>Hugo -- 0.152.2</generator><language>zh-cn</language><lastBuildDate>Sun, 06 Mar 2022 15:11:54 +0000</lastBuildDate><atom:link href="https://hanlyjiang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>Dagger 在Android库(SDK)模块中的使用实践</title><link>https://hanlyjiang.github.io/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/</link><pubDate>Sun, 06 Mar 2022 15:11:54 +0000</pubDate><guid>https://hanlyjiang.github.io/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/</guid><description>&lt;p&gt;本文主要描述如何使用Dagger解决实际项目中遇到的问题，这两个问题是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何在库（SDK）模块中使用Dagger依赖注入？&lt;/li&gt;
&lt;li&gt;MVP中的Dagger依赖注入如何实现无感注入？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文不会介绍如何使用Dagger，只专注于描述如上两个问题的解决的前因后果及解决方案。&lt;/p&gt;
&lt;h2 id="背景"&gt;背景&lt;/h2&gt;
&lt;p&gt;接手开发一个SDK，大致情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该SDK内部有若干界面，包括Activity，Fragment等&lt;/li&gt;
&lt;li&gt;使用MVP架构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逐渐发现内部依赖混乱，在得空后，遂对其依赖部分进行重构改造。&lt;/p&gt;
&lt;h3 id="为什么使用依赖注入进行改造"&gt;为什么使用依赖注入进行改造？&lt;/h3&gt;
&lt;p&gt;主要是依赖混乱，单例的滥用导致依赖关系不明显，无法管理，无法测试&lt;/p&gt;
&lt;p&gt;某些对象，我们在很多类中都需要使用，如 Retrofit 的请求对象，代表信息的标识字段等，此时为了避免通过构造函数或者setter方法来传递，就直接起了个单例，还有很多其他类似的情况，最终导致单例有10多个，调用单例 getInstance 的地方更是数不胜数。&lt;/p&gt;
&lt;p&gt;导致我们要对对应的代码进行单元测试做mock操作异常困难，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为依赖关系太不明显，几乎得一行行找才能找到类或方法到底依赖了哪些对象&lt;/li&gt;
&lt;li&gt;同时mock的过程也变得麻烦，由于没有作为类成员，所以无法简单通过mock替换 对应成员；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="依赖注入改造的问题点"&gt;依赖注入改造的问题点&lt;/h3&gt;
&lt;p&gt;主要有如下问题：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;之所以提第一个问题，是因为Google 针对Android，在Dagger的基础上针对性的构建了一个Hilt 的依赖注入框架，能够减少Android中直接使用Dagger的模板代码。但是Hilt的使中有要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;所有使用 Hilt 的应用都必须包含一个带有 &lt;code&gt;@HiltAndroidApp&lt;/code&gt; 注释的 &lt;code&gt;Application&lt;/code&gt; 类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考： &lt;a href="https://developer.android.google.cn/training/dependency-injection/hilt-android"&gt;使用 Hilt 实现依赖项注入 | Android 开发者 | Android Developers (google.cn)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是必须能控制住Application，如上所述，我们作为一个SDK的提供方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是没有机会修改Application的代码的&lt;/li&gt;
&lt;li&gt;而且，我们也不能要求使用方去做这种限制；同时，如果使用方有使用 Hilt 呢，我们的代码是否会对其产生影响？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;故，我们只能直接使用Dagger。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而另外一个问题在于MVP的架构限制，P 层需要持有V层的引用，也就是P依赖V，而V通常是Activity或者Fragment，而Activity及Fragment的创建过程由Android系统控制，所以在使用Dagger时我们需要添加一些模板代码（下方会说明），将 Activity及Fragment对象注入到 Dagger 的依赖图谱中。&lt;/p&gt;
&lt;h2 id="没有-application-的问题解决"&gt;没有 Application 的问题解决&lt;/h2&gt;
&lt;p&gt;首先，我们要解决的是没有Application的问题，那么没有Application会给我们带来哪些问题呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法使用 Hilt&lt;/li&gt;
&lt;li&gt;无法直接使用 dagger-android&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个问题实际上是类似的，Hilt及Dagger-Android都是用于解决 Android 组件（Activity，Fragment，Service，BroadcastReceiver 等）的依赖注入的。但是他们都要求我们必须使用 Application。&lt;/p&gt;</description></item><item><title>Android bindService流程</title><link>https://hanlyjiang.github.io/posts/androidbindservice-liu-cheng-fen-xi/</link><pubDate>Mon, 12 Apr 2021 10:18:50 +0000</pubDate><guid>https://hanlyjiang.github.io/posts/androidbindservice-liu-cheng-fen-xi/</guid><description>&lt;p&gt;本文分析bindService的流程，首先我们通过阅读源码获取一个主线的调用地图，然后提出若干问题，包括：APP进程中如何获取AMS，AMS如何启动APP-service的进程，AMS中如何获取ApplicationThread并与之通讯，Service的启动及绑定流程；然后再通过源码一一解答。最后再整体总结梳理一下整体流程；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预先知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binder通信机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="整体分析与总结"&gt;整体分析与总结&lt;/h2&gt;
&lt;h3 id="主线地图与问题提出"&gt;主线地图与问题提出&lt;/h3&gt;
&lt;p&gt;我们从bindService一路跟踪，初步绘制了如下的调用序列图，我们可以以下面的图作为一个主线地图，避免走失，然后根据具体问题进行细节分析。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;从上图中，我们提出如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bindServiceCommon到IActivityManager的调用中，是如何获取到ActivityManagerService的？&lt;/li&gt;
&lt;li&gt;AMS中如何获取ApplicationThread并与之通讯？
&lt;ul&gt;
&lt;li&gt;ApplicatoinThread的用途？ApplicationThread运行的进程是哪个？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程如何启动-即AMS如何创建APP:server进程？&lt;/li&gt;
&lt;li&gt;Service如何启动？&lt;/li&gt;
&lt;li&gt;Service如何绑定？
&lt;ul&gt;
&lt;li&gt;ServiceConnection 的回调方法何时使用？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="问题解答汇总"&gt;问题解答汇总&lt;/h3&gt;
&lt;p&gt;我们将相关问题的结论提前到此小节，便于后续从比较抽象的层次上来进行复习及预览；&lt;/p&gt;
&lt;h4 id="app进程如何获取ams"&gt;APP进程如何获取AMS？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;APP进程中通过 &lt;code&gt;ServiceManager.getService(Context.ACTIVITY_SERVICE)&lt;/code&gt; 获取的ActivityManagerService的客户端操作代理对象（Proxy）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该对象位于APP进程中，可以使用此对象（通过Binder进程间通信）来要求（位于system_process中）的ActivityManagerService进行对应的服务操作；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="ams如何获取applicationthread"&gt;AMS如何获取ApplicationThread？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;APP进程在binderSerice时，将自己进程中的ApplicationThread取出，通过Binder机制传递给AMS进程，传递过程中会转换成一个Proxy对象；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ActivityManager.&lt;span style="color:#a6e22e"&gt;getService&lt;/span&gt;().&lt;span style="color:#a6e22e"&gt;bindIsolatedService&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; mMainThread.&lt;span style="color:#a6e22e"&gt;getApplicationThread&lt;/span&gt;(), getActivityToken(), service,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; service.&lt;span style="color:#a6e22e"&gt;resolveTypeIfNeeded&lt;/span&gt;(getContentResolver()),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; sd, flags, instanceName, getOpPackageName(), user.&lt;span style="color:#a6e22e"&gt;getIdentifier&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="服务如何绑定服务如何启动进程如何启动"&gt;服务如何绑定？服务如何启动？进程如何启动？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程启动&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在独立的进程中运行的服务需要先将进程启动，进程的启动是通过APP进程，请求系统进程中的AMS来执行，通过AMS的&lt;code&gt;startProcessLocked&lt;/code&gt;方法启动进程，最终会通过socket接口请求zygote进程来启动进程。&lt;/li&gt;
&lt;li&gt;在启动时会指定java的入口点为ActivityThread，即进程启动后会运行ActivityThread的main方法；&lt;/li&gt;
&lt;li&gt;AMS中会记录启动的进程记录（ProcessRecord），对应的ProcessRecord中会记录进程对应的ApplicationThread；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务启动&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;服务的启动需要请求AMS来完成&lt;/li&gt;
&lt;li&gt;启动时需要先通过PID获取要启动到的ProcessRecord，通过ProcessRecord中记录的ApplicationThread来与对应的进程通信。&lt;/li&gt;
&lt;li&gt;AMS通过ApplicationThread来通知对应的进程创建服务，ApplicationThread作为通信的接口，实际上最终会通过ActivityThread的handleCreateService来创建服务的实例；&lt;/li&gt;
&lt;li&gt;服务创建时，是在APP进程（可能是独立的进程）中进行的，需要通过类加载器加载对应的Service的类，同时构造相应的上下文及资源对象等，然后构造对应的实例；&lt;/li&gt;
&lt;li&gt;服务创建成功后，会记录到ActivityThread的一个Service列表中，以便后续管理；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务绑定&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;服务绑定先在APP进程中，通过AMS代理对象发起请求，由AMS来安排bind（&lt;strong&gt;ActivityManagerService.bindIsolatedService&lt;/strong&gt;）;&lt;/li&gt;
&lt;li&gt;然后具体的绑定动作还是通过IApplicationThread安排到APP的Service进程中，最终执行的&lt;code&gt;ActivityThread#handleBindService&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;在APP进程中，会将Service取出，然后调用其onBind方法来获取IBinder远程操作对象；&lt;/li&gt;
&lt;li&gt;之后再通过AMS调用 &lt;code&gt;ActivityManagerService#publishService&lt;/code&gt; 来通知绑定成功的通知到对应的需要绑定服务的APP进程；&lt;/li&gt;
&lt;li&gt;publishService中会调用ServiceConnection的onServiceConnected方法通知服务连接了；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="整体流程总结"&gt;整体流程总结&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="详细分析解答问题"&gt;详细分析解答问题&lt;/h2&gt;
&lt;h3 id="app进程中如何获取ams"&gt;APP进程中如何获取AMS？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一次先逐项查看各个小节，最后再看此处的总结；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后续直接查看总结来快速获取结论；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;==总结：==&lt;/p&gt;</description></item><item><title>搭建Android源码工作环境</title><link>https://hanlyjiang.github.io/posts/%E6%90%AD%E5%BB%BAandroid%E6%BA%90%E7%A0%81%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/</link><pubDate>Thu, 08 Apr 2021 10:18:50 +0000</pubDate><guid>https://hanlyjiang.github.io/posts/%E6%90%AD%E5%BB%BAandroid%E6%BA%90%E7%A0%81%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/</guid><description>&lt;ul&gt;
&lt;li&gt;简单介绍系统架构、编译环境的搭建&lt;/li&gt;
&lt;li&gt;简单介绍利用 AndroidStudio 调试 system_process 进程的方法及编译更新部分系统模块的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="android系统架构"&gt;Android系统架构&lt;/h2&gt;
&lt;p&gt;Android 系统架构如下两图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="20210401092831" loading="lazy" src="https://s2.loli.net/2022/05/26/iVWSvDPlA9I4afd.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="20210401092925" loading="lazy" src="https://s2.loli.net/2022/05/26/3KYlCuj5zXc9EUs.png"&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用框架&lt;/strong&gt;。应用框架最常被应用开发者使用。很多此类 API 都可以直接映射到底层 HAL 接口，并可提供与实现驱动程序相关的实用信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Binder IPC&lt;/strong&gt;。Binder 进程间通信 (IPC) 机制允许应用框架跨越进程边界并调用 Android 系统服务代码，这使得高级框架 API 能与 Android 系统服务进行交互。在应用框架级别，开发者无法看到此类通信的过程，但一切似乎都在“按部就班地运行”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统服务&lt;/strong&gt;。系统服务是专注于特定功能的模块化组件，例如窗口管理器、搜索服务或通知管理器。应用框架 API 所提供的功能可与系统服务通信，以访问底层硬件。Android 包含两组服务：“系统”（诸如窗口管理器和通知管理器之类的服务）和“媒体”（与播放和录制媒体相关的服务）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件抽象层 (HAL)&lt;/strong&gt;。HAL 可定义一个标准接口以供硬件供应商实现，这可让 Android 忽略较低级别的驱动程序实现。借助 HAL，硬件开发者可以顺利实现相关功能，而不会影响或更改更高级别的系统。HAL 实现会被封装成模块，并会由 Android 系统适时地加载。如需了解详情，请参阅&lt;a href="https://source.android.google.cn/devices/architecture/hal?hl=zh-cn"&gt;硬件抽象层 (HAL)&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux 内核&lt;/strong&gt;。开发设备驱动程序与开发典型的 Linux 设备驱动程序类似。Android 使用的 Linux 内核版本包含一些特殊的补充功能，例如低内存终止守护进程（一个内存管理系统，可更主动地保留内存）、唤醒锁定（一种 &lt;a href="https://developer.android.google.cn/reference/android/os/PowerManager.html?hl=zh-cn"&gt;&lt;code&gt;PowerManager&lt;/code&gt;&lt;/a&gt; 系统服务）、Binder IPC 驱动程序，以及对移动嵌入式平台来说非常重要的其他功能。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。可以使用任意版本的内核，只要它支持所需功能（如 Binder 驱动程序）即可。不过建议使用 Android 内核的最新版本。如需了解详情，请参阅&lt;a href="https://source.android.google.cn/setup/building-kernels?hl=zh-cn"&gt;构建内核&lt;/a&gt;一文。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;以上部分内容来源： &lt;a href="https://source.android.google.cn/devices/architecture?hl=zh-cn"&gt;https://source.android.google.cn/devices/architecture?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="搭建开发环境并编译源码"&gt;搭建开发环境并编译源码&lt;/h2&gt;
&lt;p&gt;本节将讨论 Android 11 源码下载和编译的方法、AndroidStudio开发环境的搭建方法，及 system_process 进程的调试方法等相关知识。&lt;/p&gt;
&lt;h3 id="选择分支"&gt;选择分支&lt;/h3&gt;
&lt;p&gt;可参考 source.android.google.cn 的文档 &lt;a href="https://source.android.google.cn/setup/start/build-numbers"&gt;代号、标记和 Build 号&lt;/a&gt; ，可以看到当前最新的版本及标记如下：&lt;/p&gt;</description></item></channel></rss>