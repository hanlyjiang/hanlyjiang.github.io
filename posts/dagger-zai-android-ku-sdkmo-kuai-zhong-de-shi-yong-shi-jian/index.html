<!doctype html><html lang=zh-cn dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dagger 在Android库(SDK)模块中的使用实践 | 清水池塘</title><meta name=keywords content="Android,源码分析,依赖注入,开源框架"><meta name=description content="本文主要描述如何使用Dagger解决实际项目中遇到的问题，这两个问题是：

如何在库（SDK）模块中使用Dagger依赖注入？
MVP中的Dagger依赖注入如何实现无感注入？

本文不会介绍如何使用Dagger，只专注于描述如上两个问题的解决的前因后果及解决方案。

背景
接手开发一个SDK，大致情况如下："><meta name=author content="野生莲藕"><link rel=canonical href=https://hanlyjiang.github.io/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/><link crossorigin=anonymous href=/assets/css/stylesheet.0ddbb411bed5280eeba0e4a55c287e6addf14dc6eb09c604363a7ce5c4d40c1c.css integrity="sha256-Ddu0Eb7VKA7roOSlXCh+at3xTcbrCcYENjp85cTUDBw=" rel="preload stylesheet" as=style><link rel=icon href=https://hanlyjiang.github.io/img/home.png><link rel=icon type=image/png sizes=16x16 href=https://hanlyjiang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hanlyjiang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://hanlyjiang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://hanlyjiang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://hanlyjiang.github.io/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hanlyjiang.github.io/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/"><meta property="og:site_name" content="清水池塘"><meta property="og:title" content="Dagger 在Android库(SDK)模块中的使用实践"><meta property="og:description" content="本文主要描述如何使用Dagger解决实际项目中遇到的问题，这两个问题是：
如何在库（SDK）模块中使用Dagger依赖注入？ MVP中的Dagger依赖注入如何实现无感注入？ 本文不会介绍如何使用Dagger，只专注于描述如上两个问题的解决的前因后果及解决方案。
背景 接手开发一个SDK，大致情况如下："><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-06T15:11:54+00:00"><meta property="article:modified_time" content="2022-03-06T15:11:54+00:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="源码分析"><meta property="article:tag" content="依赖注入"><meta property="article:tag" content="开源框架"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dagger 在Android库(SDK)模块中的使用实践"><meta name=twitter:description content="本文主要描述如何使用Dagger解决实际项目中遇到的问题，这两个问题是：

如何在库（SDK）模块中使用Dagger依赖注入？
MVP中的Dagger依赖注入如何实现无感注入？

本文不会介绍如何使用Dagger，只专注于描述如上两个问题的解决的前因后果及解决方案。

背景
接手开发一个SDK，大致情况如下："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hanlyjiang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Dagger 在Android库(SDK)模块中的使用实践","item":"https://hanlyjiang.github.io/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dagger 在Android库(SDK)模块中的使用实践","name":"Dagger 在Android库(SDK)模块中的使用实践","description":"本文主要描述如何使用Dagger解决实际项目中遇到的问题，这两个问题是：\n如何在库（SDK）模块中使用Dagger依赖注入？ MVP中的Dagger依赖注入如何实现无感注入？ 本文不会介绍如何使用Dagger，只专注于描述如上两个问题的解决的前因后果及解决方案。\n背景 接手开发一个SDK，大致情况如下：\n","keywords":["Android","源码分析","依赖注入","开源框架"],"articleBody":"本文主要描述如何使用Dagger解决实际项目中遇到的问题，这两个问题是：\n如何在库（SDK）模块中使用Dagger依赖注入？ MVP中的Dagger依赖注入如何实现无感注入？ 本文不会介绍如何使用Dagger，只专注于描述如上两个问题的解决的前因后果及解决方案。\n背景 接手开发一个SDK，大致情况如下：\n该SDK内部有若干界面，包括Activity，Fragment等 使用MVP架构 逐渐发现内部依赖混乱，在得空后，遂对其依赖部分进行重构改造。\n为什么使用依赖注入进行改造？ 主要是依赖混乱，单例的滥用导致依赖关系不明显，无法管理，无法测试\n某些对象，我们在很多类中都需要使用，如 Retrofit 的请求对象，代表信息的标识字段等，此时为了避免通过构造函数或者setter方法来传递，就直接起了个单例，还有很多其他类似的情况，最终导致单例有10多个，调用单例 getInstance 的地方更是数不胜数。\n导致我们要对对应的代码进行单元测试做mock操作异常困难，\n因为依赖关系太不明显，几乎得一行行找才能找到类或方法到底依赖了哪些对象 同时mock的过程也变得麻烦，由于没有作为类成员，所以无法简单通过mock替换\f对应成员； 依赖注入改造的问题点 主要有如下问题：\n1. 没有Application。该模块为SDK，我们并不能直接修改Application对象，Application为集成方自行编写。\n2. MVP的绑定。MVP绑定中模板代码较多，我们希望能尽可能的实现无感的注入。\n之所以提第一个问题，是因为Google 针对Android，在Dagger的基础上针对性的构建了一个Hilt 的依赖注入框架，能够减少Android中直接使用Dagger的模板代码。但是Hilt的使中有要求：\n所有使用 Hilt 的应用都必须包含一个带有 @HiltAndroidApp 注释的 Application 类。\n参考： 使用 Hilt 实现依赖项注入 | Android 开发者 | Android Developers (google.cn)\n也就是必须能控制住Application，如上所述，我们作为一个SDK的提供方：\n是没有机会修改Application的代码的 而且，我们也不能要求使用方去做这种限制；同时，如果使用方有使用 Hilt 呢，我们的代码是否会对其产生影响？ 故，我们只能直接使用Dagger。\n而另外一个问题在于MVP的架构限制，P 层需要持有V层的引用，也就是P依赖V，而V通常是Activity或者Fragment，而Activity及Fragment的创建过程由Android系统控制，所以在使用Dagger时我们需要添加一些模板代码（下方会说明），将 Activity及Fragment对象注入到 Dagger 的依赖图谱中。\n没有 Application 的问题解决 首先，我们要解决的是没有Application的问题，那么没有Application会给我们带来哪些问题呢？\n无法使用 Hilt 无法直接使用 dagger-android 这两个问题实际上是类似的，Hilt及Dagger-Android都是用于解决 Android 组件（Activity，Fragment，Service，BroadcastReceiver 等）的依赖注入的。但是他们都要求我们必须使用 Application。\n为什么一定要Application？ 首先，让我们看下 dagger-android 的使用方式，这里参考 [Google 的示例](architecture-components-samples/GithubBrowserSample at master · android/architecture-components-samples) 进行说明。\nDagger-Android 的使用 这里我们省略 gradle 依赖的引入部分，直接解释代码。\n1. Application 进行改造 如下代码所述，主要有如下修改：\n令 Application 实现 HasActivityInjector 接口； Application 中注入一个类型为 DispatchingAndroidInjector 的成员，同时通过HasActivityInjector接口定义的重载方法 activityInjector() 返回该成员。 在 Application.onCreate 中调用 AppInjector.init(this) 执行注入操作。 至此，准备工作就完毕了，之后就可以使用Dagger 无感注入Activity或者Fragment了。\nclass GithubApp : Application(), HasActivityInjector { @Inject lateinit var dispatchingAndroidInjector: DispatchingAndroidInjector override fun onCreate() { super.onCreate() if (BuildConfig.DEBUG) { Timber.plant(Timber.DebugTree()) } AppInjector.init(this) } override fun activityInjector() = dispatchingAndroidInjector } AppInjector.init 的实现也很简单，实际上就是：\n在 Activity Create 的时候调用 AndroidInjection.inject(activity) 及 在 Fragment Create 的时候调用 AndroidSupportInjection.inject(f) object AppInjector { fun init(githubApp: GithubApp) { DaggerAppComponent.builder().application(githubApp) .build().inject(githubApp) githubApp .registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks { override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) { handleActivity(activity) } }) } private fun handleActivity(activity: Activity) { if (activity is HasSupportFragmentInjector) { AndroidInjection.inject(activity) } if (activity is FragmentActivity) { activity.supportFragmentManager .registerFragmentLifecycleCallbacks( object : FragmentManager.FragmentLifecycleCallbacks() { override fun onFragmentCreated(fm: FragmentManager,f: Fragment,savedInstanceState: Bundle? ) { if (f is Injectable) { AndroidSupportInjection.inject(f) } } }, true ) } } } AndroidInjection.inject 及 AndroidSupportInjection.inject为 dagger-android 提供的接口，我们后续进行分析。\n2. 使用 再完成上述准备工作之后，要想让Activity或者Fragment能够自动注入，只需要进行如下操作（我们同样还是参考Google示例代码）\n在 Module 中使用@ContributesAndroidInjector 标记一个返回对应Activity（如MainActivity）的方法 // https://github.com/android/architecture-components-samples/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/di/MainActivityModule.kt @Module abstract class MainActivityModule { @ContributesAndroidInjector(modules = [FragmentBuildersModule::class]) abstract fun contributeMainActivity(): MainActivity } 当然还需要将这个Module包含到 AppComponent中（同时 AppComponent中需要包含 AndroidInjectionModule这个 dagger-android 提供的module） // https://github.com/android/architecture-components-samples/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/di/AppComponent.kt @Singleton @Component( modules = [ AndroidInjectionModule::class, MainActivityModule::class] ) interface AppComponent { // 删除其他部分 } 3. 总结 也就是说，使用dagger-android时，在完成了准备动作之后，后续只需要添加一个 @ContributesAndroidInjector 注解的方法，就可以让你的Activity支持自动依赖注入。\n为什么需要 Application 上面介绍了 dagger-android 的使用方式，实际上是为了展示在使用Dagger-Android之后，我们可以无需对Activity进行修改，就可以自动向其中注入依赖。 这里的修改实际上指的是手动在每个Activity 的 onCreate 方法调用Dagger组件的注入方法。\n但是我们的问题并没有得到回答，即：\n为什么需要Application？\n现在，让我们看下 AndroidInjection.inject(activity) 的实现：(AndroidInjection 为dagger-android 库提供的辅助工具类)\npublic static void inject(Activity activity) { checkNotNull(activity, \"activity\"); Application application = activity.getApplication(); if (!(application instanceof HasActivityInjector)) { throw new RuntimeException( String.format( \"%s does not implement %s\", application.getClass().getCanonicalName(), HasActivityInjector.class.getCanonicalName())); } AndroidInjector activityInjector = ((HasActivityInjector) application).activityInjector(); checkNotNull(activityInjector, \"%s.activityInjector() returned null\", application.getClass()); activityInjector.inject(activity); } 从代码中我们可以看到，执行了如下步骤：\n由Activity获取Application； 判断 Application 是否实现了 HasActivityInjector 从 Application 获取 AndroidInjector，然后使用此对象执行对目标Activity的注入。 另外，AndroidInjection 类还有对 Service，Fragment等的注入辅助方法，过程中也都类似对Activity的注入，会获取 Application 对象，然后从Application对象中获取AndroidInejctor，再用此对象进行目标组件的依赖注入。\n所以，我们现在知道了为什么一定要Application了：\n实际上，是需要其中的 AndroidInjector ； 在各种Android组件中（Activity，Service，等）我们都能直接通过其获取到Application对象，这样就能找到存在于Application中的 AndroidInjector，然后执行注入操作。 扩展 - AndroidInjector 哪里来的？ 通过上面的分析，我们知道了为什么 dagger-android 一定需要Application，是为了获取其中的AndroidInjector 用来执行目标Android组件的注入操作。\n那么，这个 AndroidInjector 是哪里来的呢？\n由前面的GithubApp代码中我们看到，这个 AndroidInject 就是Application中使用了 @Inject 标记的类型为 DispatchingAndroidInjector 的对象\n// AndroidInjection.inject(activity) AndroidInjector activityInjector = ((HasActivityInjector) application).activityInjector(); // GithubApp @Inject lateinit var dispatchingAndroidInjector: DispatchingAndroidInjector override fun activityInjector() = dispatchingAndroidInjector 我们去Dagger 的生成代码中( DaggerAppComponent )中查找对应的类型 DispatchingAndroidInjector\n// DaggerAppComponent.java private DispatchingAndroidInjector\u003cActivity\u003e getDispatchingAndroidInjectorOfActivity() { return DispatchingAndroidInjector_Factory.newDispatchingAndroidInjector( getMapOfClassOfAndProviderOfFactoryOf()); } private GithubApp injectGithubApp(GithubApp instance) { GithubApp_MembersInjector.injectDispatchingAndroidInjector( instance, getDispatchingAndroidInjectorOfActivity()); return instance; } @Override public void inject(GithubApp githubApp) { injectGithubApp(githubApp); } // GithubApp_MembersInjector.java @Override public void injectMembers(GithubApp instance) { injectDispatchingAndroidInjector(instance, dispatchingAndroidInjectorProvider.get()); } public static void injectDispatchingAndroidInjector( GithubApp instance, DispatchingAndroidInjector\u003cActivity\u003e dispatchingAndroidInjector) { instance.dispatchingAndroidInjector = dispatchingAndroidInjector; } 可以看到 DaggerAppComponent中在注入inject(GithubApp)时，会将DispatchingAndroidInjector 类型的依赖注入到 GithubApp 中。\n更多细节：\ndagger-android-processor 处理其会根据 @ContributesAndroidInjector 自动生成一个Module的代码，内容如下：\n@Module(subcomponents = MainActivityModule_ContributeMainActivity.MainActivitySubcomponent.class) public abstract class MainActivityModule_ContributeMainActivity { private MainActivityModule_ContributeMainActivity() {} @Binds @IntoMap @ActivityKey(MainActivity.class) abstract AndroidInjector.Factory\u003c? extends Activity\u003e bindAndroidInjectorFactory( MainActivitySubcomponent.Builder builder); @Subcomponent(modules = FragmentBuildersModule.class) public interface MainActivitySubcomponent extends AndroidInjector\u003cMainActivity\u003e { @Subcomponent.Builder abstract class Builder extends AndroidInjector.Builder\u003cMainActivity\u003e {} } } 此模块中定义了 bindAndroidInjectorFactory 方法，使用 @Binds @IntoMap生成 Map","wordCount":"6726","inLanguage":"zh-cn","datePublished":"2022-03-06T15:11:54Z","dateModified":"2022-03-06T15:11:54Z","author":{"@type":"Person","name":"野生莲藕"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hanlyjiang.github.io/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/"},"publisher":{"@type":"Organization","name":"清水池塘","logo":{"@type":"ImageObject","url":"https://hanlyjiang.github.io/img/home.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hanlyjiang.github.io/ accesskey=h title="清水池塘 (Alt + H)"><img src=https://hanlyjiang.github.io/img/home.png alt aria-label=logo height=35>清水池塘</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hanlyjiang.github.io/ title=首页><span><i class='fas fa-home'></i>首页</span></a></li><li><a href=https://hanlyjiang.github.io/series/ title=专题><span>专题</span></a></li><li><a href=https://hanlyjiang.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://hanlyjiang.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hanlyjiang.github.io/archives/ title=归档><span><i class='fas fa-archives'></i>归档</span></a></li><li><a href=https://hanlyjiang.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hanlyjiang.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://hanlyjiang.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Dagger 在Android库(SDK)模块中的使用实践</h1><div class=post-meta><span title='2022-03-06 15:11:54 +0000 UTC'>2022年3月6日</span>&nbsp;·&nbsp;<span>14 分钟</span>&nbsp;·&nbsp;<span>野生莲藕</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e8%bf%9b%e8%a1%8c%e6%94%b9%e9%80%a0 aria-label=为什么使用依赖注入进行改造？>为什么使用依赖注入进行改造？</a></li><li><a href=#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%94%b9%e9%80%a0%e7%9a%84%e9%97%ae%e9%a2%98%e7%82%b9 aria-label=依赖注入改造的问题点>依赖注入改造的问题点</a></li></ul></li><li><a href=#%e6%b2%a1%e6%9c%89-application-%e7%9a%84%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3 aria-label="没有 Application 的问题解决">没有 Application 的问题解决</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%80%e5%ae%9a%e8%a6%81application aria-label=为什么一定要Application？>为什么一定要Application？</a><ul><li><a href=#dagger-android-%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="Dagger-Android 的使用">Dagger-Android 的使用</a><ul><li><a href=#1-application-%e8%bf%9b%e8%a1%8c%e6%94%b9%e9%80%a0 aria-label="1. Application 进行改造">1. Application 进行改造</a></li><li><a href=#2-%e4%bd%bf%e7%94%a8 aria-label="2. 使用">2. 使用</a></li><li><a href=#3-%e6%80%bb%e7%bb%93 aria-label="3. 总结">3. 总结</a></li></ul></li></ul></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-application aria-label="为什么需要 Application">为什么需要 Application</a></li><li><a href=#%e6%89%a9%e5%b1%95---androidinjector-%e5%93%aa%e9%87%8c%e6%9d%a5%e7%9a%84 aria-label="扩展 - AndroidInjector 哪里来的？">扩展 - AndroidInjector 哪里来的？</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=解决方案>解决方案</a></li></ul></li><li><a href=#mvp-%e6%9e%b6%e6%9e%84%e7%9a%84%e6%b3%a8%e5%85%a5%e9%97%ae%e9%a2%98 aria-label="MVP 架构的注入问题">MVP 架构的注入问题</a><ul><li><a href=#mvp-%e4%b8%ad%e7%9a%84%e6%b3%a8%e5%85%a5%e9%97%ae%e9%a2%98 aria-label="MVP 中的注入问题？">MVP 中的注入问题？</a><ul><li><a href=#mvp-%e6%b3%a8%e5%85%a5%e7%9a%84%e4%b8%80%e8%88%ac%e5%86%99%e6%b3%95 aria-label="MVP 注入的一般写法">MVP 注入的一般写法</a></li><li><a href=#mvp-%e6%b3%a8%e5%85%a5%e4%b8%80%e8%88%ac%e5%86%99%e6%b3%95%e7%9a%84%e9%97%ae%e9%a2%98 aria-label="MVP 注入一般写法的问题">MVP 注入一般写法的问题</a></li></ul></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-1 aria-label=解决方案>解决方案</a><ul><li><a href=#%e6%8f%90%e4%be%9b%e7%bb%9f%e4%b8%80%e7%9a%84mvp%e6%a8%a1%e5%9d%97%e5%8f%8a%e7%bb%84%e4%bb%b6%e5%a3%b0%e6%98%8e aria-label=提供统一的Mvp模块及组件声明>提供统一的Mvp模块及组件声明</a></li><li><a href=#%e6%b3%a8%e5%86%8c%e5%88%b0-root-component aria-label="注册到 Root Component">注册到 Root Component</a></li><li><a href=#%e6%b3%a8%e5%85%a5%e8%bf%87%e7%a8%8b%e5%b0%81%e8%a3%85%e9%9a%90%e8%97%8f aria-label=注入过程封装隐藏>注入过程封装隐藏</a></li></ul></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e5%85%b3%e9%94%ae%e7%82%b9%e8%af%b4%e6%98%8e aria-label=解决方案关键点说明>解决方案关键点说明</a><ul><li><a href=#%e6%b3%a8%e5%85%a5%e9%80%bb%e8%be%91%e7%a7%bb%e5%8a%a8%e5%88%b0activitylifecyclecallback%e5%9b%9e%e8%b0%83%e5%8f%8a%e9%81%87%e5%88%b0%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=注入逻辑移动到ActivityLifecycleCallback回调及遇到的问题>注入逻辑移动到ActivityLifecycleCallback回调及遇到的问题</a></li><li><a href=#%e4%bd%bf%e7%94%a8-dagger-android-%e7%94%9f%e6%88%90-inject-%e6%a8%a1%e6%9d%bf%e4%bb%a3%e7%a0%81 aria-label="使用 Dagger-Android 生成 inject 模板代码">使用 Dagger-Android 生成 inject 模板代码</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b%e9%81%bf%e5%85%8ddagger%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5%e4%bd%bf%e7%94%a8provider%e6%96%b9%e6%b3%95%e8%bf%98%e5%8e%9f%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af aria-label=使用包装类型避免Dagger类型检查，使用provider方法还原类型信息>使用包装类型避免Dagger类型检查，使用provider方法还原类型信息</a></li></ul></li></ul></li><li><a href=#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81 aria-label=示例代码>示例代码</a></li></ul></div></details></div><div class=post-content><p>本文主要描述如何使用Dagger解决实际项目中遇到的问题，这两个问题是：</p><ol><li>如何在库（SDK）模块中使用Dagger依赖注入？</li><li>MVP中的Dagger依赖注入如何实现无感注入？</li></ol><p>本文不会介绍如何使用Dagger，只专注于描述如上两个问题的解决的前因后果及解决方案。</p><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>接手开发一个SDK，大致情况如下：</p><ul><li>该SDK内部有若干界面，包括Activity，Fragment等</li><li>使用MVP架构</li></ul><p>逐渐发现内部依赖混乱，在得空后，遂对其依赖部分进行重构改造。</p><h3 id=为什么使用依赖注入进行改造>为什么使用依赖注入进行改造？<a hidden class=anchor aria-hidden=true href=#为什么使用依赖注入进行改造>#</a></h3><p>主要是依赖混乱，单例的滥用导致依赖关系不明显，无法管理，无法测试</p><p>某些对象，我们在很多类中都需要使用，如 Retrofit 的请求对象，代表信息的标识字段等，此时为了避免通过构造函数或者setter方法来传递，就直接起了个单例，还有很多其他类似的情况，最终导致单例有10多个，调用单例 getInstance 的地方更是数不胜数。</p><p>导致我们要对对应的代码进行单元测试做mock操作异常困难，</p><ol><li>因为依赖关系太不明显，几乎得一行行找才能找到类或方法到底依赖了哪些对象</li><li>同时mock的过程也变得麻烦，由于没有作为类成员，所以无法简单通过mock替换 对应成员；</li></ol><h3 id=依赖注入改造的问题点>依赖注入改造的问题点<a hidden class=anchor aria-hidden=true href=#依赖注入改造的问题点>#</a></h3><p>主要有如下问题：</p><p style=color:red>1. 没有Application。该模块为SDK，我们并不能直接修改Application对象，Application为集成方自行编写。</p><p style=color:red>2. MVP的绑定。MVP绑定中模板代码较多，我们希望能尽可能的实现无感的注入。</p><p>之所以提第一个问题，是因为Google 针对Android，在Dagger的基础上针对性的构建了一个Hilt 的依赖注入框架，能够减少Android中直接使用Dagger的模板代码。但是Hilt的使中有要求：</p><blockquote><p><strong>所有使用 Hilt 的应用都必须包含一个带有 <code>@HiltAndroidApp</code> 注释的 <code>Application</code> 类。</strong></p><p>参考： <a href=https://developer.android.google.cn/training/dependency-injection/hilt-android>使用 Hilt 实现依赖项注入 | Android 开发者 | Android Developers (google.cn)</a></p></blockquote><p>也就是必须能控制住Application，如上所述，我们作为一个SDK的提供方：</p><ol><li>是没有机会修改Application的代码的</li><li>而且，我们也不能要求使用方去做这种限制；同时，如果使用方有使用 Hilt 呢，我们的代码是否会对其产生影响？</li></ol><p><strong>故，我们只能直接使用Dagger。</strong></p><p>而另外一个问题在于MVP的架构限制，P 层需要持有V层的引用，也就是P依赖V，而V通常是Activity或者Fragment，而Activity及Fragment的创建过程由Android系统控制，所以在使用Dagger时我们需要添加一些模板代码（下方会说明），将 Activity及Fragment对象注入到 Dagger 的依赖图谱中。</p><h2 id=没有-application-的问题解决>没有 Application 的问题解决<a hidden class=anchor aria-hidden=true href=#没有-application-的问题解决>#</a></h2><p>首先，我们要解决的是没有Application的问题，那么没有Application会给我们带来哪些问题呢？</p><ol><li>无法使用 Hilt</li><li>无法直接使用 dagger-android</li></ol><p>这两个问题实际上是类似的，Hilt及Dagger-Android都是用于解决 Android 组件（Activity，Fragment，Service，BroadcastReceiver 等）的依赖注入的。但是他们都要求我们必须使用 Application。</p><h3 id=为什么一定要application>为什么一定要Application？<a hidden class=anchor aria-hidden=true href=#为什么一定要application>#</a></h3><p>首先，让我们看下 dagger-android 的使用方式，这里参考 [Google 的示例](<a href=https://github.com/android/architecture-components-samples/tree/master/GithubBrowserSample>architecture-components-samples/GithubBrowserSample at master · android/architecture-components-samples</a>) 进行说明。</p><h4 id=dagger-android-的使用>Dagger-Android 的使用<a hidden class=anchor aria-hidden=true href=#dagger-android-的使用>#</a></h4><p>这里我们省略 gradle 依赖的引入部分，直接解释代码。</p><h5 id=1-application-进行改造>1. Application 进行改造<a hidden class=anchor aria-hidden=true href=#1-application-进行改造>#</a></h5><p>如下代码所述，主要有如下修改：</p><ol><li>令 Application 实现 <code>HasActivityInjector</code> 接口；</li><li>Application 中注入一个类型为 <code>DispatchingAndroidInjector&lt;Activity></code> 的成员，同时通过HasActivityInjector接口定义的重载方法 <code>activityInjector()</code> 返回该成员。</li><li>在 <code>Application.onCreate</code> 中调用 <code>AppInjector.init(this)</code> 执行注入操作。</li></ol><p>至此，准备工作就完毕了，之后就可以使用Dagger 无感注入Activity或者Fragment了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GithubApp</span> : Application(), HasActivityInjector {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Inject</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Activity&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.onCreate()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>BuildConfig</span>.DEBUG) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Timber</span>.plant(<span style=color:#a6e22e>Timber</span>.DebugTree())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>AppInjector</span>.<span style=color:#66d9ef>init</span>(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>activityInjector</span>() = dispatchingAndroidInjector
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>AppInjector.init 的实现也很简单，实际上就是：</p><ul><li>在 Activity Create 的时候调用 <code>AndroidInjection.inject(activity)</code> 及</li><li>在 Fragment Create 的时候调用 <code>AndroidSupportInjection.inject(f)</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>AppInjector</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>init</span>(githubApp: GithubApp) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DaggerAppComponent</span>.builder().application(githubApp)
</span></span><span style=display:flex><span>            .build().inject(githubApp)
</span></span><span style=display:flex><span>        githubApp
</span></span><span style=display:flex><span>            .registerActivityLifecycleCallbacks(<span style=color:#66d9ef>object</span> <span style=color:#960050;background-color:#1e0010>: </span><span style=color:#a6e22e>Application</span>.ActivityLifecycleCallbacks {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onActivityCreated</span>(activity: Activity, savedInstanceState: Bundle?) {
</span></span><span style=display:flex><span>                    handleActivity(activity)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>handleActivity</span>(activity: Activity) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (activity <span style=color:#66d9ef>is</span> HasSupportFragmentInjector) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>AndroidInjection</span>.inject(activity)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (activity <span style=color:#66d9ef>is</span> FragmentActivity) {
</span></span><span style=display:flex><span>            activity.supportFragmentManager
</span></span><span style=display:flex><span>                .registerFragmentLifecycleCallbacks(
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>object</span> <span style=color:#960050;background-color:#1e0010>: </span><span style=color:#a6e22e>FragmentManager</span>.FragmentLifecycleCallbacks() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onFragmentCreated</span>(fm: FragmentManager,f: Fragment,savedInstanceState: Bundle?
</span></span><span style=display:flex><span>                        ) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (f <span style=color:#66d9ef>is</span> Injectable) {
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>AndroidSupportInjection</span>.inject(f)
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><code>AndroidInjection.inject</code> 及 <code>AndroidSupportInjection.inject</code>为 dagger-android 提供的接口，我们后续进行分析。</p></blockquote><h5 id=2-使用>2. 使用<a hidden class=anchor aria-hidden=true href=#2-使用>#</a></h5><p>再完成上述准备工作之后，要想让Activity或者Fragment能够自动注入，只需要进行如下操作（我们同样还是参考<a href=https://github.com/android/architecture-components-samples/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/di/MainActivityModule.kt>Google示例代码</a>）</p><ol><li>在 Module 中使用<code>@ContributesAndroidInjector</code> 标记一个返回对应Activity（如MainActivity）的方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// https://github.com/android/architecture-components-samples/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/di/MainActivityModule.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Module</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainActivityModule</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ContributesAndroidInjector</span>(modules = [FragmentBuildersModule<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>contributeMainActivity</span>(): MainActivity
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>当然还需要将这个Module包含到 AppComponent中（同时 AppComponent中需要包含 <code>AndroidInjectionModule</code>这个 dagger-android 提供的module）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// https://github.com/android/architecture-components-samples/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/di/AppComponent.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Singleton</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Component</span>(
</span></span><span style=display:flex><span>    modules = [
</span></span><span style=display:flex><span>        AndroidInjectionModule<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>,
</span></span><span style=display:flex><span>        MainActivityModule<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>]
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>AppComponent</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 删除其他部分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h5 id=3-总结>3. 总结<a hidden class=anchor aria-hidden=true href=#3-总结>#</a></h5><p>也就是说，使用dagger-android时，在完成了准备动作之后，<strong>后续只需要添加一个 <code>@ContributesAndroidInjector</code> 注解的方法，就可以让你的Activity支持自动依赖注入。</strong></p><h3 id=为什么需要-application>为什么需要 Application<a hidden class=anchor aria-hidden=true href=#为什么需要-application>#</a></h3><p>上面介绍了 dagger-android 的使用方式，实际上是为了展示在使用Dagger-Android之后，我们<strong>可以无需对Activity进行修改，就可以自动向其中注入依赖</strong>。 这里的修改实际上指的是手动在每个Activity 的 onCreate 方法调用Dagger组件的注入方法。</p><p>但是我们的问题并没有得到回答，即：</p><p><b><span style=color:red>为什么需要Application？</span></b></p><p>现在，让我们看下 <code>AndroidInjection.inject(activity)</code> 的实现：(AndroidInjection 为dagger-android 库提供的辅助工具类)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>public</span> static void inject(Activity activity) {
</span></span><span style=display:flex><span>    checkNotNull(activity, <span style=color:#e6db74>&#34;activity&#34;</span>);
</span></span><span style=display:flex><span>    Application application = activity.getApplication();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (!(application instanceof HasActivityInjector)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> new RuntimeException(
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>String</span>.format(
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;%s does not implement %s&#34;</span>,
</span></span><span style=display:flex><span>              application.getClass().getCanonicalName(),
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>HasActivityInjector</span>.<span style=color:#66d9ef>class</span>.getCanonicalName()));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    AndroidInjector&lt;Activity&gt; activityInjector =
</span></span><span style=display:flex><span>        ((HasActivityInjector) application).activityInjector();
</span></span><span style=display:flex><span>    checkNotNull(activityInjector, <span style=color:#e6db74>&#34;%s.activityInjector() returned null&#34;</span>, application.getClass());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    activityInjector.inject(activity);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>从代码中我们可以看到，执行了如下步骤：</p><ol><li><strong>由Activity获取Application</strong>；</li><li>判断 Application 是否实现了 HasActivityInjector</li><li>从 Application 获取 <code>AndroidInjector&lt;Activity></code>，然后使用此对象执行对目标Activity的注入。</li></ol><p>另外，AndroidInjection 类还有对 Service，Fragment等的注入辅助方法，过程中也都类似对Activity的注入，会获取 Application 对象，然后从Application对象中获取AndroidInejctor，再用此对象进行目标组件的依赖注入。</p><p>所以，我们现在知道了为什么一定要Application了：</p><ol><li><strong>实际上，是需要其中的 AndroidInjector ；</strong></li><li><strong>在各种Android组件中（Activity，Service，等）我们都能直接通过其获取到Application对象，这样就能找到存在于Application中的 AndroidInjector，然后执行注入操作。</strong></li></ol><h3 id=扩展---androidinjector-哪里来的>扩展 - AndroidInjector 哪里来的？<a hidden class=anchor aria-hidden=true href=#扩展---androidinjector-哪里来的>#</a></h3><p>通过上面的分析，我们知道了为什么 dagger-android 一定需要Application，是为了获取其中的AndroidInjector 用来执行目标Android组件的注入操作。</p><p>那么，<strong>这个 AndroidInjector 是哪里来的呢？</strong></p><p>由前面的GithubApp代码中我们看到，这个 AndroidInject 就是Application中使用了 <code>@Inject</code> 标记的类型为<code> DispatchingAndroidInjector&lt;Activity></code> 的对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// AndroidInjection.inject(activity)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>AndroidInjector&lt;Activity&gt; activityInjector =
</span></span><span style=display:flex><span>        ((HasActivityInjector) application).activityInjector();    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// GithubApp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Inject</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Activity&gt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>activityInjector</span>() = dispatchingAndroidInjector
</span></span></code></pre></div><p>我们去Dagger 的生成代码中( <code>DaggerAppComponent</code> )中查找对应的类型 <code>DispatchingAndroidInjector&lt;Activity></code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// DaggerAppComponent.java  </span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> DispatchingAndroidInjector<span style=color:#f92672>&lt;</span>Activity<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getDispatchingAndroidInjectorOfActivity</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> DispatchingAndroidInjector_Factory.<span style=color:#a6e22e>newDispatchingAndroidInjector</span>(
</span></span><span style=display:flex><span>        getMapOfClassOfAndProviderOfFactoryOf());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> GithubApp <span style=color:#a6e22e>injectGithubApp</span>(GithubApp instance) {
</span></span><span style=display:flex><span>    GithubApp_MembersInjector.<span style=color:#a6e22e>injectDispatchingAndroidInjector</span>(
</span></span><span style=display:flex><span>        instance, getDispatchingAndroidInjectorOfActivity());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> instance;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>inject</span>(GithubApp githubApp) {
</span></span><span style=display:flex><span>    injectGithubApp(githubApp);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// GithubApp_MembersInjector.java</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>injectMembers</span>(GithubApp instance) {
</span></span><span style=display:flex><span>    injectDispatchingAndroidInjector(instance, dispatchingAndroidInjectorProvider.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>injectDispatchingAndroidInjector</span>(
</span></span><span style=display:flex><span>      GithubApp instance, DispatchingAndroidInjector<span style=color:#f92672>&lt;</span>Activity<span style=color:#f92672>&gt;</span> dispatchingAndroidInjector) {
</span></span><span style=display:flex><span>    instance.<span style=color:#a6e22e>dispatchingAndroidInjector</span> <span style=color:#f92672>=</span> dispatchingAndroidInjector;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>可以看到 DaggerAppComponent中在注入<code>inject(GithubApp)</code>时，会将<code>DispatchingAndroidInjector&lt;Activity></code> 类型的依赖注入到 GithubApp 中。</p><blockquote><p><strong>更多细节：</strong></p><ol><li><p>dagger-android-processor 处理其会根据 <code>@ContributesAndroidInjector</code> 自动生成一个Module的代码，内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Module</span>(subcomponents <span style=color:#f92672>=</span> MainActivityModule_ContributeMainActivity.<span style=color:#a6e22e>MainActivitySubcomponent</span>.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainActivityModule_ContributeMainActivity</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>MainActivityModule_ContributeMainActivity</span>() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Binds</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@IntoMap</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@ActivityKey</span>(MainActivity.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> AndroidInjector.<span style=color:#a6e22e>Factory</span><span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Activity<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>bindAndroidInjectorFactory</span>(
</span></span><span style=display:flex><span>      MainActivitySubcomponent.<span style=color:#a6e22e>Builder</span> builder);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Subcomponent</span>(modules <span style=color:#f92672>=</span> FragmentBuildersModule.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>MainActivitySubcomponent</span> <span style=color:#66d9ef>extends</span> AndroidInjector<span style=color:#f92672>&lt;</span>MainActivity<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Subcomponent.Builder</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Builder</span> <span style=color:#66d9ef>extends</span> AndroidInjector.<span style=color:#a6e22e>Builder</span><span style=color:#f92672>&lt;</span>MainActivity<span style=color:#f92672>&gt;</span> {}
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>此模块中定义了 <code>bindAndroidInjectorFactory</code> 方法，使用 <code>@Binds @IntoMap</code>生成 <code>Map&lt;Class&lt;? extends T>, Provider&lt;AndroidInjector.Factory&lt;? extends T>>></code> 类型的Map</li><li>在这里注入到Map中的内容就是 <code>(MainActivity.class, MainActivitySubcomponent.Builder builder)</code>, 其中 <code>MainActivitySubcomponent.Builder</code> 用于构建 <code>MainActivitySubcomponent</code></li><li><code>MainActivitySubcomponent</code> 继承了 <code>AndroidInjector&lt;MainActivity></code> 类，所以会有一个 <code>inject(MainActivity instance)</code>的方法，这个方法就是最中实现对 MainActivity 依赖注入的实现入口；</li></ul></li><li><p>同时 <code>dagger-android</code> 中的<code>DispatchingAndroidInjector</code> 类中，会声明对 类型<code>Map&lt;Class&lt;? extends T>, Provider&lt;AndroidInjector.Factory&lt;? extends T>>></code> 的依赖，所以上面的<code>(MainActivity.class, MainActivitySubcomponent.Builder builder)</code>会自动被注入到 <code>DispatchingAndroidInjector</code> 对象中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DispatchingAndroidInjector</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> AndroidInjector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Map<span style=color:#f92672>&lt;</span>Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;</span>, Provider<span style=color:#f92672>&lt;</span>AndroidInjector.<span style=color:#a6e22e>Factory</span><span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;&gt;&gt;</span>
</span></span><span style=display:flex><span>      injectorFactories;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>@Inject</span>
</span></span><span style=display:flex><span>      DispatchingAndroidInjector(
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;</span>, Provider<span style=color:#f92672>&lt;</span>AndroidInjector.<span style=color:#a6e22e>Factory</span><span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;&gt;&gt;</span> injectorFactories) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>injectorFactories</span> <span style=color:#f92672>=</span> injectorFactories;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span> }
</span></span></code></pre></div></li><li><p>而这个 <code>DispatchingAndroidInjector&lt;Activity></code> 在 GithubApp中被声明为依赖，所以也会被自动注入，从而我们能在GithubApp中通过 AndroidInjection 获取到 <code>DispatchingAndroidInjector&lt;Activity></code>, 然后调用其 <code>MainActivitySubcomponent</code> ，然后调用其 inject 方法完成注入</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DispatchingAndroidInjector</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> AndroidInjector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> { 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>maybeInject</span>(T instance) {
</span></span><span style=display:flex><span>    Provider<span style=color:#f92672>&lt;</span>AndroidInjector.<span style=color:#a6e22e>Factory</span><span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;&gt;</span> factoryProvider <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// instance 类型为 MainActivity，所以可以获取到 Provider&lt;MainActivitySubcomponent.Builder&gt;</span>
</span></span><span style=display:flex><span>        injectorFactories.<span style=color:#a6e22e>get</span>(instance.<span style=color:#a6e22e>getClass</span>());
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 这里就通过 MainActivitySubcomponent.Builder 获取到 factory = MainActivitySubcomponent.Builder</span>
</span></span><span style=display:flex><span>    AndroidInjector.<span style=color:#a6e22e>Factory</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> factory <span style=color:#f92672>=</span> (AndroidInjector.<span style=color:#a6e22e>Factory</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>) factoryProvider.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      AndroidInjector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> injector <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>          checkNotNull(
</span></span><span style=display:flex><span>              factory.<span style=color:#a6e22e>create</span>(instance), <span style=color:#e6db74>&#34;%s.create(I) should not return null.&#34;</span>, factory.<span style=color:#a6e22e>getClass</span>());
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 上面调用  factory.create(instance) 就是调用 MainActivitySubcomponent.Builder.create 方法创建 MainActivitySubcomponent</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 这里的 inejctor 就是 MainActivitySubcomponent</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 然后通过 MainActivitySubcomponent 的 inejct(MainActivity) 方法来实现对 MainActivity 的注入</span>
</span></span><span style=display:flex><span>      injector.<span style=color:#a6e22e>inject</span>(instance);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (ClassCastException e) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InvalidInjectorBindingException(
</span></span><span style=display:flex><span>          String.<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;%s does not implement AndroidInjector.Factory&lt;%s&gt;&#34;</span>,
</span></span><span style=display:flex><span>              factory.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getCanonicalName</span>(), instance.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getCanonicalName</span>()),
</span></span><span style=display:flex><span>          e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol></blockquote><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>现在，我们对前面的内容总结一下：</p><p><strong>dagger-android 为了实现对于Activity等Android组件的无感注入，将Activity等注入的实现Component放在了Application的成员变量中</strong></p><h3 id=解决方案>解决方案<a hidden class=anchor aria-hidden=true href=#解决方案>#</a></h3><p>之所以选择Application对象，是因为其生命周期比较持久，和应用一致。而为了对Activity实现无感注入，使用到的只是被注入到Application中的 DispatchingAndroidInjector 对象。</p><p>故我们可以将Application替换为任意一个静态的对象即可，类似如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SdkContainer</span> <span style=color:#66d9ef>implements</span> HasAndroidInjector {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Inject</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> DispatchingAndroidInjector<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> androidInjector;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AndroidInjector<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>androidInjector</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> androidInjector;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SdkInjector</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String TAG <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;SdkInjector&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> SdkContainer sSdkContainer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> SdkContainer <span style=color:#a6e22e>getSdkContainer</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sSdkContainer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>(Application application) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (sSdkContainer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        SdkComponent sSdkComponent <span style=color:#f92672>=</span> DaggerSdkComponent.<span style=color:#a6e22e>builder</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>application</span>(application)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>        SdkInjector.<span style=color:#a6e22e>sSdkContainer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SdkContainer(sSdkComponent);
</span></span><span style=display:flex><span>        sSdkComponent.<span style=color:#a6e22e>inject</span>(sSdkContainer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Singleton</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Component</span>(
</span></span><span style=display:flex><span>        modules <span style=color:#f92672>=</span> {  AndroidInjectionModule.<span style=color:#a6e22e>class</span>,}
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>SdkComponent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>inject</span>(SdkContainer sdkContainer);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Component.Builder</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Builder</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@BindsInstance</span>
</span></span><span style=display:flex><span>        Builder <span style=color:#a6e22e>application</span>(Application application);
</span></span><span style=display:flex><span>        SdkComponent <span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=mvp-架构的注入问题>MVP 架构的注入问题<a hidden class=anchor aria-hidden=true href=#mvp-架构的注入问题>#</a></h2><h3 id=mvp-中的注入问题>MVP 中的注入问题？<a hidden class=anchor aria-hidden=true href=#mvp-中的注入问题>#</a></h3><p>一个 Presenter 的一般构造方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestDiMvpActivityPresenter</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>TestDiMvpActivityPresenter</span>(TestDiView view) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestDiMvpActivity</span> <span style=color:#66d9ef>extends</span> Activity <span style=color:#66d9ef>implements</span> TestDiView {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到Presenter构造时需要一个TestDiView，而这个TestDiView实际上是 TestDiMvpActivity，而我们无法手动构造 TestDiMvpActivity 的实例，只能等系统创建之后才能获取实例，然后进行注入，所以<strong>一般MVP的注入写法如下</strong>：</p><h4 id=mvp-注入的一般写法>MVP 注入的一般写法<a hidden class=anchor aria-hidden=true href=#mvp-注入的一般写法>#</a></h4><ol><li><strong>定义子组件及模块</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 修改点1⃣️    </span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Module</span>(
</span></span><span style=display:flex><span>          subcomponents <span style=color:#f92672>=</span> TestDiMvpActivityModule.<span style=color:#a6e22e>MvpComponent</span>.<span style=color:#a6e22e>class</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>TestDiMvpActivityModule</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>@Module</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MvpModule</span> {
</span></span><span style=display:flex><span>          TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> testDiView;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MvpModule</span>(TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> testDiView) {
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>testDiView</span> <span style=color:#f92672>=</span> testDiView;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>@Provides</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>public</span> TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> <span style=color:#a6e22e>providerView</span>() {
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>return</span> testDiView;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>@Subcomponent</span>(modules <span style=color:#f92672>=</span> MvpModule.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>MvpComponent</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>inject</span>(TestDiMvpActivity activity);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>@Subcomponent.Builder</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Builder</span> {
</span></span><span style=display:flex><span>              MvpComponent <span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>              Builder <span style=color:#a6e22e>module</span>(MvpModule mvpModule);
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ol start=2><li><strong>在 RootComponent 中注册模块并提供Builder获取函数</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#a6e22e>@Singleton</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@Component</span>(
</span></span><span style=display:flex><span>           modules <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>             			 <span style=color:#75715e>//  修改点2⃣️</span>
</span></span><span style=display:flex><span>                   TestDiMvpActivityModule.<span style=color:#a6e22e>class</span>,
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>   )
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>SdkComponent</span> {
</span></span><span style=display:flex><span>	     <span style=color:#75715e>// 修改点3⃣️</span>
</span></span><span style=display:flex><span>       TestDiMvpActivityModule.<span style=color:#a6e22e>MvpComponent</span>.<span style=color:#a6e22e>Builder</span> <span style=color:#a6e22e>testDiMvpActivityMComponentBuilder</span>();
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>@Component.Builder</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Builder</span> {
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><ol start=3><li><strong>使用时在 TestDiMvpActivity.onCreate</strong> 中</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestDiMvpActivity</span> <span style=color:#66d9ef>extends</span> Activity <span style=color:#66d9ef>implements</span> TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> {
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span>(<span style=color:#a6e22e>@Nullable</span>  Bundle savedInstanceState) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 修改点4⃣️</span>
</span></span><span style=display:flex><span>   				SdkInjector.<span style=color:#a6e22e>getSdkComponent</span>().<span style=color:#a6e22e>testDiMvpActivityMComponentBuilder</span>()
</span></span><span style=display:flex><span>                   .<span style=color:#a6e22e>module</span>(<span style=color:#66d9ef>new</span> TestDiMvpActivityModule.<span style=color:#a6e22e>MvpModule</span>(<span style=color:#66d9ef>this</span>)).<span style=color:#a6e22e>build</span>()
</span></span><span style=display:flex><span>                   .<span style=color:#a6e22e>inject</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>onCreate</span>(savedInstanceState);
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><p><span style=color:green><strong>其实现原理在于：</strong></span></p><p><span style=color:green>1. 在Activity被系统初始化之后，在其onCreate中获取其实例 </span></p><p><span style=color:green>2. 将Activity实例传入到MvpModule中，然后由MvpModule中的 providers 方法来提供 View 层对象 </span></p><p><span style=color:green>3. 将 MvpModule作为参数构造MvpComponent，然后使用MvpComponent 的inject 方法对TestDiMvpActivity 执行注入动作。</span></p><h4 id=mvp-注入一般写法的问题>MVP 注入一般写法的问题<a hidden class=anchor aria-hidden=true href=#mvp-注入一般写法的问题>#</a></h4><p><span style=color:red><strong>这里的的问题在于：</strong></span></p><p><span style=color:red>1. 每添加一个Mvp的组件，都修改四个地方，添加起来非常麻烦，容易漏掉； </span></p><p><span style=color:red>2. 每次添加组件都都需要修改顶层的 Root Component（示例代码中的SdkComponent）；</span></p><p><span style=color:red>3. 需要在每个具体Mvp组件的生命周期方法（如MvpActiviy的onCreate）中添加注入代码，导致具体的实现知道了注入细节；</span></p><h3 id=解决方案-1>解决方案<a hidden class=anchor aria-hidden=true href=#解决方案-1>#</a></h3><p>上面提到的问题就是新增一个支持注入的MVP组件太麻烦，我们希望使用一种修改点少的方案，而且对于组件无感的方案。就像 dagger-android 一样。</p><p><strong>现在我们先给出方案，以便能够快速的查看解决方案的全貌效果，然后再说明其中的关键细节</strong>。</p><p>整体方案由如下主要流程：</p><h4 id=提供统一的mvp模块及组件声明>提供统一的Mvp模块及组件声明<a hidden class=anchor aria-hidden=true href=#提供统一的mvp模块及组件声明>#</a></h4><p>我们希望最终增加一个组件时，只修改一个地方，不用修改 Dagger 父组件，故我们用一个统一的MvpModule来定义，在下面的例子中，我们添加了两个需要支持Mvp的组件，其中一个为Activity，一个为Fragment。增加一个Mvp 的Activity或者Fragment时，我们只需要在MvpProvider中添加两个方法即可，一个<code>@Provider</code>标记，另外一个 <code>@ContributesAndroidInjector</code> 标记</p><p>注意其中用到了我们自定义的一个AndroidProvider 的类，后面我们会说明此类的作用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Module</span>(subcomponents <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        MvpModule.<span style=color:#a6e22e>MvpComponent</span>.<span style=color:#a6e22e>class</span>,
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>MvpModule</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Module</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MvpProvider</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@MvpScope</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Provides</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> <span style=color:#a6e22e>bindTestDiView</span>(<span style=color:#a6e22e>@Nullable</span> AndroidProvider<span style=color:#f92672>&lt;</span>Activity<span style=color:#f92672>&gt;</span> activityProvider) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (activityProvider <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> (TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span>) activityProvider.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException(<span style=color:#e6db74>&#34;Please provider activity provider when build component!&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@ContributesAndroidInjector</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>abstract</span> TestDiMvpActivity <span style=color:#a6e22e>contributeTestDiMvpActivity</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@MvpScope</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Provides</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> TestDiMvpFragmentPresenter.<span style=color:#a6e22e>View</span> <span style=color:#a6e22e>bindTestTestDiMvpFragmentView</span>(<span style=color:#a6e22e>@Nullable</span> AndroidProvider<span style=color:#f92672>&lt;</span>Fragment<span style=color:#f92672>&gt;</span> fragmentAndroidProvider) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// May delete null check to keep code clean since we provide Fragment correctly</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//            if (fragmentAndroidProvider != null) {</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (TestDiMvpFragmentPresenter.<span style=color:#a6e22e>View</span>) fragmentAndroidProvider.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>//            } else {</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//                throw new NullPointerException(&#34;Please provider Fragment provider when build component!&#34;);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//            }</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 提供 TestDiMvpFragment 的注入接口
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return TestDiMvpFragment
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@ContributesAndroidInjector</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>abstract</span> TestDiMvpFragment <span style=color:#a6e22e>contributeTestDiMvpFragment</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@MvpScope</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Subcomponent</span>(modules <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>            AndroidInjectionModule.<span style=color:#a6e22e>class</span>,
</span></span><span style=display:flex><span>            MvpProvider.<span style=color:#a6e22e>class</span>,
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>MvpComponent</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        MvpContainer <span style=color:#a6e22e>inject</span>(MvpContainer mvpContainer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Subcomponent.Builder</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Builder</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@BindsInstance</span>
</span></span><span style=display:flex><span>            Builder <span style=color:#a6e22e>activityProvider</span>(<span style=color:#a6e22e>@Nullable</span> AndroidProvider<span style=color:#f92672>&lt;</span>Activity<span style=color:#f92672>&gt;</span> activityProvider);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@BindsInstance</span>
</span></span><span style=display:flex><span>            Builder <span style=color:#a6e22e>fragmentProvider</span>(<span style=color:#a6e22e>@Nullable</span> AndroidProvider<span style=color:#f92672>&lt;</span>Fragment<span style=color:#f92672>&gt;</span> fragmentProvider);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            MvpComponent <span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Android 组件提供等，主要用于延迟提供
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param &lt;T&gt; 组件类型（Activity，Fragment）等
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AndroidProvider</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Provider<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> T item;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>AndroidProvider</span>(T item) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>item</span> <span style=color:#f92672>=</span> item;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>get</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> item;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=注册到-root-component>注册到 Root Component<a hidden class=anchor aria-hidden=true href=#注册到-root-component>#</a></h4><p>我们只需要这么注册一次即可，后续添加组件时无需再修改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Singleton</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Component</span>(
</span></span><span style=display:flex><span>        modules <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>          			<span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// MVP 组件</span>
</span></span><span style=display:flex><span>                MvpModule.<span style=color:#a6e22e>class</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>SdkComponent</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    MvpModule.<span style=color:#a6e22e>MvpComponent</span>.<span style=color:#a6e22e>Builder</span> <span style=color:#a6e22e>mvpComponentBuilder</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Component.Builder</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Builder</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=注入过程封装隐藏>注入过程封装隐藏<a hidden class=anchor aria-hidden=true href=#注入过程封装隐藏>#</a></h4><p>在之前描述的一般的MVP Activity 的注入过程中，我们是在每个具体的MvpActivity中的onCreate 方法中进行注册的，现在我们将注入的流程隐藏起来，放置到 ActivityLifeCycleCallbacks 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SdkInjector</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String TAG <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;SdkInjector&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> SdkContainer sSdkContainer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> SdkComponent <span style=color:#a6e22e>getSdkComponent</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sSdkContainer.<span style=color:#a6e22e>getSdkComponent</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> SdkContainer <span style=color:#a6e22e>getSdkContainer</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sSdkContainer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 初始化 DI
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param application Application
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>(Application application) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (sSdkContainer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        SdkComponent sSdkComponent <span style=color:#f92672>=</span> DaggerSdkComponent.<span style=color:#a6e22e>builder</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>application</span>(application)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>        SdkInjector.<span style=color:#a6e22e>sSdkContainer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SdkContainer(sSdkComponent);
</span></span><span style=display:flex><span>        sSdkComponent.<span style=color:#a6e22e>inject</span>(sSdkContainer);
</span></span><span style=display:flex><span>        sSdkContainer.<span style=color:#a6e22e>testInject</span>();
</span></span><span style=display:flex><span>        application.<span style=color:#a6e22e>registerActivityLifecycleCallbacks</span>(<span style=color:#66d9ef>new</span> BasicActivityLifeCycleCallbacks() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onActivityPreCreated</span>(<span style=color:#a6e22e>@NonNull</span> Activity activity, <span style=color:#a6e22e>@Nullable</span> Bundle savedInstanceState) {
</span></span><span style=display:flex><span>                injectActivity(activity, savedInstanceState);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>onActivityPreCreated</span>(activity, savedInstanceState);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>injectActivity</span>(<span style=color:#a6e22e>@NotNull</span> Activity activity, <span style=color:#a6e22e>@Nullable</span> Bundle savedInstanceState) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (activity <span style=color:#66d9ef>instanceof</span> MvpInjectable) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// MVP 的 Activity 注入</span>
</span></span><span style=display:flex><span>            MvpModule.<span style=color:#a6e22e>MvpComponent</span> mvpActivityComponent <span style=color:#f92672>=</span> SdkInjector.<span style=color:#a6e22e>getSdkComponent</span>()
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>mvpComponentBuilder</span>().<span style=color:#a6e22e>activityProvider</span>(<span style=color:#66d9ef>new</span> AndroidProvider<span style=color:#f92672>&lt;&gt;</span>(activity)).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>            MvpContainer mvpContainer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MvpContainer(mvpActivityComponent);
</span></span><span style=display:flex><span>            mvpActivityComponent.<span style=color:#a6e22e>inject</span>(mvpContainer);
</span></span><span style=display:flex><span>            SdkAndroidInjection.<span style=color:#a6e22e>inject</span>(activity, mvpContainer);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (activity <span style=color:#66d9ef>instanceof</span> Injectable) {
</span></span><span style=display:flex><span>            SdkAndroidInjection.<span style=color:#a6e22e>inject</span>(activity);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Log.<span style=color:#a6e22e>w</span>(TAG, <span style=color:#e6db74>&#34;Warning! You Activity &#34;</span> <span style=color:#f92672>+</span> activity.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getSimpleName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;is not injectable! &#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (activity <span style=color:#66d9ef>instanceof</span> FragmentActivity) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> FragmentManager.<span style=color:#a6e22e>FragmentLifecycleCallbacks</span> lifecycleCallbacks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FragmentManager.<span style=color:#a6e22e>FragmentLifecycleCallbacks</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onFragmentAttached</span>(<span style=color:#a6e22e>@NonNull</span> <span style=color:#a6e22e>@NotNull</span> FragmentManager fm, <span style=color:#a6e22e>@NonNull</span> <span style=color:#a6e22e>@NotNull</span> Fragment f, <span style=color:#a6e22e>@NonNull</span> <span style=color:#a6e22e>@NotNull</span> Context context) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>onFragmentAttached</span>(fm, f, context);
</span></span><span style=display:flex><span>                    injectFragment(f, activity);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            ((FragmentActivity) activity).<span style=color:#a6e22e>getSupportFragmentManager</span>()
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>registerFragmentLifecycleCallbacks</span>(lifecycleCallbacks, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>injectFragment</span>(<span style=color:#a6e22e>@NotNull</span> Fragment f, <span style=color:#a6e22e>@NotNull</span> Activity activity) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (f <span style=color:#66d9ef>instanceof</span> Injectable) {
</span></span><span style=display:flex><span>            SdkAndroidInjection.<span style=color:#a6e22e>inject</span>(f);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (f <span style=color:#66d9ef>instanceof</span> MvpInjectable) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// MVP 的 Fragment 注入</span>
</span></span><span style=display:flex><span>            MvpModule.<span style=color:#a6e22e>MvpComponent</span> mvpComponent <span style=color:#f92672>=</span> SdkInjector.<span style=color:#a6e22e>getSdkComponent</span>()
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>mvpComponentBuilder</span>()
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>activityProvider</span>(<span style=color:#66d9ef>new</span> AndroidProvider<span style=color:#f92672>&lt;&gt;</span>(activity))
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>fragmentProvider</span>(<span style=color:#66d9ef>new</span> AndroidProvider<span style=color:#f92672>&lt;&gt;</span>(f))
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>            MvpContainer mvpContainer <span style=color:#f92672>=</span> mvpComponent.<span style=color:#a6e22e>inject</span>(<span style=color:#66d9ef>new</span> MvpContainer(mvpComponent));
</span></span><span style=display:flex><span>            SdkAndroidInjection.<span style=color:#a6e22e>inject</span>(f, mvpContainer);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Log.<span style=color:#a6e22e>w</span>(TAG, <span style=color:#e6db74>&#34;Warning! You fragment  &#34;</span> <span style=color:#f92672>+</span> f.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getSimpleName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; is not injectable!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=解决方案关键点说明>解决方案关键点说明<a hidden class=anchor aria-hidden=true href=#解决方案关键点说明>#</a></h3><p>我们考虑下普通的MVP注入过程中为什么需要如此多的模板代码。</p><ol><li><p>由于P层依赖V，而 V 层是Activity，是系统生成的，所以，我们只能在onCreate 回调中获取到Activity，然后将其塞到Dagger的依赖对象的图谱中，也就是如下代码所做的</p><p>即，必须提<strong>供一个Module来接收Activity</strong>将其放入到Dagger对象Graph中，同时也必须在onCreate中你才能获取到Activity。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>			<span style=color:#a6e22e>@Module</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MvpModule</span> {
</span></span><span style=display:flex><span>          TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> testDiView;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MvpModule</span>(TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> testDiView) {
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>testDiView</span> <span style=color:#f92672>=</span> testDiView;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>@Provides</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>public</span> TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> <span style=color:#a6e22e>providerView</span>() {
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>return</span> testDiView;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span>(<span style=color:#a6e22e>@Nullable</span>  Bundle savedInstanceState) {
</span></span><span style=display:flex><span>			SdkInjector.<span style=color:#a6e22e>getSdkComponent</span>().<span style=color:#a6e22e>testDiMvpActivityMComponentBuilder</span>()
</span></span><span style=display:flex><span>        						<span style=color:#75715e>// 将Activity塞进依赖Graph</span>
</span></span><span style=display:flex><span>                   .<span style=color:#a6e22e>module</span>(<span style=color:#66d9ef>new</span> TestDiMvpActivityModule.<span style=color:#a6e22e>MvpModule</span>(<span style=color:#66d9ef>this</span>)).<span style=color:#a6e22e>build</span>()
</span></span><span style=display:flex><span>                   .<span style=color:#a6e22e>inject</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>对于无法自动注入的对象，必须要通过 Component 提供一个 <strong>inject 方法</strong>，然后调用inject方法完成对其的手动注入，也就是上面onCreate方法中所写的部分。</p></li></ol><h4 id=注入逻辑移动到activitylifecyclecallback回调及遇到的问题>注入逻辑移动到ActivityLifecycleCallback回调及遇到的问题<a hidden class=anchor aria-hidden=true href=#注入逻辑移动到activitylifecyclecallback回调及遇到的问题>#</a></h4><p>实际上，通过向Application注册ActivityLifecycleCallback回调，我们可以将具体MvpActivity中的onCreate里的注入代码隐藏起来，我们在仔细研究下onCreate 中的注入逻辑，考虑可能会遇到的问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span>(<span style=color:#a6e22e>@Nullable</span>  Bundle savedInstanceState) {
</span></span><span style=display:flex><span>			SdkInjector.<span style=color:#a6e22e>getSdkComponent</span>()
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>testDiMvpActivityMComponentBuilder</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将Activity塞进依赖Graph</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1⃣️  塞入</span>
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>module</span>(<span style=color:#66d9ef>new</span> TestDiMvpActivityModule.<span style=color:#a6e22e>MvpModule</span>(<span style=color:#66d9ef>this</span>)).<span style=color:#a6e22e>build</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2⃣️  注入</span>
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>inject</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>考虑如下两个地方：</p><ol><li>塞入：在构造TestDiMvpActivityModule.MvpModule时，我们必须要传入一个具体类型（TestDiMvpActivity），而如果我们移动到ActivityLifecycleCallback中之后，这个具体的类型信息会丢失；</li><li>注入：在inject时，我们的Component中定义的方法也是需要具体类型信息（TestDiMvpActivity）的，因为这样Dagger才能根据具体类型获取其依赖哪些信息，生成正确的注入代码，而移动到 ActivityLifecycleCallback 中之后，这个信息也会丢失；</li></ol><p>也就是说，移动到 ActivityLifecycleCallback中之后，具体的类型信息丢失了，导致我们无法正确的调用塞入方法和注入方法。</p><h4 id=使用-dagger-android-生成-inject-模板代码>使用 Dagger-Android 生成 inject 模板代码<a hidden class=anchor aria-hidden=true href=#使用-dagger-android-生成-inject-模板代码>#</a></h4><p>对于inject方法来说，我们实际上可以使用 Dagger-Android 的 <code>@ContributesAndroidInjector</code> 来帮助我们解决；</p><h4 id=使用包装类型避免dagger类型检查使用provider方法还原类型信息>使用包装类型避免Dagger类型检查，使用provider方法还原类型信息<a hidden class=anchor aria-hidden=true href=#使用包装类型避免dagger类型检查使用provider方法还原类型信息>#</a></h4><p>在塞入的过程中，由于丢失了Activity的具体类型信息，我们将无法通过类型检查，所以我们创建了一个名为 AndroidProvider 的包装类型，我们在构造组件时，原先需要TestDiMvpActivity这个具体类型，现在我们只需要传入我们的包装类型，可以做到代码统一。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// MVP 的 Activity 注入</span>
</span></span><span style=display:flex><span>            MvpModule.<span style=color:#a6e22e>MvpComponent</span> mvpActivityComponent <span style=color:#f92672>=</span> SdkInjector.<span style=color:#a6e22e>getSdkComponent</span>()
</span></span><span style=display:flex><span>              <span style=color:#75715e>// TestDiMvpActivity -&gt;  new AndroidProvider&lt;Activity&gt;(activity)</span>
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>mvpComponentBuilder</span>().<span style=color:#a6e22e>activityProvider</span>(<span style=color:#66d9ef>new</span> AndroidProvider<span style=color:#f92672>&lt;&gt;</span>(activity)).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>            MvpContainer mvpContainer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MvpContainer(mvpActivityComponent);
</span></span><span style=display:flex><span>            mvpActivityComponent.<span style=color:#a6e22e>inject</span>(mvpContainer);
</span></span><span style=display:flex><span>            SdkAndroidInjection.<span style=color:#a6e22e>inject</span>(activity, mvpContainer);
</span></span></code></pre></div><p>那么我们何时将其还原呢？</p><p>在提供对应TestDiView时，我们直接对其进行强制转换，然后提供为 TestDiView 类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#a6e22e>@Module</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MvpProvider</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Provides</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span> <span style=color:#a6e22e>bindTestDiView</span>(<span style=color:#a6e22e>@Nullable</span> AndroidProvider<span style=color:#f92672>&lt;</span>Activity<span style=color:#f92672>&gt;</span> activityProvider) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (activityProvider <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> (TestDiMvpActivityPresenter.<span style=color:#a6e22e>TestDiView</span>) activityProvider.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException(<span style=color:#e6db74>&#34;Please provider activity provider when build component!&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=示例代码>示例代码<a hidden class=anchor aria-hidden=true href=#示例代码>#</a></h2><p>具体实施过程中还有一些细节，可以参考Github中对应示例模块的源码。</p><ul><li><a href=https://github.com/hanlyjiang/android-libraries/tree/master/lib_di_sample>android-libraries/lib_di_sample at master · hanlyjiang/android-libraries (github.com)</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://hanlyjiang.github.io/tags/android/>Android</a></li><li><a href=https://hanlyjiang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a></li><li><a href=https://hanlyjiang.github.io/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/>依赖注入</a></li><li><a href=https://hanlyjiang.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/>开源框架</a></li></ul><nav class=paginav><a class=prev href=https://hanlyjiang.github.io/posts/aar-java8-jie-kou-nosuchmethoderror-cuo-wu-jie-jue-ji-lu/><span class=title>« 上一页</span><br><span>AAR Java8 接口 NoSuchMethodError 错误解决记录</span>
</a><a class=next href=https://hanlyjiang.github.io/posts/shi-yong-kotlin-bian-xie-gradle-jiao-ben/><span class=title>下一页 »</span><br><span>使用Kotlin编写gradle脚本</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hanlyjiang.github.io/>清水池塘</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>