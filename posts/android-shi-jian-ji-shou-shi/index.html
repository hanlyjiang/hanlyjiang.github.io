<!doctype html><html lang=zh-cn dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android事件及手势 | 清水池塘</title><meta name=keywords content="Android"><meta name=description content="android事件基础及手势，主要关注各种手势的使用及其计算原理 。

Android事件基础
这里我们主要关注概念
事件监听器及事件处理程序
可直接查看 官方文档，此处仅做简要描述；
事件监听器
View类的包含一个回调方法的接口，通过setXXXListener来定义事件处理程序；

事件监听器是 View 类中包含一个回调方法的接口。当用户与界面项目之间的互动触发已注册监听器的 View 对象时，Android 框架将调用这些方法。"><meta name=author content="野生莲藕"><link rel=canonical href=https://hanlyjiang.github.io/posts/android-shi-jian-ji-shou-shi/><link crossorigin=anonymous href=/assets/css/stylesheet.0ddbb411bed5280eeba0e4a55c287e6addf14dc6eb09c604363a7ce5c4d40c1c.css integrity="sha256-Ddu0Eb7VKA7roOSlXCh+at3xTcbrCcYENjp85cTUDBw=" rel="preload stylesheet" as=style><link rel=icon href=https://hanlyjiang.github.io/img/home.png><link rel=icon type=image/png sizes=16x16 href=https://hanlyjiang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hanlyjiang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://hanlyjiang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://hanlyjiang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://hanlyjiang.github.io/posts/android-shi-jian-ji-shou-shi/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hanlyjiang.github.io/posts/android-shi-jian-ji-shou-shi/"><meta property="og:site_name" content="清水池塘"><meta property="og:title" content="Android事件及手势"><meta property="og:description" content="android事件基础及手势，主要关注各种手势的使用及其计算原理 。
Android事件基础 这里我们主要关注概念
事件监听器及事件处理程序 可直接查看 官方文档，此处仅做简要描述；
事件监听器 View类的包含一个回调方法的接口，通过setXXXListener来定义事件处理程序；
事件监听器是 View 类中包含一个回调方法的接口。当用户与界面项目之间的互动触发已注册监听器的 View 对象时，Android 框架将调用这些方法。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-02-20T10:13:24+00:00"><meta property="article:modified_time" content="2018-02-20T10:13:24+00:00"><meta property="article:tag" content="Android"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android事件及手势"><meta name=twitter:description content="android事件基础及手势，主要关注各种手势的使用及其计算原理 。

Android事件基础
这里我们主要关注概念
事件监听器及事件处理程序
可直接查看 官方文档，此处仅做简要描述；
事件监听器
View类的包含一个回调方法的接口，通过setXXXListener来定义事件处理程序；

事件监听器是 View 类中包含一个回调方法的接口。当用户与界面项目之间的互动触发已注册监听器的 View 对象时，Android 框架将调用这些方法。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hanlyjiang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Android事件及手势","item":"https://hanlyjiang.github.io/posts/android-shi-jian-ji-shou-shi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android事件及手势","name":"Android事件及手势","description":"android事件基础及手势，主要关注各种手势的使用及其计算原理 。\nAndroid事件基础 这里我们主要关注概念\n事件监听器及事件处理程序 可直接查看 官方文档，此处仅做简要描述；\n事件监听器 View类的包含一个回调方法的接口，通过setXXXListener来定义事件处理程序；\n事件监听器是 View 类中包含一个回调方法的接口。当用户与界面项目之间的互动触发已注册监听器的 View 对象时，Android 框架将调用这些方法。\n","keywords":["Android"],"articleBody":"android事件基础及手势，主要关注各种手势的使用及其计算原理 。\nAndroid事件基础 这里我们主要关注概念\n事件监听器及事件处理程序 可直接查看 官方文档，此处仅做简要描述；\n事件监听器 View类的包含一个回调方法的接口，通过setXXXListener来定义事件处理程序；\n事件监听器是 View 类中包含一个回调方法的接口。当用户与界面项目之间的互动触发已注册监听器的 View 对象时，Android 框架将调用这些方法。\n事件监听器接口中包含以下回调方法：onClick()，onLongClick()，onFocusChange()，onKey()，onTouch()，onCreateContextMenu()\n我们重点关注onTouch：\nonTouch()： 在 View.OnTouchListener 中。当用户执行可视为触摸事件的操作时，包括按下、释放或屏幕上的任何移动手势（在项目边界内），系统会调用此方法。\n此方法返回一个布尔值，指示监听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。因此，如果在收到 down 操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。因此，您无需执行事件内的任何其他操作，如手势或最终的 up 操作事件。\n事件处理程序 直接引用官方文档描述：\n如果您从 View 构建自定义组件，则可定义几种回调方法，用作默认事件处理程序。在有关自定义 View 组件的文档中，您将了解一些用于事件处理的常见回调，包括：\nonKeyDown(int, KeyEvent)：在发生新的按键事件时调用。 onKeyUp(int, KeyEvent)：在发生 key up 事件时调用。 onTrackballEvent(MotionEvent)：在发生轨迹球动作事件时调用。 onTouchEvent(MotionEvent)：在发生触屏动作事件时调用。 onFocusChanged(boolean, int, Rect)：在 View 对象获得或失去焦点时调用。 还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。因此，在管理布局内更复杂的事件时，不妨考虑使用以下其他方法：\nActivity.dispatchTouchEvent(MotionEvent)：此方法允许 Activity 在所有触摸事件分派给窗口之前截获它们。 ViewGroup.onInterceptTouchEvent(MotionEvent)：此方法允许 ViewGroup 监视分派给子级 View 的事件。 ViewParent.requestDisallowInterceptTouchEvent(boolean)：对父级 View 调用此方法，可指示不应使用 onInterceptTouchEvent(MotionEvent) 截获触摸事件。 这里我们重点关注 onTouchEvent(MotionEvent) 即在发生触屏动作事件时调用的回调方法；\n触摸手势 手势可以让用户通过触摸来与屏幕元素进行交互；\n用户交户角度的手势划分：\n手势类型 具体手势-不同类型之间有重复 解释 导航手势 实现导航作用 点击 - Tap 如：点击按钮跳转到另外一个页面 滚动和拖移 - Scroll\u0026Pan 如：滑动图片列表或拖动以浏览地图Scroll - 快速拖动并抬起手指时发生的一种滚动 Pan-拖移，慢速移动 拖动/拖拽 - Drag 用户在触摸屏上拖动手指时发生的一种滚动如：按住底部sheet并向屏幕顶部拖动 轻扫 - Swipe 单个手指触摸屏幕并快速地朝任意一个方向滑动如：左右滑动以在不同的Tab页中切换 捏合/缩放 - Pinch 双指或多指捏合如：在一个图片列表中缩放一个item进入大图查看界面 动作手势 执行某种动作 点击 - Tap 长按 - Long press 如：长按选中 轻扫 - Swipe 如：轻扫item展现删除/收藏按钮 变换手势 用于改变元素大小，位置，旋转角度，实现变换效果 双击 - Double tap 如：双击缩放图片 捏合/缩放 - Pinch 如：缩放查看图片细节 组合手势 如：地图中的放大缩小\u0026旋转 选取并拖动 - Pick up\u0026Move 长按选择元素 + 拖动元素 来源及手势的动画效果可以看这里： material.io\nAndroid中用于检测或处理手势的类/方法：\nGestureDetector：支持检测按下、滑动、长按等手势；事件回调方法包括 onDown()、onLongPress()、onFling()、[onScroll()](https://developer.android.google.cn/reference/android/view/GestureDetector.OnGestureListener#onScroll(android.view.MotionEvent, android.view.MotionEvent, float, float)) 等。可以将 GestureDetector 与 onTouchEvent() 方法结合使用； ScaleGestureDetector：用于检测缩放手势； onTouchEvent()： 直接处理onTouchEvent()方法，然后自行根据事件序列来判断手势； VelocityTracker：用于跟踪触摸事件的速度，如滑动事件中一般需要结合速度来使用； Scroller \u0026 OverScroller： 用于收集触摸事件来生成滚动动画所需的数据，OverScroller可以指示滑动后是否到达了内容边缘； 两种不同的滚动: 拖动和滑动\n拖动是指用户在触摸屏上拖动手指时发生的一种滚动。简单的拖动通常是通过替换 GestureDetector.OnGestureListener 中的 onScroll() 实现的。有关拖动的详细讨论，可参阅拖动和缩放。 滑动是用户快速拖动并抬起手指时发生的一种滚动。在用户抬起手指后，您通常需要继续滚动（移动视口），但要减速，直到视口停止移动为止。滑动可以通过替换 GestureDetector.OnGestureListener 中的 onFling() 以及使用滚动条对象来实现。 系统会在用户拖动手指以平移内容时调用 onScroll()，系统仅在手指还在屏幕上时才会调用 onScroll()；当手指从屏幕上抬起时，手势便会结束，或开始执行滑动手势（如果手指在抬起之前正在以一定的速度移动）。 接下来我们详细了解触摸手势中各个item的用法；\n触摸事件类逐个了解 我们先对涉及的元素类进行单独学习，由于普通的事件监听器比较简单，所以主要关注触摸手势部分，这块先从GestureDetector开始；\nGestureDetector 详解 能够识别的手势，是 GestureDetector.OnGestureListener及 ，GestureDetector.SimpleOnGestureListener ,其中 包括如下几种：\n回调方法 对应事件触发时机及说明 onDown(downEvent):Boolean 点按按下手指时 event为down事件时触发. onFling(downEvent,upEvent,velocityX,velocityY):Boolean 滑动(投掷)事件发生时触发 onLongPress(downEvent) 发生长按事件时触发 onScroll(downEvent,moveEvent,distanceX,distanceY):Boolean 拖动事件发生时 onShowPress(downEvent) 按在屏幕上但是没有移动或抬起手指 onSingleTapUp(upEvent):Boolean 点按抬起手指时触发 GestureDetector.SimpleOnGestureListener onContextClick(event) 上下文菜单点击事件发生时 onDoubleTap(event) 双击事件 onDoubleTapEvent(event) 双击事件过程中的事件，包括down，move，up事件 onSingleTapConfirmed(event) 单次点击发生时 问题： 以下通过阅读API文档并编写简单的示例代码，通过操作触发对应的手势来观察以确定以下问题的答案。\nGestureDetector 各个事件发生的关系，有无交叉？ 按下-释放可能的事件序列： onDown - onSingleTapUp： 按下，迅速抬起（干净利落的） onDown - onShowPress - onSingleTapUp：按下，缓慢抬起 onDown - onShowPress - onLongPress：按下，稍有延迟的抬起 onScroll触发的可能事件序列： longPress 被触发之后，无法再触发onScroll onDown - onScroll onDown - onShowPress - onScroll onFling的触发序列 触发onScroll - 多个 onScroll - onFling GestureDetector.SimpleOnGestureDetector 单次点击事件序列： onDown - onSingleTapUp - onSingleTapConfirmed onDown - onShowPress - onSingleTapUp - onSingleTapConfirmed （按下后稍有停顿） 双击可能的事件序列： onDown - onShowPress - onSingleTapUp - onDoubleTap_down - onDoubleTapEvent_down - onDown - onShowPress - onDoubleTapEvent_up 滑动onFling和拖动onScroll的区别时机？ onScroll一定先发生，如果抬起时有一定速度，就会触发onFling onSingleTapUp(upEvent) 及 onSingleTapConfirmed(event)的区别？ onSingleTapConfirmed 只会在确认当前tap之后不会有另外一次tap构成double-tap手势的情况下才会被触发，也就是说onSingleTapUp实际上有可能时doubleTap的一次事件，如果确定只能又明确的单次点击事件触发，就需要区分 onDoubleTab 和 onDoubleTapEvent 之前的区别？ onDoubleTab 只包含down事件，而onDoubleTapEvent则还包含其他事件（move，up） Scroller 详解 scroller 本身并不与View关联，仅用于做辅助的动画计算，使用起来有以下步骤：\n初始化 通过startScroll或fling方法设定计算模型及计算所需要的参数 定期调用 computeScrollOffset 进行运算，然后取出运算后的值 使用运算后的值动态的改变View的属性实现滚动效果 计算模型： 模型/方法 参数 含义 startScroll startX 起始水平滚动偏移量（以像素为单位），正数会将内容向左滚动。 startY 开始的垂直滚动偏移量（以像素为单位）。 正数将使内容向上滚动。 dx 滑动的水平距离。 正数会将内容向左滚动。 dy 垂直滑动距离。 正数将使内容向上滚动。 duration 滚动持续时间（以毫秒为单位） fling startX 滚动的起点（X） startY 滚动的起点（Y） velocityX 滚动的初始速度（X方向），以像素/秒为单位。 velocityY 滚动的初始速度（Y方向），以像素/秒为单位。 minX 最小X值。 滚动条将不会滚动到该点。 maxX 最大X值。 滚动条将不会滚动到该点。 minY 最小Y值。 滚动条将不会滚动到该点。 maxY 最大Y值。 滚动条将不会滚动到该点。 计算结果值 方法/值 说明 getCurrX 新的X偏移量是距原点的绝对距离。 getCurrY 新的Y偏移量是距原点的绝对距离。 ScaleGestureDetector 详解 使用提供的 MotionEvent 事件序列来检测缩放手势，当检测到对应的缩放事件时，会通过 OnScaleGestureListener 来通知用户；\n使用流程：\n为 View 创建 ScaleGestureDetector 实例； 在 View.onTouchEvent(MotionEvent) 方法中调用 ScaleGestureDetector 实例的 onTouchEvent 方法； 基本用法 构造函数 仓库 含义/作用 context 上下文 ScaleGestureListener 缩放监听 Handler（可选） 用于运行延迟侦听事件的处理程序 方法及属性 属性/方法 含义说明 备注 getCurrentSpan 两个手指之间的通过手势焦点的平均距离 （何为平均距离？） getCurrentSpanX 形成手势的过程中两个手指之间通过手势焦点的X方向的平均距离 两个手指的滑动X距离相加取平均 getCurrentSpanY 形成手势的过程中两个手指之间通过手势焦点的Y方向的平均距离 两个手指的滑动Y距离相加取平均 getEventTime 返回正在处理的当前事件的事件时间 getFocusX 当前手势焦点（gesture’s focal point）的X坐标 手势焦点=两个手势点的中点；双击触发时则是触摸点 getFocusY 当前手势焦点（gesture’s focal point）的Y坐标 两个手势点的中点 getPreviousSpan 之前的 两个手指之间的通过手势焦点的平均距离 上次回调（scaleBegin/scale）的span参数 getPreviousSpanX 之前的 形成手势的过程中两个手指之间通过手势焦点的X方向的平均距离 getPreviousSpanY 之前的 形成手势的过程中两个手指之间通过手势焦点的Y方向的平均距离 getScaleFactor 从之前的缩放事件到当前缩放事件的 缩放比例 两次回调之间的缩放比例 getTimeDelta 上一个被接受的缩放事件到当前缩放事件之前的时间差 两次回调之间的 isInProgress 缩放手势是否正在进行中 ScaleBegin 中为false，另外两个为true isQuickScaleEnabled 是否启用了快速缩放-用户通过双击+一个Swipe操作来触发缩放 isStylusScaleEnabled 返回用户使用触笔并按下按钮的触笔缩放手势是否应该执行缩放。 setQuickScaleEnabled 当用户执行双击+Swipe动作时是否触发缩放监听 setStylusScaleEnabled 当用户执行触笔缩放动作时是否触发缩放监听 onTouchEvent 接受MotionEvents并在适当的时机分发事件到 OnScaleGestureListener 如何使用？\n构造侦听器对象； 在 onTouchEvent 回调中调用侦听器对象的 onTouchEvent方法并传入MotionEvent； var mScaleGestureDetector = ScaleGestureDetector(this,this) override fun onTouchEvent(event: MotionEvent?): Boolean { return mScaleGestureDetector.onTouchEvent(event) || super.onTouchEvent(event) } 深入探究 如何触发手势？ 两个手指张开闭合就可以 如何消费手势？ 如何利用手势的参数实现缩放的动画/动作？ 如何消费手势？ 事件类型 CurrentSpan currentSpanX currentSpanY EventTime FocusX FocusY Previouspan PreviouspanX PreviouspanY ScaleFactor TimeDelta isInProgress isQuickScaleEnabled isStylusScaleEnabled onScaleBegin 448.18158 338.30157 293.9707 120680064 405.82724 765.9927 448.18158 338.30157 293.9707 1.0 0 FALSE TRUE TRUE onScale 448.18158 338.30157 293.9707 120680064 405.82724 765.9927 448.18158 338.30157 293.9707 1.0 0 TRUE TRUE true onScale 473.83823 355.72217 313.0246 120680081 408.95367 770.60486 448.18158 338.30157 293.9707 1.0572461 17 TRUE TRUE true onScale 492.1729 367.65485 327.20648 120680098 410.2758 772.77576 473.83823 355.72217 313.0246 1.038694 17 TRUE TRUE true onScale 509.8993 380.36285 339.59003 120680114 411.72714 775.3407 492.1729 367.65485 327.20648 1.0360166 16 TRUE TRUE true onScale 526.8072 391.90063 352.05072 120680131 413.6501 777.7251 509.8993 380.36285 339.59003 1.0331593 17 TRUE TRUE true onScale 541.9916 402.3568 363.13068 120680147 415.72614 780.33923 526.8072 391.90063 352.05072 1.0288234 16 TRUE TRUE true onScale 552.3365 408.6225 371.62244 120680164 418.1556 782.6556 541.9916 402.3568 363.13068 1.0190868 17 TRUE TRUE true onScale 560.9881 413.25342 379.38013 120680181 418.5 783.56335 552.3365 408.6225 371.62244 1.0156636 17 TRUE TRUE true onScale 567.2112 417.16174 384.32355 120680197 419.58087 785.08093 560.9881 413.25342 379.38013 1.011093 16 TRUE TRUE true onScale 575.6995 423.24652 390.24646 120680214 420.5411 786.0411 567.2112 417.16174 384.32355 1.014965 17 TRUE TRUE true onScale 584.7019 428.15033 398.2005 120680230 422.02505 788.0502 575.6995 423.24652 390.24646 1.0156373 16 TRUE TRUE true onScale 592.25555 432.04736 405.09473 120680247 423.02368 789.5237 584.7019 428.15033 398.2005 1.0129188 17 TRUE TRUE true onScale 601.86597 436.95844 413.89606 120680263 424.47922 791.9689 592.25555 432.04736 405.09473 1.0162268 16 TRUE TRUE true onScale 611.9895 442.71814 422.5302 120680280 425.453 793.453 601.86597 436.95844 413.89606 1.0168202 17 TRUE TRUE true onScale 621.78754 447.69666 431.49445 120680297 426.94946 794.94946 611.9895 442.71814 422.5302 1.0160102 17 TRUE TRUE true onScale 629.77124 451.88318 438.64954 120680313 427.9416 795.4416 621.78754 447.69666 431.49445 1.0128399 16 TRUE TRUE true onScale 636.78015 454.8739 445.6217 120680330 428.43695 795.93695 629.77124 451.88318 438.64954 1.0111293 17 TRUE TRUE true onScaleEnd 644.16754 458.65613 452.31226 120680346 428.5 795.5 636.78015 454.8739 445.6217 1.0 16 TRUE TRUE true 以下是测试过程中的detector的属性变化数据，可以发现如下规律：\nonScaleBegin 时 inProgress为false\ncurrentSpan^2 = currentSpanX^2 * currentSpanY^2 ，即currentSpan为两个手指总共移动的距离，如下图所示：\n手指1移动的轨迹为蓝色矩形中的对角线，手指2移动的轨迹为红色矩形的对角线 currentSpan 就是两个手指移动的对角线相加，currentSpanX和currentSpanY分别为蓝色矩形和红色矩形按如下方式拼接成一个大的矩形之后的两条边； 每次事件的previouSpan的值都等于上次事件的currentSpan的值； FocusX和FocusY即为事件回调触发时两个手指连线的中点坐标，随着手指的不断移动，焦点也是不断的变化的； 大部分timeDelta都在16-17ms左右，所以不应在回调方法中执行耗时事件，对应逻辑应放置到Runnable中去执行； scaleBegin和第一次onScale回调的各项值都一致，除了scaleBegin的isInProgress为FALSE； 缩放比例（scaleFactor）为1.0时，没有缩放； 如何利用手势的参数实现缩放的动画/动作？ 假设我现在需要在检测到缩放手势时同步的对ImageView执行缩放动作，此时应该怎么做？\n如何对ImageView的图片进行缩放？ 根据缩放比例不断的重新设置View的scaleX及scaleY的值； 每次事件触发都进行缩放操作？还是积累一定程度之后进行？ 由于每次变化的时间非常短，所以我们应该在每次onScale方法触发时执行变换； 如何让View根据手势效果进行变换？ 通过之前对手势侦听器，缩放手势侦听器及滚动条类的学习及分析，我们知道了各个类的基本用途：\nGeostureDetector： 辅助侦听判断down，tag，doubletap，scroll，fling等手势并在检测到手势后回调对应的方法，给出事件相关的参数数据； ScaleGeostureDetector： 辅助侦听判断缩放手势，并在缩放手势发生时通过回调对应方法来通知我们对应事件的发生，并给出事件相关的参数数据； Scroller： 用于辅助计算生成滚动过程中的一系列值的序列； 可以方向，上述类只是告诉你事件发生了，还有告诉你事件的相关参数，如滚动事件的滚动距离，fling事件的滑动速度，等等，但是都没有涉及到如何变换将这些事件反映到界面的变化上，那么我们如何将上述的事件变化反映到界面上呢？\nView基础属性 部分变化效果都是针对View/ViewGroup来说的，要想改变View，就得改变其属性，如：\n滑动时改变TransitionX，TransitionY 缩放时改变View的scaleX/scaleY 我们需要研究View中有哪些属性，属性如何影响View的展示效果，以下通过API文档的setXXX属性列出View的部分属性：\n属性 说明 alpha 透明度 background/backgroundColor 背景 bottomleftrighttopelevation 视图相对于parent的位置elevation为view的深度 clipBounds 矩形裁剪区域，view的内容会在该区域绘制 clipToOutline:Boolean fadingEdgeLength 用于指示此视图中更多内容可用的褪色边缘的大小 foreground 前景drawable layoutParams 布局参数 minHeightminWidth 最小宽高 padding 内边距 relativePadding 减去可能的滚动条尺寸 pivotXpivotY view 旋转缩放所围绕的点。默认为view中点坐标 rotation 绕pivot点的旋转角度 rotationXrotationY 绕通过pivot点的水平线/垂直线的旋转角度 scaleXscaleY X/Y方向上绕pivot点的缩放比例，1.0表示无缩放 scrollXscrollY 水平/垂直滚动位置的position translationXtranslationYtranslationZ 相对于视图左边位置的水平/垂直/深度位置，可以改变布局 x/y/z x: x位置； 等效translationX=x-lefty: y位置； 等效translationY=y-topz: z位置； 等效translationZ=z-elevation 与视图变化相关的最基本的就是加粗部分的属性，总结起来就是位置，大小，透明度，旋转，缩放，平移。其他具体的子View则可能引入自己的属性；\n那么旋转/平移/缩放究竟改变的是啥？ 滚动及平移（scroll/fling）：改变x和y（亦可以通过translationX/Y，最终都是改变了x和y） 缩放： 改变scaleX/scaleY/pivotX/pivotY Matrix解析 用途： matrix存储一个3x3的矩阵，用于对坐标进行变换； $$ \\begin{bmatrix} MSCALE_X \u0026 MSKEW_X \u0026 MTRANS_X \\ MSKEW_Y \u0026 MSCALE_Y \u0026 MTRANS_Y \\ MPERSP_0 \u0026 MPERSP_1 \u0026 MPERSP_2 \\ \\end{bmatrix} $$ 矩阵各个元素的用途：\n字段 用途 MSCALE_X，MSCALE_Y 控制X轴和Y轴方向的缩放 MSKEW_X，MSKEW_Y 控制X坐标和Y坐标的扭曲系数(旋转) MTRANS_X，MTRANS_Y 控制X方向和Y方向的线性平移 MPERSP_0 , MPERSP_1 , MPERSP_2 MPERSP_0、MPERSP_1和MPERSP_2是关于透视的控制 Matrix提供一系列的辅助变换函数，每种类型有 pre,post,set三种操作方式，矩阵的乘法运算顺序不一致结果不同，pre表示前（preconcats），post表示后（postconcats），set为直接设置；\npostScale方法来对坐标后接触缩放变换，有两种变体：\n方法 说明 postScale (float sx, float sy, float px, float py) 使用指定的scale执行矩阵postconcats：M' = S(sx, sy, px, py) * M 其中sx，sy分别为x轴和y轴的缩放大小，px，py为缩放中心点的坐标 boolean postScale (float sx, float sy) 使用指定的scale执行矩阵postconcats： M' = S(sx, sy) * M post和set及pre的区别 scale currentScale preScale 和postScale对值产生一样的效果，但是如果有其他变换一起使用，他会先于set被应用 setScale 直接覆盖，如果matrix中原先有scale的值，那么原先的值会被覆盖 postScale 只需要设置增量即可，如原先的scale为0.5425669，postScale(1.3947428)后scale的值为 $$0.5425669*1.3947428 = 0.7567413$$ Matrix如何与ImageView结合 那么我们如何才能将Matrix同ImageView或者Canvas或者Bitmap结合起来呢？\n查找Canvas的相关方法，可以看到setMatrix方法，\npublic void setMatrix (Matrix matrix) Completely replace the current matrix with the specified matrix. If the matrix parameter is null, then the current matrix is reset to identity. Note: it is recommended to use concat(android.graphics.Matrix), scale(float, float), translate(float, float) and rotate(float) instead of this method.\n同时下面温馨提示，让我们使用其他方法，其中涉及到矩阵的就有contact，所以我们研究下contact方法：\ncontact方法接受一个Matrix对象，可以将参数中的矩阵预连接到canvas本身的矩阵上（Preconcat the current matrix with the specified matrix.）；假设当前矩阵为C，要连接的矩阵为S，这里的预连接（preconcat）指的是：C = S x C\n单一效果实现 拖动效果实现 初始化GestureDetector\nprivate lateinit var mDetector: GestureDetector override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) mDetector = GestureDetector(this, simpleDetectorListener) } 使用 GestureDetector 侦听 onScroll 手势\noverride fun dispatchTouchEvent(ev: MotionEvent?): Boolean { return mDetector.onTouchEvent(ev) } GestureDetector 的 onScroll 回调方法中处理滚动事件\noverride fun onScroll(e1: MotionEvent?, e2: MotionEvent?, distanceX: Float, distanceY: Float): Boolean { // 改变ImageView 的x和y imageView.x -= distanceX imageView.y -= distanceY return true } Fling-投掷效果实现 初始化GestureDetector及 Scroller\nprivate lateinit var mDetector: GestureDetector private lateinit var mScroller: Scroller override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) mDetector = GestureDetector(this, simpleDetectorListener) mScroller = Scroller(this) } 在onTouchEvent或dispatchTouchEvent中使用GestureDetector 侦听 onFling 手势\noverride fun dispatchTouchEvent(ev: MotionEvent?): Boolean { return mDetector.onTouchEvent(ev) } onFling回调中使用Scroller 完成滚动辅助计算并从Scroller中获取参数来更新视图的x,y相关属性\noverride fun onFling(e1: MotionEvent?, e2: MotionEvent?, velocityX: Float, velocityY: Float): Boolean { return handleFling(e1, e2, velocityX, velocityY) } private fun handleFling(down: MotionEvent?, move: MotionEvent?, velocityX: Float, velocityY: Float): Boolean { // 停止 mScroller.forceFinished(true) val minX: Int = (imageView.pivotX * (1 - imageView.scaleX)).roundToInt() val minY: Int = (imageView.pivotY * (1 - imageView.scaleY)).roundToInt() val maxX: Int = ((imageView.width - imageView.pivotX) * (imageView.scaleX - 1)).roundToInt() val maxY: Int = ((imageView.height - imageView.pivotY) * (imageView.scaleY - 1)).roundToInt() mScroller.fling(imageView.x.toInt(), imageView.y.toInt(), velocityX.toInt(), velocityY.toInt(), minX, maxX, minY, maxY) // Invalidate to request a redraw isFling = true postFling() return true } private fun postFling() { imageView.postDelayed(flingRunnable, 16L) } private val flingRunnable = Runnable { if (!mScroller.isFinished ) { // 计算滚动后的参数 mScroller.computeScrollOffset() // 从滚动器中获取计算出的值并更新图片的x,y属性 imageView.x = mScroller.currX.toFloat() imageView.y = mScroller.currY.toFloat() // 定期刷新 postFling() } } View缩放后fling边界计算\n说明：\n缩放前宽：width\n缩放前高：height\n缩放比例：scale\n缩放焦点坐标：focusX，focusY\nminX = - focusX * （scale-1）\nminY = - focusY * （scale-1）\nmaxX = （width-focusX）*（scale-1）\nmaxY = （height-focusY）*（scale-1）\nScaleGestureDetector 实现双指缩放效果 初始化 ScaleGestureDetector ；\nprivate lateinit var mScaleDetector: ScaleGestureDetector private val scaleDetectorListener: ScaleGestureDetector.OnScaleGestureListener = object : ScaleGestureDetector.OnScaleGestureListener { override fun onScaleBegin(detector: ScaleGestureDetector?): Boolean { isScaling = true scaleStartX = detector!!.focusX scaleStartY = detector.focusY return true } override fun onScale(detector: ScaleGestureDetector?): Boolean { Timber.tag(\"GestureDetector\").d(\"handleScale onScale\") detector?.run { handleScale(detector) } return true } override fun onScaleEnd(detector: ScaleGestureDetector?) { Timber.tag(\"GestureDetector\").d(\"handleScale onScaleEnd\") isScaling = false } } 事件分发时调用 ScaleGestureDetector 的 onTouchEvent 方法传递事件序列；\n在scale事件回调方法中处理scale事件-根据事件参数更新View的缩放（scaleX，scaleY）属性完成视图更新；\n参考文章 matrix参考 Android matrix.postScale的用法 Android Matrix Matrix学习1、基础的知识 MathJax基本的使用方式 Typora Math Block What does it mean to “preconcat” a matrix in Android? Android Matrix的pre、post理解 android手势 手势类型- Material.io ","wordCount":"8181","inLanguage":"zh-cn","datePublished":"2018-02-20T10:13:24Z","dateModified":"2018-02-20T10:13:24Z","author":{"@type":"Person","name":"野生莲藕"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hanlyjiang.github.io/posts/android-shi-jian-ji-shou-shi/"},"publisher":{"@type":"Organization","name":"清水池塘","logo":{"@type":"ImageObject","url":"https://hanlyjiang.github.io/img/home.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hanlyjiang.github.io/ accesskey=h title="清水池塘 (Alt + H)"><img src=https://hanlyjiang.github.io/img/home.png alt aria-label=logo height=35>清水池塘</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hanlyjiang.github.io/ title=首页><span><i class='fas fa-home'></i>首页</span></a></li><li><a href=https://hanlyjiang.github.io/archives/ title=归档><span><i class='fas fa-tags'></i>归档</span></a></li><li><a href=https://hanlyjiang.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hanlyjiang.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hanlyjiang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hanlyjiang.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Android事件及手势</h1><div class=post-meta><span title='2018-02-20 10:13:24 +0000 UTC'>2018年2月20日</span>&nbsp;·&nbsp;<span>17 min</span>&nbsp;·&nbsp;<span>野生莲藕</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#android%e4%ba%8b%e4%bb%b6%e5%9f%ba%e7%a1%80 aria-label=Android事件基础>Android事件基础</a><ul><li><a href=#%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e5%8f%8a%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f aria-label=事件监听器及事件处理程序>事件监听器及事件处理程序</a><ul><li><a href=#%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8 aria-label=事件监听器>事件监听器</a></li><li><a href=#%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f aria-label=事件处理程序>事件处理程序</a></li></ul></li><li><a href=#%e8%a7%a6%e6%91%b8%e6%89%8b%e5%8a%bf aria-label=触摸手势>触摸手势</a></li></ul></li><li><a href=#%e8%a7%a6%e6%91%b8%e4%ba%8b%e4%bb%b6%e7%b1%bb%e9%80%90%e4%b8%aa%e4%ba%86%e8%a7%a3 aria-label=触摸事件类逐个了解>触摸事件类逐个了解</a><ul><li><a href=#gesturedetector-%e8%af%a6%e8%a7%a3 aria-label="GestureDetector 详解">GestureDetector 详解</a><ul><li><a href=#%e9%97%ae%e9%a2%98 aria-label=问题：>问题：</a></li><li><a href=#scroller-%e8%af%a6%e8%a7%a3 aria-label="Scroller 详解">Scroller 详解</a><ul><li><a href=#%e8%ae%a1%e7%ae%97%e6%a8%a1%e5%9e%8b aria-label=计算模型：>计算模型：</a></li><li><a href=#%e8%ae%a1%e7%ae%97%e7%bb%93%e6%9e%9c%e5%80%bc aria-label=计算结果值>计算结果值</a></li></ul></li></ul></li><li><a href=#scalegesturedetector-%e8%af%a6%e8%a7%a3 aria-label="ScaleGestureDetector 详解">ScaleGestureDetector 详解</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95 aria-label=基本用法>基本用法</a><ul><li><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=构造函数>构造函数</a></li><li><a href=#%e6%96%b9%e6%b3%95%e5%8f%8a%e5%b1%9e%e6%80%a7 aria-label=方法及属性>方法及属性</a></li></ul></li><li><a href=#%e6%b7%b1%e5%85%a5%e6%8e%a2%e7%a9%b6 aria-label=深入探究>深入探究</a><ul><li><a href=#%e5%a6%82%e4%bd%95%e6%b6%88%e8%b4%b9%e6%89%8b%e5%8a%bf aria-label=如何消费手势？>如何消费手势？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8%e6%89%8b%e5%8a%bf%e7%9a%84%e5%8f%82%e6%95%b0%e5%ae%9e%e7%8e%b0%e7%bc%a9%e6%94%be%e7%9a%84%e5%8a%a8%e7%94%bb%e5%8a%a8%e4%bd%9c aria-label=如何利用手势的参数实现缩放的动画/动作？>如何利用手势的参数实现缩放的动画/动作？</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e8%ae%a9view%e6%a0%b9%e6%8d%ae%e6%89%8b%e5%8a%bf%e6%95%88%e6%9e%9c%e8%bf%9b%e8%a1%8c%e5%8f%98%e6%8d%a2 aria-label=如何让View根据手势效果进行变换？>如何让View根据手势效果进行变换？</a><ul><li><a href=#view%e5%9f%ba%e7%a1%80%e5%b1%9e%e6%80%a7 aria-label=View基础属性>View基础属性</a></li><li><a href=#%e9%82%a3%e4%b9%88%e6%97%8b%e8%bd%ac%e5%b9%b3%e7%a7%bb%e7%bc%a9%e6%94%be%e7%a9%b6%e7%ab%9f%e6%94%b9%e5%8f%98%e7%9a%84%e6%98%af%e5%95%a5 aria-label=那么旋转/平移/缩放究竟改变的是啥？>那么旋转/平移/缩放究竟改变的是啥？</a></li><li><a href=#matrix%e8%a7%a3%e6%9e%90 aria-label=Matrix解析>Matrix解析</a><ul><li><a href=#post%e5%92%8cset%e5%8f%8apre%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=post和set及pre的区别>post和set及pre的区别</a><ul><li><a href=#scale aria-label=scale>scale</a></li></ul></li></ul></li><li><a href=#matrix%e5%a6%82%e4%bd%95%e4%b8%8eimageview%e7%bb%93%e5%90%88 aria-label=Matrix如何与ImageView结合>Matrix如何与ImageView结合</a></li></ul></li><li><a href=#%e5%8d%95%e4%b8%80%e6%95%88%e6%9e%9c%e5%ae%9e%e7%8e%b0 aria-label=单一效果实现>单一效果实现</a><ul><li><a href=#%e6%8b%96%e5%8a%a8%e6%95%88%e6%9e%9c%e5%ae%9e%e7%8e%b0 aria-label=拖动效果实现>拖动效果实现</a></li><li><a href=#fling-%e6%8a%95%e6%8e%b7%e6%95%88%e6%9e%9c%e5%ae%9e%e7%8e%b0 aria-label=Fling-投掷效果实现>Fling-投掷效果实现</a></li><li><a href=#scalegesturedetector-%e5%ae%9e%e7%8e%b0%e5%8f%8c%e6%8c%87%e7%bc%a9%e6%94%be%e6%95%88%e6%9e%9c aria-label="ScaleGestureDetector 实现双指缩放效果">ScaleGestureDetector 实现双指缩放效果</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0 aria-label=参考文章>参考文章</a><ul><li><a href=#matrix%e5%8f%82%e8%80%83 aria-label=matrix参考>matrix参考</a></li><li><a href=#android%e6%89%8b%e5%8a%bf aria-label=android手势>android手势</a></li></ul></li></ul></div></details></div><div class=post-content><p>android事件基础及手势，主要关注各种手势的使用及其计算原理 。</p><h2 id=android事件基础>Android事件基础<a hidden class=anchor aria-hidden=true href=#android事件基础>#</a></h2><p>这里我们主要关注概念</p><h3 id=事件监听器及事件处理程序>事件监听器及事件处理程序<a hidden class=anchor aria-hidden=true href=#事件监听器及事件处理程序>#</a></h3><p>可直接查看 <a href=https://developer.android.google.cn/guide/topics/ui/ui-events>官方文档</a>，此处仅做简要描述；</p><h4 id=事件监听器>事件监听器<a hidden class=anchor aria-hidden=true href=#事件监听器>#</a></h4><p>View类的包含一个回调方法的接口，通过setXXXListener来定义事件处理程序；</p><blockquote><p>事件监听器是 <code>View</code> 类中包含一个回调方法的接口。当用户与界面项目之间的互动触发已注册监听器的 View 对象时，Android 框架将调用这些方法。</p><p>事件监听器接口中包含以下回调方法：onClick()，onLongClick()，onFocusChange()，onKey()，onTouch()，onCreateContextMenu()</p></blockquote><p>我们重点关注onTouch：</p><blockquote><p>onTouch()： 在 <code>View.OnTouchListener</code> 中。当用户执行可视为触摸事件的操作时，包括按下、释放或屏幕上的任何移动手势（在项目边界内），系统会调用此方法。</p><p>此方法返回一个布尔值，指示监听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。因此，如果在收到 down 操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。因此，您无需执行事件内的任何其他操作，如手势或最终的 up 操作事件。</p></blockquote><h4 id=事件处理程序>事件处理程序<a hidden class=anchor aria-hidden=true href=#事件处理程序>#</a></h4><p>直接引用官方文档描述：</p><blockquote><p>如果您从 View 构建自定义组件，则可定义几种回调方法，用作默认事件处理程序。在有关<a href=https://developer.android.google.cn/guide/topics/ui/custom-components>自定义 View 组件</a>的文档中，您将了解一些用于事件处理的常见回调，包括：</p><ul><li><code>onKeyDown(int, KeyEvent)</code>：在发生新的按键事件时调用。</li><li><code>onKeyUp(int, KeyEvent)</code>：在发生 key up 事件时调用。</li><li><code>onTrackballEvent(MotionEvent)</code>：在发生轨迹球动作事件时调用。</li><li><code>onTouchEvent(MotionEvent)</code>：在发生触屏动作事件时调用。</li><li><code>onFocusChanged(boolean, int, Rect)</code>：在 View 对象获得或失去焦点时调用。</li></ul><p>还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。因此，在管理布局内更复杂的事件时，不妨考虑使用以下其他方法：</p><ul><li><code>Activity.dispatchTouchEvent(MotionEvent)</code>：此方法允许 <code>Activity</code> 在所有触摸事件分派给窗口之前截获它们。</li><li><code>ViewGroup.onInterceptTouchEvent(MotionEvent)</code>：此方法允许 <code>ViewGroup</code> 监视分派给子级 View 的事件。</li><li><code>ViewParent.requestDisallowInterceptTouchEvent(boolean)</code>：对父级 View 调用此方法，可指示不应使用 <code>onInterceptTouchEvent(MotionEvent)</code> 截获触摸事件。</li></ul></blockquote><p>这里我们重点关注 <code>onTouchEvent(MotionEvent)</code> 即在发生触屏动作事件时调用的回调方法；</p><h3 id=触摸手势>触摸手势<a hidden class=anchor aria-hidden=true href=#触摸手势>#</a></h3><p>手势可以让用户通过触摸来与屏幕元素进行交互；</p><p><strong>用户交户角度的手势划分</strong>：</p><table><thead><tr><th>手势类型</th><th>具体手势-不同类型之间有重复</th><th>解释</th></tr></thead><tbody><tr><td>导航手势</td><td></td><td>实现导航作用</td></tr><tr><td></td><td>点击 - Tap</td><td>如：点击按钮跳转到另外一个页面</td></tr><tr><td></td><td>滚动和拖移 - Scroll&amp;Pan</td><td>如：滑动图片列表或拖动以浏览地图<br><br>Scroll - 快速拖动并抬起手指时发生的一种滚动<br>Pan-拖移，慢速移动</td></tr><tr><td></td><td>拖动/拖拽 - Drag</td><td>用户在触摸屏上拖动手指时发生的一种滚动<br>如：按住底部sheet并向屏幕顶部拖动</td></tr><tr><td></td><td>轻扫 - Swipe</td><td>单个手指触摸屏幕并快速地朝任意一个方向滑动<br>如：左右滑动以在不同的Tab页中切换</td></tr><tr><td></td><td>捏合/缩放 - Pinch</td><td>双指或多指捏合<br>如：在一个图片列表中缩放一个item进入大图查看界面</td></tr><tr><td>动作手势</td><td></td><td>执行某种动作</td></tr><tr><td></td><td>点击 - Tap</td><td></td></tr><tr><td></td><td>长按 - Long press</td><td>如：长按选中</td></tr><tr><td></td><td>轻扫 - Swipe</td><td>如：轻扫item展现删除/收藏按钮</td></tr><tr><td>变换手势</td><td></td><td>用于改变元素大小，位置，旋转角度，实现变换效果</td></tr><tr><td></td><td>双击 - Double tap</td><td>如：双击缩放图片</td></tr><tr><td></td><td>捏合/缩放 - Pinch</td><td>如：缩放查看图片细节</td></tr><tr><td></td><td>组合手势</td><td>如：地图中的放大缩小&旋转</td></tr><tr><td></td><td>选取并拖动 - Pick up&amp;Move</td><td>长按选择元素 + 拖动元素</td></tr></tbody></table><blockquote><p><a href=https://material.io/design/interaction/gestures.html>来源</a>及手势的动画效果可以看这里： <a href=https://material.io/design/interaction/gestures.html#types-of-gestures>material.io</a></p></blockquote><p><strong>Android中用于检测或处理手势的类/方法：</strong></p><ul><li><a href=https://developer.android.google.cn/reference/android/view/GestureDetector>GestureDetector</a>：支持检测按下、滑动、长按等手势；事件回调方法包括 <code>onDown()</code>、<code>onLongPress()</code>、<code>onFling()</code>、[onScroll()](<a href=https://developer.android.google.cn/reference/android/view/GestureDetector.OnGestureListener#onScroll%28android.view.MotionEvent>https://developer.android.google.cn/reference/android/view/GestureDetector.OnGestureListener#onScroll(android.view.MotionEvent</a>, android.view.MotionEvent, float, float)) 等。可以将 <code>GestureDetector</code> 与 <code>onTouchEvent()</code> 方法结合使用；</li><li><a href=https://developer.android.google.cn/reference/android/view/ScaleGestureDetector>ScaleGestureDetector</a>：用于检测缩放手势；</li><li><a href=https://developer.android.google.cn/reference/android/view/View#onTouchEvent%28android.view.MotionEvent%29>onTouchEvent()</a>： 直接处理onTouchEvent()方法，然后自行根据事件序列来判断手势；</li><li><a href=https://developer.android.google.cn/reference/android/view/VelocityTracker>VelocityTracker</a>：用于跟踪触摸事件的速度，如滑动事件中一般需要结合速度来使用；</li><li><a href=https://developer.android.google.cn/reference/android/widget/Scroller>Scroller</a> & <a href=https://developer.android.google.cn/reference/android/widget/OverScroller>OverScroller</a>： 用于收集触摸事件来生成滚动动画所需的数据，OverScroller可以指示滑动后是否到达了内容边缘；</li></ul><blockquote><p><strong>两种不同的滚动: 拖动和滑动</strong></p><ul><li><strong>拖动</strong>是指用户在触摸屏上拖动手指时发生的一种滚动。简单的拖动通常是通过替换 <code>GestureDetector.OnGestureListener</code> 中的 <code>onScroll()</code> 实现的。有关拖动的详细讨论，可参阅<a href=https://developer.android.google.cn/training/gestures/scale>拖动和缩放</a>。</li><li><strong>滑动</strong>是用户快速拖动并抬起手指时发生的一种滚动。在用户抬起手指后，您通常需要继续滚动（移动视口），但要减速，直到视口停止移动为止。滑动可以通过替换 <code>GestureDetector.OnGestureListener</code> 中的 <code>onFling()</code> 以及使用滚动条对象来实现。</li><li>系统会在用户拖动手指以平移内容时调用 <code>onScroll()</code>，系统仅在手指还在屏幕上时才会调用 <code>onScroll()</code>；当手指从屏幕上抬起时，手势便会结束，或开始执行滑动手势（如果手指在抬起之前正在以一定的速度移动）。</li></ul></blockquote><p>接下来我们详细了解触摸手势中各个item的用法；</p><h2 id=触摸事件类逐个了解>触摸事件类逐个了解<a hidden class=anchor aria-hidden=true href=#触摸事件类逐个了解>#</a></h2><p>我们先对涉及的元素类进行单独学习，由于普通的事件监听器比较简单，所以主要关注触摸手势部分，这块先从GestureDetector开始；</p><h3 id=gesturedetector-详解>GestureDetector 详解<a hidden class=anchor aria-hidden=true href=#gesturedetector-详解>#</a></h3><p>能够识别的手势，是 <code>GestureDetector.OnGestureListener</code>及 ，<code>GestureDetector.SimpleOnGestureListener</code> ,其中 包括如下几种：</p><table><thead><tr><th>回调方法</th><th>对应事件触发时机及说明</th></tr></thead><tbody><tr><td><code>onDown(downEvent):Boolean</code></td><td>点按按下手指时 event为down事件时触发.</td></tr><tr><td><code>onFling(downEvent,upEvent,velocityX,velocityY):Boolean</code></td><td>滑动(投掷)事件发生时触发</td></tr><tr><td><code>onLongPress(downEvent)</code></td><td>发生长按事件时触发</td></tr><tr><td><code>onScroll(downEvent,moveEvent,distanceX,distanceY):Boolean</code></td><td>拖动事件发生时</td></tr><tr><td><code>onShowPress(downEvent)</code></td><td>按在屏幕上但是没有移动或抬起手指</td></tr><tr><td><code>onSingleTapUp(upEvent):Boolean</code></td><td>点按抬起手指时触发</td></tr><tr><td><code>GestureDetector.SimpleOnGestureListener</code></td><td></td></tr><tr><td><code>onContextClick(event)</code></td><td>上下文菜单点击事件发生时</td></tr><tr><td><code>onDoubleTap(event)</code></td><td>双击事件</td></tr><tr><td><code>onDoubleTapEvent(event)</code></td><td>双击事件过程中的事件，包括down，move，up事件</td></tr><tr><td><code>onSingleTapConfirmed(event)</code></td><td>单次点击发生时</td></tr></tbody></table><h4 id=问题><strong>问题：</strong><a hidden class=anchor aria-hidden=true href=#问题>#</a></h4><p>以下通过<strong>阅读API文档并编写简单的示例代码</strong>，通过<strong>操作触发对应的手势来观察</strong>以确定以下问题的答案。</p><ol><li>GestureDetector 各个事件发生的关系，有无交叉？<ul><li>按下-释放可能的事件序列：<ul><li>onDown - onSingleTapUp： 按下，迅速抬起（干净利落的）</li><li>onDown - onShowPress - onSingleTapUp：按下，缓慢抬起</li><li>onDown - onShowPress - onLongPress：按下，稍有延迟的抬起</li></ul></li><li>onScroll触发的可能事件序列：<ul><li>longPress 被触发之后，无法再触发onScroll</li><li>onDown - onScroll</li><li>onDown - onShowPress - onScroll</li></ul></li><li>onFling的触发序列<ul><li>触发onScroll - 多个 onScroll - onFling</li></ul></li></ul></li><li>GestureDetector.SimpleOnGestureDetector<ul><li>单次点击事件序列：<ul><li>onDown - onSingleTapUp - onSingleTapConfirmed</li><li>onDown - onShowPress - onSingleTapUp - onSingleTapConfirmed （按下后稍有停顿）</li></ul></li><li>双击可能的事件序列：<ul><li>onDown - onShowPress - onSingleTapUp - onDoubleTap_down - onDoubleTapEvent_down - <strong>onDown</strong> - onShowPress - onDoubleTapEvent_up</li></ul></li></ul></li><li>滑动onFling和拖动onScroll的区别时机？<ul><li>onScroll一定先发生，如果抬起时有一定速度，就会触发onFling</li></ul></li><li><code>onSingleTapUp(upEvent)</code> 及 <code>onSingleTapConfirmed(event)</code>的区别？<ul><li>onSingleTapConfirmed 只会在确认当前tap之后不会有另外一次tap构成double-tap手势的情况下才会被触发，也就是说onSingleTapUp实际上有可能时doubleTap的一次事件，如果确定只能又明确的单次点击事件触发，就需要区分</li></ul></li><li>onDoubleTab 和 onDoubleTapEvent 之前的区别？<ul><li>onDoubleTab 只包含down事件，而onDoubleTapEvent则还包含其他事件（move，up）</li></ul></li></ol><h4 id=scroller-详解>Scroller 详解<a hidden class=anchor aria-hidden=true href=#scroller-详解>#</a></h4><p>scroller 本身并不与View关联，仅用于做辅助的动画计算，使用起来有以下步骤：</p><ol><li>初始化</li><li>通过<code>startScroll</code>或<code>fling</code>方法设定计算模型及计算所需要的参数</li><li>定期调用 <code>computeScrollOffset</code> 进行运算，然后取出运算后的值</li><li>使用运算后的值动态的改变View的属性实现滚动效果</li></ol><h5 id=计算模型>计算模型：<a hidden class=anchor aria-hidden=true href=#计算模型>#</a></h5><table><thead><tr><th>模型/方法</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><strong>startScroll</strong></td><td>startX</td><td>起始水平滚动偏移量（以像素为单位），正数会将内容向左滚动。</td></tr><tr><td></td><td>startY</td><td>开始的垂直滚动偏移量（以像素为单位）。 正数将使内容向上滚动。</td></tr><tr><td></td><td>dx</td><td>滑动的水平距离。 正数会将内容向左滚动。</td></tr><tr><td></td><td>dy</td><td>垂直滑动距离。 正数将使内容向上滚动。</td></tr><tr><td></td><td>duration</td><td>滚动持续时间（以毫秒为单位）</td></tr><tr><td><strong>fling</strong></td><td>startX</td><td>滚动的起点（X）</td></tr><tr><td></td><td>startY</td><td>滚动的起点（Y）</td></tr><tr><td></td><td>velocityX</td><td>滚动的初始速度（X方向），以像素/秒为单位。</td></tr><tr><td></td><td>velocityY</td><td>滚动的初始速度（Y方向），以像素/秒为单位。</td></tr><tr><td></td><td>minX</td><td>最小X值。 滚动条将不会滚动到该点。</td></tr><tr><td></td><td>maxX</td><td>最大X值。 滚动条将不会滚动到该点。</td></tr><tr><td></td><td>minY</td><td>最小Y值。 滚动条将不会滚动到该点。</td></tr><tr><td></td><td>maxY</td><td>最大Y值。 滚动条将不会滚动到该点。</td></tr></tbody></table><h5 id=计算结果值>计算结果值<a hidden class=anchor aria-hidden=true href=#计算结果值>#</a></h5><table><thead><tr><th>方法/值</th><th>说明</th></tr></thead><tbody><tr><td>getCurrX</td><td>新的X偏移量是距原点的绝对距离。</td></tr><tr><td>getCurrY</td><td>新的Y偏移量是距原点的绝对距离。</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id=scalegesturedetector-详解><code>ScaleGestureDetector</code> 详解<a hidden class=anchor aria-hidden=true href=#scalegesturedetector-详解>#</a></h3><p>使用提供的 MotionEvent 事件序列来检测缩放手势，当检测到对应的缩放事件时，会通过 OnScaleGestureListener 来通知用户；</p><p>使用流程：</p><ul><li>为 View 创建 ScaleGestureDetector 实例；</li><li>在 View.onTouchEvent(MotionEvent) 方法中调用 ScaleGestureDetector 实例的 onTouchEvent 方法；</li></ul><h4 id=基本用法>基本用法<a hidden class=anchor aria-hidden=true href=#基本用法>#</a></h4><ul><li><h5 id=构造函数><strong>构造函数</strong><a hidden class=anchor aria-hidden=true href=#构造函数>#</a></h5></li></ul><table><thead><tr><th>仓库</th><th>含义/作用</th></tr></thead><tbody><tr><td>context</td><td>上下文</td></tr><tr><td>ScaleGestureListener</td><td>缩放监听</td></tr><tr><td>Handler（可选）</td><td>用于运行延迟侦听事件的处理程序</td></tr></tbody></table><ul><li><h5 id=方法及属性><strong>方法及属性</strong><a hidden class=anchor aria-hidden=true href=#方法及属性>#</a></h5></li></ul><table><thead><tr><th>属性/方法</th><th>含义说明</th><th>备注</th></tr></thead><tbody><tr><td>getCurrent<strong>Span</strong></td><td>两个手指之间的通过手势焦点的平均距离</td><td>（何为平均距离？）</td></tr><tr><td>getCurrent<strong>Span</strong>X</td><td>形成手势的过程中两个手指之间通过手势焦点的X方向的平均距离</td><td>两个手指的滑动X距离相加取平均</td></tr><tr><td>getCurrent<strong>Span</strong>Y</td><td>形成手势的过程中两个手指之间通过手势焦点的Y方向的平均距离</td><td>两个手指的滑动Y距离相加取平均</td></tr><tr><td>getEventTime</td><td>返回正在处理的当前事件的事件时间</td><td></td></tr><tr><td>get<strong>Focus</strong>X</td><td>当前手势焦点（gesture&rsquo;s focal point）的X坐标</td><td>手势焦点=两个手势点的中点；双击触发时则是触摸点</td></tr><tr><td>get<strong>Focus</strong>Y</td><td>当前手势焦点（gesture&rsquo;s focal point）的Y坐标</td><td>两个手势点的中点</td></tr><tr><td>getPrevious<strong>Span</strong></td><td>之前的 两个手指之间的通过<strong>手势焦点</strong>的平均距离</td><td>上次回调（scaleBegin/scale）的span参数</td></tr><tr><td>getPrevious<strong>Span</strong>X</td><td>之前的 形成手势的过程中两个手指之间通过手势焦点的X方向的平均距离</td><td></td></tr><tr><td>getPrevious<strong>Span</strong>Y</td><td>之前的 形成手势的过程中两个手指之间通过手势焦点的Y方向的平均距离</td><td></td></tr><tr><td>getScaleFactor</td><td>从之前的缩放事件到当前缩放事件的 缩放比例</td><td>两次回调之间的缩放比例</td></tr><tr><td>getTimeDelta</td><td>上一个被接受的缩放事件到当前缩放事件之前的时间差</td><td>两次回调之间的</td></tr><tr><td>isInProgress</td><td>缩放手势是否正在进行中</td><td>ScaleBegin 中为false，另外两个为true</td></tr><tr><td>isQuickScaleEnabled</td><td>是否启用了快速缩放-用户通过双击+一个Swipe操作来触发缩放</td><td></td></tr><tr><td>isStylusScaleEnabled</td><td>返回用户使用触笔并按下按钮的触笔缩放手势是否应该执行缩放。</td><td></td></tr><tr><td>setQuickScaleEnabled</td><td>当用户执行双击+Swipe动作时是否触发缩放监听</td><td></td></tr><tr><td>setStylusScaleEnabled</td><td>当用户执行触笔缩放动作时是否触发缩放监听</td><td></td></tr><tr><td>onTouchEvent</td><td>接受MotionEvents并在适当的时机分发事件到 OnScaleGestureListener</td><td></td></tr></tbody></table><ul><li><p><strong>如何使用？</strong></p><ol><li>构造侦听器对象；</li><li>在 onTouchEvent 回调中调用侦听器对象的 onTouchEvent方法并传入MotionEvent；</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>var</span> mScaleGestureDetector = ScaleGestureDetector(<span style=color:#66d9ef>this</span>,<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onTouchEvent</span>(event: MotionEvent?): Boolean {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mScaleGestureDetector.onTouchEvent(event) <span style=color:#f92672>||</span> <span style=color:#66d9ef>super</span>.onTouchEvent(event)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h4 id=深入探究>深入探究<a hidden class=anchor aria-hidden=true href=#深入探究>#</a></h4><ol><li>如何触发手势？<ul><li>两个手指张开闭合就可以</li></ul></li><li>如何消费手势？</li><li>如何利用手势的参数实现缩放的动画/动作？</li></ol><h5 id=如何消费手势>如何消费手势？<a hidden class=anchor aria-hidden=true href=#如何消费手势>#</a></h5><table><thead><tr><th><strong>事件类型</strong></th><th><strong>CurrentSpan</strong></th><th><strong>currentSpanX</strong></th><th><strong>currentSpanY</strong></th><th><strong>EventTime</strong></th><th><strong>FocusX</strong></th><th><strong>FocusY</strong></th><th><strong>Previouspan</strong></th><th><strong>PreviouspanX</strong></th><th><strong>PreviouspanY</strong></th><th><strong>ScaleFactor</strong></th><th><strong>TimeDelta</strong></th><th><strong>isInProgress</strong></th><th><strong>isQuickScaleEnabled</strong></th><th><strong>isStylusScaleEnabled</strong></th></tr></thead><tbody><tr><td><strong>onScaleBegin</strong></td><td>448.18158</td><td>338.30157</td><td>293.9707</td><td>120680064</td><td>405.82724</td><td>765.9927</td><td>448.18158</td><td>338.30157</td><td>293.9707</td><td>1.0</td><td>0</td><td>FALSE</td><td>TRUE</td><td>TRUE</td></tr><tr><td><strong>onScale</strong></td><td>448.18158</td><td>338.30157</td><td>293.9707</td><td>120680064</td><td>405.82724</td><td>765.9927</td><td>448.18158</td><td>338.30157</td><td>293.9707</td><td>1.0</td><td>0</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>473.83823</td><td>355.72217</td><td>313.0246</td><td>120680081</td><td>408.95367</td><td>770.60486</td><td>448.18158</td><td>338.30157</td><td>293.9707</td><td>1.0572461</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>492.1729</td><td>367.65485</td><td>327.20648</td><td>120680098</td><td>410.2758</td><td>772.77576</td><td>473.83823</td><td>355.72217</td><td>313.0246</td><td>1.038694</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>509.8993</td><td>380.36285</td><td>339.59003</td><td>120680114</td><td>411.72714</td><td>775.3407</td><td>492.1729</td><td>367.65485</td><td>327.20648</td><td>1.0360166</td><td>16</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>526.8072</td><td>391.90063</td><td>352.05072</td><td>120680131</td><td>413.6501</td><td>777.7251</td><td>509.8993</td><td>380.36285</td><td>339.59003</td><td>1.0331593</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>541.9916</td><td>402.3568</td><td>363.13068</td><td>120680147</td><td>415.72614</td><td>780.33923</td><td>526.8072</td><td>391.90063</td><td>352.05072</td><td>1.0288234</td><td>16</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>552.3365</td><td>408.6225</td><td>371.62244</td><td>120680164</td><td>418.1556</td><td>782.6556</td><td>541.9916</td><td>402.3568</td><td>363.13068</td><td>1.0190868</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>560.9881</td><td>413.25342</td><td>379.38013</td><td>120680181</td><td>418.5</td><td>783.56335</td><td>552.3365</td><td>408.6225</td><td>371.62244</td><td>1.0156636</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>567.2112</td><td>417.16174</td><td>384.32355</td><td>120680197</td><td>419.58087</td><td>785.08093</td><td>560.9881</td><td>413.25342</td><td>379.38013</td><td>1.011093</td><td>16</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>575.6995</td><td>423.24652</td><td>390.24646</td><td>120680214</td><td>420.5411</td><td>786.0411</td><td>567.2112</td><td>417.16174</td><td>384.32355</td><td>1.014965</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>584.7019</td><td>428.15033</td><td>398.2005</td><td>120680230</td><td>422.02505</td><td>788.0502</td><td>575.6995</td><td>423.24652</td><td>390.24646</td><td>1.0156373</td><td>16</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>592.25555</td><td>432.04736</td><td>405.09473</td><td>120680247</td><td>423.02368</td><td>789.5237</td><td>584.7019</td><td>428.15033</td><td>398.2005</td><td>1.0129188</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>601.86597</td><td>436.95844</td><td>413.89606</td><td>120680263</td><td>424.47922</td><td>791.9689</td><td>592.25555</td><td>432.04736</td><td>405.09473</td><td>1.0162268</td><td>16</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>611.9895</td><td>442.71814</td><td>422.5302</td><td>120680280</td><td>425.453</td><td>793.453</td><td>601.86597</td><td>436.95844</td><td>413.89606</td><td>1.0168202</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>621.78754</td><td>447.69666</td><td>431.49445</td><td>120680297</td><td>426.94946</td><td>794.94946</td><td>611.9895</td><td>442.71814</td><td>422.5302</td><td>1.0160102</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>629.77124</td><td>451.88318</td><td>438.64954</td><td>120680313</td><td>427.9416</td><td>795.4416</td><td>621.78754</td><td>447.69666</td><td>431.49445</td><td>1.0128399</td><td>16</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScale</strong></td><td>636.78015</td><td>454.8739</td><td>445.6217</td><td>120680330</td><td>428.43695</td><td>795.93695</td><td>629.77124</td><td>451.88318</td><td>438.64954</td><td>1.0111293</td><td>17</td><td>TRUE</td><td>TRUE</td><td>true</td></tr><tr><td><strong>onScaleEnd</strong></td><td>644.16754</td><td>458.65613</td><td>452.31226</td><td>120680346</td><td>428.5</td><td>795.5</td><td>636.78015</td><td>454.8739</td><td>445.6217</td><td>1.0</td><td>16</td><td>TRUE</td><td>TRUE</td><td>true</td></tr></tbody></table><p>以下是测试过程中的detector的属性变化数据，可以发现如下规律：</p><ol><li><p><strong>onScaleBegin</strong> 时 inProgress为false</p></li><li><p>currentSpan<sup>^2</sup> = currentSpanX<sup>^2</sup> * currentSpanY<sup>^2</sup> ，即currentSpan为两个手指总共移动的距离，如下图所示：</p></li></ol><ul><li>手指1移动的轨迹为蓝色矩形中的对角线，手指2移动的轨迹为红色矩形的对角线</li></ul><img src=https://gitee.com/hanlyjiang/image-repo/raw/master/imgs/20210224223801.png alt=image-20210224223801886 style=zoom:50%><ul><li>currentSpan 就是两个手指移动的对角线相加，currentSpanX和currentSpanY分别为蓝色矩形和红色矩形按如下方式拼接成一个大的矩形之后的两条边；</li></ul><img src=https://gitee.com/hanlyjiang/image-repo/raw/master/imgs/20210224223831.png alt=image-20210224223831274 style=zoom:50%><ol start=3><li>每次事件的previouSpan的值都等于上次事件的currentSpan的值；</li><li>FocusX和FocusY即为事件回调触发时两个手指连线的中点坐标，随着手指的不断移动，焦点也是不断的变化的；</li><li>大部分timeDelta都在16-17ms左右，所以不应在回调方法中执行耗时事件，对应逻辑应放置到Runnable中去执行；</li><li>scaleBegin和第一次onScale回调的各项值都一致，除了scaleBegin的isInProgress为<code>FALSE</code>；</li><li>缩放比例（scaleFactor）为1.0时，没有缩放；</li></ol><h5 id=如何利用手势的参数实现缩放的动画动作>如何利用手势的参数实现缩放的动画/动作？<a hidden class=anchor aria-hidden=true href=#如何利用手势的参数实现缩放的动画动作>#</a></h5><p>假设我现在需要在检测到缩放手势时同步的对ImageView执行缩放动作，此时应该怎么做？</p><ul><li>如何对ImageView的图片进行缩放？<ul><li>根据缩放比例不断的重新设置View的scaleX及scaleY的值；</li></ul></li><li>每次事件触发都进行缩放操作？还是积累一定程度之后进行？<ul><li>由于每次变化的时间非常短，所以我们应该在每次onScale方法触发时执行变换；</li></ul></li></ul><h2 id=如何让view根据手势效果进行变换>如何让View根据手势效果进行变换？<a hidden class=anchor aria-hidden=true href=#如何让view根据手势效果进行变换>#</a></h2><p>通过之前对手势侦听器，缩放手势侦听器及滚动条类的学习及分析，我们知道了各个类的基本用途：</p><ul><li>GeostureDetector： 辅助侦听判断down，tag，doubletap，scroll，fling等手势并在检测到手势后回调对应的方法，给出事件相关的参数数据；</li><li>ScaleGeostureDetector： 辅助侦听判断缩放手势，并在缩放手势发生时通过回调对应方法来通知我们对应事件的发生，并给出事件相关的参数数据；</li><li>Scroller： 用于辅助计算生成滚动过程中的一系列值的序列；</li></ul><p>可以方向，上述类只是告诉你事件发生了，还有告诉你事件的相关参数，如滚动事件的滚动距离，fling事件的滑动速度，等等，但是都没有涉及到如何变换将这些事件反映到界面的变化上，那么我们如何将上述的事件变化反映到界面上呢？</p><h3 id=view基础属性>View基础属性<a hidden class=anchor aria-hidden=true href=#view基础属性>#</a></h3><p>部分变化效果都是针对View/ViewGroup来说的，要想改变View，就得改变其属性，如：</p><ul><li>滑动时改变TransitionX，TransitionY</li><li>缩放时改变View的scaleX/scaleY</li></ul><p>我们需要研究View中有哪些属性，属性如何影响View的展示效果，以下通过API文档的setXXX属性列出View的部分属性：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>alpha</strong></td><td>透明度</td></tr><tr><td>background/backgroundColor</td><td>背景</td></tr><tr><td><strong>bottom<br>left<br>right<br>top</strong><br><strong>elevation</strong></td><td>视图相对于parent的位置<br>elevation为view的深度</td></tr><tr><td>clipBounds</td><td>矩形裁剪区域，view的内容会在该区域绘制</td></tr><tr><td>clipToOutline:Boolean</td><td></td></tr><tr><td>fadingEdgeLength</td><td>用于指示此视图中更多内容可用的褪色边缘的大小</td></tr><tr><td>foreground</td><td>前景drawable</td></tr><tr><td>layoutParams</td><td>布局参数</td></tr><tr><td>minHeight<br>minWidth</td><td>最小宽高</td></tr><tr><td>padding</td><td>内边距</td></tr><tr><td>relativePadding</td><td>减去可能的滚动条尺寸</td></tr><tr><td><strong>pivotX<br>pivotY</strong></td><td>view 旋转缩放所围绕的点。默认为view中点坐标</td></tr><tr><td><strong>rotation</strong></td><td>绕pivot点的旋转角度</td></tr><tr><td><strong>rotationX<br>rotationY</strong></td><td>绕通过pivot点的水平线/垂直线的旋转角度</td></tr><tr><td><strong>scaleX<br>scaleY</strong></td><td>X/Y方向上绕pivot点的缩放比例，1.0表示无缩放</td></tr><tr><td><strong>scrollX<br>scrollY</strong></td><td>水平/垂直滚动位置的position</td></tr><tr><td><strong>translationX<br>translationY<br>translationZ</strong></td><td>相对于视图左边位置的水平/垂直/深度位置，可以改变布局</td></tr><tr><td><strong>x/y/z</strong></td><td>x: x位置； 等效translationX=x-left<br>y: y位置； 等效translationY=y-top<br>z: z位置； 等效translationZ=z-elevation</td></tr></tbody></table><p>与视图变化相关的最基本的就是加粗部分的属性，总结起来就是位置，大小，透明度，旋转，缩放，平移。其他具体的子View则可能引入自己的属性；</p><h3 id=那么旋转平移缩放究竟改变的是啥>那么旋转/平移/缩放究竟改变的是啥？<a hidden class=anchor aria-hidden=true href=#那么旋转平移缩放究竟改变的是啥>#</a></h3><ul><li>滚动及平移（scroll/fling）：改变x和y（亦可以通过translationX/Y，最终都是改变了x和y）</li><li>缩放： 改变scaleX/scaleY/pivotX/pivotY</li></ul><h3 id=matrix解析>Matrix解析<a hidden class=anchor aria-hidden=true href=#matrix解析>#</a></h3><p>用途： matrix存储一个3x3的矩阵，用于对坐标进行变换；
$$
\begin{bmatrix}
MSCALE_X & MSKEW_X & MTRANS_X \
MSKEW_Y & MSCALE_Y & MTRANS_Y \
MPERSP_0 & MPERSP_1 & MPERSP_2 \
\end{bmatrix}
$$
矩阵各个元素的用途：</p><table><thead><tr><th>字段</th><th>用途</th></tr></thead><tbody><tr><td><code>MSCALE_X</code>，<code>MSCALE_Y</code></td><td>控制X轴和Y轴方向的缩放</td></tr><tr><td><code>MSKEW_X</code>，<code>MSKEW_Y</code></td><td>控制X坐标和Y坐标的扭曲系数(旋转)</td></tr><tr><td><code>MTRANS_X</code>，<code>MTRANS_Y</code></td><td>控制X方向和Y方向的线性平移</td></tr><tr><td><code>MPERSP_0</code> , <code>MPERSP_1</code> , <code>MPERSP_2</code></td><td>MPERSP_0、MPERSP_1和MPERSP_2是关于透视的控制</td></tr></tbody></table><p>Matrix提供一系列的辅助变换函数，每种类型有 <code>pre</code>,<code>post</code>,<code>set</code>三种操作方式，矩阵的乘法运算顺序不一致结果不同，pre表示前（preconcats），post表示后（postconcats），set为直接设置；</p><p><code>postScale</code>方法来对坐标后接触缩放变换，有两种变体：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>postScale (float sx, float sy, float px, float py)</code></td><td>使用指定的scale执行矩阵postconcats：<code>M' = S(sx, sy, px, py) * M</code><br>其中sx，sy分别为x轴和y轴的缩放大小，px，py为缩放中心点的坐标</td></tr><tr><td><code>boolean postScale (float sx, float sy)</code></td><td>使用指定的scale执行矩阵postconcats： <code>M' = S(sx, sy) * M</code></td></tr></tbody></table><h4 id=post和set及pre的区别>post和set及pre的区别<a hidden class=anchor aria-hidden=true href=#post和set及pre的区别>#</a></h4><h5 id=scale>scale<a hidden class=anchor aria-hidden=true href=#scale>#</a></h5><table><thead><tr><th></th><th>currentScale</th></tr></thead><tbody><tr><td>preScale</td><td>和postScale对值产生一样的效果，但是如果有其他变换一起使用，他会先于set被应用</td></tr><tr><td>setScale</td><td>直接覆盖，如果matrix中原先有scale的值，那么原先的值会被覆盖</td></tr><tr><td>postScale</td><td>只需要设置增量即可，如原先的scale为0.5425669，postScale(1.3947428)后scale的值为 $$0.5425669*1.3947428 = 0.7567413$$</td></tr></tbody></table><h3 id=matrix如何与imageview结合>Matrix如何与ImageView结合<a hidden class=anchor aria-hidden=true href=#matrix如何与imageview结合>#</a></h3><p>那么我们如何才能将Matrix同ImageView或者Canvas或者Bitmap结合起来呢？</p><p>查找Canvas的相关方法，可以看到setMatrix方法，</p><blockquote><pre tabindex=0><code>public void setMatrix (Matrix matrix)
</code></pre><p>Completely replace the current matrix with the specified matrix. If the matrix parameter is null, then the current matrix is reset to identity. <strong>Note:</strong> it is recommended to use <code>concat(android.graphics.Matrix)</code>, <code>scale(float, float)</code>, <code>translate(float, float)</code> and <code>rotate(float)</code> instead of this method.</p></blockquote><p>同时下面温馨提示，让我们使用其他方法，其中涉及到矩阵的就有contact，所以我们研究下contact方法：</p><p>contact方法接受一个Matrix对象，可以将参数中的矩阵预连接到canvas本身的矩阵上（Preconcat the current matrix with the specified matrix.）；假设当前矩阵为C，要连接的矩阵为S，这里的预连接（preconcat）指的是：<code>C = S x C</code></p><h2 id=单一效果实现>单一效果实现<a hidden class=anchor aria-hidden=true href=#单一效果实现>#</a></h2><h3 id=拖动效果实现>拖动效果实现<a hidden class=anchor aria-hidden=true href=#拖动效果实现>#</a></h3><ol><li><p>初始化<code>GestureDetector</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> mDetector: GestureDetector
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.onCreate(savedInstanceState)
</span></span><span style=display:flex><span>        mDetector = GestureDetector(<span style=color:#66d9ef>this</span>, simpleDetectorListener)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>使用 <code>GestureDetector</code> 侦听 <code>onScroll</code> 手势</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>dispatchTouchEvent</span>(ev: MotionEvent?): Boolean {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> mDetector.onTouchEvent(ev)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>GestureDetector</code> 的 <code>onScroll</code> 回调方法中处理滚动事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onScroll</span>(e1: MotionEvent?, e2: MotionEvent?, distanceX: Float, distanceY: Float): Boolean {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 改变ImageView 的x和y
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    imageView.x <span style=color:#f92672>-=</span> distanceX
</span></span><span style=display:flex><span>    imageView.y <span style=color:#f92672>-=</span> distanceY
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h3 id=fling-投掷效果实现>Fling-投掷效果实现<a hidden class=anchor aria-hidden=true href=#fling-投掷效果实现>#</a></h3><ol><li><p>初始化<code>GestureDetector</code>及 <code>Scroller</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> mDetector: GestureDetector
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> mScroller: Scroller
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.onCreate(savedInstanceState)
</span></span><span style=display:flex><span>        mDetector = GestureDetector(<span style=color:#66d9ef>this</span>, simpleDetectorListener)
</span></span><span style=display:flex><span>    	mScroller = Scroller(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>在onTouchEvent或dispatchTouchEvent中使用<code>GestureDetector</code> 侦听 <code>onFling</code> 手势</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>dispatchTouchEvent</span>(ev: MotionEvent?): Boolean {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mDetector.onTouchEvent(ev)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>onFling回调中使用<code>Scroller </code>完成滚动辅助计算并从Scroller中获取参数来更新视图的x,y相关属性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onFling</span>(e1: MotionEvent?, e2: MotionEvent?, velocityX: Float, velocityY: Float): Boolean {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> handleFling(e1, e2, velocityX, velocityY)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>handleFling</span>(down: MotionEvent?, move: MotionEvent?, velocityX: Float, velocityY: Float): Boolean {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 停止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mScroller.forceFinished(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> minX: Int = (imageView.pivotX * (<span style=color:#ae81ff>1</span> - imageView.scaleX)).roundToInt()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> minY: Int = (imageView.pivotY * (<span style=color:#ae81ff>1</span> - imageView.scaleY)).roundToInt()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> maxX: Int = ((imageView.width - imageView.pivotX) * (imageView.scaleX - <span style=color:#ae81ff>1</span>)).roundToInt()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> maxY: Int = ((imageView.height - imageView.pivotY) * (imageView.scaleY - <span style=color:#ae81ff>1</span>)).roundToInt()
</span></span><span style=display:flex><span>        mScroller.fling(imageView.x.toInt(), imageView.y.toInt(), velocityX.toInt(), velocityY.toInt(),
</span></span><span style=display:flex><span>                minX, maxX, minY, maxY)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Invalidate to request a redraw
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        isFling = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        postFling()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>postFling</span>() {
</span></span><span style=display:flex><span>    imageView.postDelayed(flingRunnable, <span style=color:#ae81ff>16L</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> flingRunnable = Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!mScroller.isFinished ) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 计算滚动后的参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            mScroller.computeScrollOffset()
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从滚动器中获取计算出的值并更新图片的x,y属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            imageView.x = mScroller.currX.toFloat()
</span></span><span style=display:flex><span>            imageView.y = mScroller.currY.toFloat()
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 定期刷新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            postFling()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><p><strong>View缩放后fling边界计算</strong></p><p><img alt=image-20210228180521446 loading=lazy src=https://gitee.com/hanlyjiang/image-repo/raw/master/imgs/20210228180522.png></p><p><strong>说明：</strong></p><ol><li><p>缩放前宽：width</p></li><li><p>缩放前高：height</p></li><li><p>缩放比例：scale</p></li><li><p>缩放焦点坐标：focusX，focusY</p></li><li><p>minX = - focusX * （scale-1）</p></li><li><p>minY = - focusY * （scale-1）</p></li><li><p>maxX = （width-focusX）*（scale-1）</p></li><li><p>maxY = （height-focusY）*（scale-1）</p></li></ol><h3 id=scalegesturedetector-实现双指缩放效果>ScaleGestureDetector 实现双指缩放效果<a hidden class=anchor aria-hidden=true href=#scalegesturedetector-实现双指缩放效果>#</a></h3><ol><li><p>初始化 <code>ScaleGestureDetector</code> ；</p><pre tabindex=0><code>    private lateinit var mScaleDetector: ScaleGestureDetector
    private val scaleDetectorListener: ScaleGestureDetector.OnScaleGestureListener = object : ScaleGestureDetector.OnScaleGestureListener {

        override fun onScaleBegin(detector: ScaleGestureDetector?): Boolean {
            isScaling = true
            scaleStartX = detector!!.focusX
            scaleStartY = detector.focusY
            return true
        }

        override fun onScale(detector: ScaleGestureDetector?): Boolean {
            Timber.tag(&#34;GestureDetector&#34;).d(&#34;handleScale onScale&#34;)
            detector?.run {
                handleScale(detector)
            }
            return true
        }


        override fun onScaleEnd(detector: ScaleGestureDetector?) {
            Timber.tag(&#34;GestureDetector&#34;).d(&#34;handleScale onScaleEnd&#34;)
            isScaling = false
        }
    }
</code></pre></li><li><p>事件分发时调用 <code>ScaleGestureDetector</code> 的 onTouchEvent 方法传递事件序列；</p></li><li><p>在scale事件回调方法中处理scale事件-根据事件参数更新View的缩放（scaleX，scaleY）属性完成视图更新；</p></li></ol><h2 id=参考文章>参考文章<a hidden class=anchor aria-hidden=true href=#参考文章>#</a></h2><h3 id=matrix参考>matrix参考<a hidden class=anchor aria-hidden=true href=#matrix参考>#</a></h3><ul><li><a href=https://blog.csdn.net/maxchenfuhai/article/details/51690857>Android matrix.postScale的用法</a></li><li><a href=https://www.jianshu.com/p/a08e589ce5d4>Android Matrix</a></li><li><a href=https://www.cnblogs.com/li-print/p/3318805.html>Matrix学习1、基础的知识</a></li><li><a href=https://blog.csdn.net/u010945683/article/details/46757757>MathJax基本的使用方式</a></li><li><a href=https://support.typora.io/Markdown-Reference/#math-blocks>Typora Math Block</a></li><li><a href=https://stackoverflow.com/questions/2695537/what-does-it-mean-to-preconcat-a-matrix-in-android>What does it mean to “preconcat” a matrix in Android?</a></li><li><a href=https://www.jianshu.com/p/7ca1d675a7c8>Android Matrix的pre、post理解</a></li></ul><h3 id=android手势>android手势<a hidden class=anchor aria-hidden=true href=#android手势>#</a></h3><ul><li><a href=https://material.io/design/interaction/gestures.html#types-of-gestures>手势类型- Material.io</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://hanlyjiang.github.io/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=https://hanlyjiang.github.io/posts/hello-gridea/><span class=title>«</span><br><span>Hello Gridea</span>
</a><a class=next href=https://hanlyjiang.github.io/posts/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/><span class=title>»</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hanlyjiang.github.io/>清水池塘</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>