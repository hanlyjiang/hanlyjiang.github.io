<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gitlab持续集成与持续部署-实例 | 清水池塘</title><meta name=keywords content="Gitlab,CICD"><meta name=description content='本篇文章介绍如何基于Gitlab来配置一个服务集群的自动构建与部署更新，其中服务的更新基于docker来完成，本文主要关注如何完成部署操作，及如何完成gitlab上ci的配置；在完成单一的服务自动部署更新后，我们通过gitlab的include及trigger机制来简化统一部署流程；
前言
我们需要实现服务的自动构建后的自动更新部署，注意这里我们只需要能做到更新部署的服务即可，服务的初次部署属于低频操作，且和服务器环境相关，需要手动来完成；我们这里假定机器上已经部署好了服务；
单一项目的自动部署的示例
这里我们首先以一个springboot的服务作为示例，实现了整个自动打包及部署更新的流程；
效果


提交之后，自动构建jar，并打包docker镜像



构建完成后，通过gitlab界面，可以触发部署，完成后可以访问对应的环境（详见下方说明）


触发部署步骤的方式
触发部署有多个入口：


流水线列表尾部的手动作业按钮



流水线列表中，点击对应的手动任务，在弹出框中点击运行



流水线详情中，点击触发部署



对应手动作业的详情中，点击“触发此手动操作”



作业列表中对应的部署作业的尾部



访问部署环境的方式
部署之后，会在gitlab中生成一个环境，在环境的相关界面即可访问对应的服务地址

在项目的“运维-环境”入口可以查看所有的环境




点击对应环境尾部的链接图标即可访问



也可以在对应的环境详情页面，点击“查看部署” （注意在部署作业的详情中也可以找到对应环境的入口哦-触发部署步骤的方式的第四中方式的附图）



实现方式
我们有三个任务：

构建jar
构建docker镜像
部署服务（通过swarm）

其中构建jar和构建docker镜像是自动完成的，部署步骤则需要手动通过gitlab界面进行触发；
gitlab-ci.yml 配置
variables:
  #  配置仓库环境
  DOCKER_REGISTRY: zh-registry.colorless.com.cn
  DOCKER_NAMESPACE: colorless
  DEPLOY_PATH: /Wksp/colorlessWork/colorless-deploy/deploy/
  #  配置镜像服务名
  SERVICE_NAME: graphql-token

stages:
  - test
  - build
  - build_image
  - deploy

# 引入代码检查任务
#include:
#  local: ci/gitlab-ci-sonar.yml

build:jar:
  # 部分模块若不使用1.8编译会报错
  image: maven:3.6.3-jdk-8
  stage: build
  script:
    - mvn package
    - mkdir _archiver
    - cp target/*.jar _archiver/
    - ls -lh _archiver/
  artifacts:
    name: "dist-$CI_PROJECT_NAME-$CI_COMMIT_SHORT_SHA"
    paths:
      - _archiver/*.jar
    # 生成的归档包比较大，我们只保留短时间
    expire_in: 1 hours
  tags:
    - common-build
  only:
    - master
    - web

build:docker:
  stage: build_image
  script:
    # 登录公司的Harbor，注意必须在环境变量配置 HARBOR_PWD
    - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin
    # 定义镜像TAG
    - IMAGE_NAME=$DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA
    - echo "Docker build options $DOCKER_OPTIONS, set DOCKER_OPTIONS to --no-cache force rebuild all stage"
    - cp _archiver/*.jar docker/
    # build镜像
    - JAR_FILE=`ls docker/ | grep -E *.jar`
    - echo $JAR_FILE
    - docker build $DOCKER_OPTIONS --build-arg JAR_FILE=$JAR_FILE -t $IMAGE_NAME ./docker/
    # 推送镜像
    - docker push $IMAGE_NAME
    - echo "镜像构建完成：$IMAGE_NAME"
  tags:
    - docker
  only:
    - master
    - web

deploy:
  stage: deploy
  script:
    - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin
    - cd $DEPLOY_PATH
    - source deploy.sh
    - update_service $DOCKER_NAMESPACE $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA
  environment:
    name: test_env_deploy
    url: $APP_URL/
  when: manual
  only:
    - branches
    - web
  tags:
    - deploy_graphql
注意 deploy 任务中定义的环境配置：'><meta name=author content="野生莲藕"><link rel=canonical href=https://hanlyjiang.github.io/posts/gitlab-chi-xu-ji-cheng-yu-chi-xu-bu-shu-shi-li/><link crossorigin=anonymous href=/assets/css/stylesheet.e3ad983e2ed74d47928d2fcfb404b2d2a87f0ad3e1c106708add8cededbe9a25.css integrity="sha256-462YPi7XTUeSjS/PtASy0qh/CtPhwQZwit2M7e2+miU=" rel="preload stylesheet" as=style><link rel=icon href=https://hanlyjiang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hanlyjiang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hanlyjiang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://hanlyjiang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://hanlyjiang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hanlyjiang.github.io/posts/gitlab-chi-xu-ji-cheng-yu-chi-xu-bu-shu-shi-li/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hanlyjiang.github.io/posts/gitlab-chi-xu-ji-cheng-yu-chi-xu-bu-shu-shi-li/"><meta property="og:site_name" content="清水池塘"><meta property="og:title" content="Gitlab持续集成与持续部署-实例"><meta property="og:description" content='本篇文章介绍如何基于Gitlab来配置一个服务集群的自动构建与部署更新，其中服务的更新基于docker来完成，本文主要关注如何完成部署操作，及如何完成gitlab上ci的配置；在完成单一的服务自动部署更新后，我们通过gitlab的include及trigger机制来简化统一部署流程；
前言 我们需要实现服务的自动构建后的自动更新部署，注意这里我们只需要能做到更新部署的服务即可，服务的初次部署属于低频操作，且和服务器环境相关，需要手动来完成；我们这里假定机器上已经部署好了服务；
单一项目的自动部署的示例 这里我们首先以一个springboot的服务作为示例，实现了整个自动打包及部署更新的流程；
效果 提交之后，自动构建jar，并打包docker镜像
构建完成后，通过gitlab界面，可以触发部署，完成后可以访问对应的环境（详见下方说明）
触发部署步骤的方式 触发部署有多个入口：
流水线列表尾部的手动作业按钮
流水线列表中，点击对应的手动任务，在弹出框中点击运行
流水线详情中，点击触发部署
对应手动作业的详情中，点击“触发此手动操作”
作业列表中对应的部署作业的尾部
访问部署环境的方式 部署之后，会在gitlab中生成一个环境，在环境的相关界面即可访问对应的服务地址
在项目的“运维-环境”入口可以查看所有的环境 点击对应环境尾部的链接图标即可访问
也可以在对应的环境详情页面，点击“查看部署” （注意在部署作业的详情中也可以找到对应环境的入口哦-触发部署步骤的方式的第四中方式的附图）
实现方式 我们有三个任务：
构建jar 构建docker镜像 部署服务（通过swarm） 其中构建jar和构建docker镜像是自动完成的，部署步骤则需要手动通过gitlab界面进行触发；
gitlab-ci.yml 配置 variables: # 配置仓库环境 DOCKER_REGISTRY: zh-registry.colorless.com.cn DOCKER_NAMESPACE: colorless DEPLOY_PATH: /Wksp/colorlessWork/colorless-deploy/deploy/ # 配置镜像服务名 SERVICE_NAME: graphql-token stages: - test - build - build_image - deploy # 引入代码检查任务 #include: # local: ci/gitlab-ci-sonar.yml build:jar: # 部分模块若不使用1.8编译会报错 image: maven:3.6.3-jdk-8 stage: build script: - mvn package - mkdir _archiver - cp target/*.jar _archiver/ - ls -lh _archiver/ artifacts: name: "dist-$CI_PROJECT_NAME-$CI_COMMIT_SHORT_SHA" paths: - _archiver/*.jar # 生成的归档包比较大，我们只保留短时间 expire_in: 1 hours tags: - common-build only: - master - web build:docker: stage: build_image script: # 登录公司的Harbor，注意必须在环境变量配置 HARBOR_PWD - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin # 定义镜像TAG - IMAGE_NAME=$DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA - echo "Docker build options $DOCKER_OPTIONS, set DOCKER_OPTIONS to --no-cache force rebuild all stage" - cp _archiver/*.jar docker/ # build镜像 - JAR_FILE=`ls docker/ | grep -E *.jar` - echo $JAR_FILE - docker build $DOCKER_OPTIONS --build-arg JAR_FILE=$JAR_FILE -t $IMAGE_NAME ./docker/ # 推送镜像 - docker push $IMAGE_NAME - echo "镜像构建完成：$IMAGE_NAME" tags: - docker only: - master - web deploy: stage: deploy script: - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin - cd $DEPLOY_PATH - source deploy.sh - update_service $DOCKER_NAMESPACE $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA environment: name: test_env_deploy url: $APP_URL/ when: manual only: - branches - web tags: - deploy_graphql 注意 deploy 任务中定义的环境配置：'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-26T16:12:17+00:00"><meta property="article:modified_time" content="2021-05-26T16:12:17+00:00"><meta property="article:tag" content="Gitlab"><meta property="article:tag" content="CICD"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gitlab持续集成与持续部署-实例"><meta name=twitter:description content='本篇文章介绍如何基于Gitlab来配置一个服务集群的自动构建与部署更新，其中服务的更新基于docker来完成，本文主要关注如何完成部署操作，及如何完成gitlab上ci的配置；在完成单一的服务自动部署更新后，我们通过gitlab的include及trigger机制来简化统一部署流程；
前言
我们需要实现服务的自动构建后的自动更新部署，注意这里我们只需要能做到更新部署的服务即可，服务的初次部署属于低频操作，且和服务器环境相关，需要手动来完成；我们这里假定机器上已经部署好了服务；
单一项目的自动部署的示例
这里我们首先以一个springboot的服务作为示例，实现了整个自动打包及部署更新的流程；
效果


提交之后，自动构建jar，并打包docker镜像



构建完成后，通过gitlab界面，可以触发部署，完成后可以访问对应的环境（详见下方说明）


触发部署步骤的方式
触发部署有多个入口：


流水线列表尾部的手动作业按钮



流水线列表中，点击对应的手动任务，在弹出框中点击运行



流水线详情中，点击触发部署



对应手动作业的详情中，点击“触发此手动操作”



作业列表中对应的部署作业的尾部



访问部署环境的方式
部署之后，会在gitlab中生成一个环境，在环境的相关界面即可访问对应的服务地址

在项目的“运维-环境”入口可以查看所有的环境




点击对应环境尾部的链接图标即可访问



也可以在对应的环境详情页面，点击“查看部署” （注意在部署作业的详情中也可以找到对应环境的入口哦-触发部署步骤的方式的第四中方式的附图）



实现方式
我们有三个任务：

构建jar
构建docker镜像
部署服务（通过swarm）

其中构建jar和构建docker镜像是自动完成的，部署步骤则需要手动通过gitlab界面进行触发；
gitlab-ci.yml 配置
variables:
  #  配置仓库环境
  DOCKER_REGISTRY: zh-registry.colorless.com.cn
  DOCKER_NAMESPACE: colorless
  DEPLOY_PATH: /Wksp/colorlessWork/colorless-deploy/deploy/
  #  配置镜像服务名
  SERVICE_NAME: graphql-token

stages:
  - test
  - build
  - build_image
  - deploy

# 引入代码检查任务
#include:
#  local: ci/gitlab-ci-sonar.yml

build:jar:
  # 部分模块若不使用1.8编译会报错
  image: maven:3.6.3-jdk-8
  stage: build
  script:
    - mvn package
    - mkdir _archiver
    - cp target/*.jar _archiver/
    - ls -lh _archiver/
  artifacts:
    name: "dist-$CI_PROJECT_NAME-$CI_COMMIT_SHORT_SHA"
    paths:
      - _archiver/*.jar
    # 生成的归档包比较大，我们只保留短时间
    expire_in: 1 hours
  tags:
    - common-build
  only:
    - master
    - web

build:docker:
  stage: build_image
  script:
    # 登录公司的Harbor，注意必须在环境变量配置 HARBOR_PWD
    - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin
    # 定义镜像TAG
    - IMAGE_NAME=$DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA
    - echo "Docker build options $DOCKER_OPTIONS, set DOCKER_OPTIONS to --no-cache force rebuild all stage"
    - cp _archiver/*.jar docker/
    # build镜像
    - JAR_FILE=`ls docker/ | grep -E *.jar`
    - echo $JAR_FILE
    - docker build $DOCKER_OPTIONS --build-arg JAR_FILE=$JAR_FILE -t $IMAGE_NAME ./docker/
    # 推送镜像
    - docker push $IMAGE_NAME
    - echo "镜像构建完成：$IMAGE_NAME"
  tags:
    - docker
  only:
    - master
    - web

deploy:
  stage: deploy
  script:
    - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin
    - cd $DEPLOY_PATH
    - source deploy.sh
    - update_service $DOCKER_NAMESPACE $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA
  environment:
    name: test_env_deploy
    url: $APP_URL/
  when: manual
  only:
    - branches
    - web
  tags:
    - deploy_graphql
注意 deploy 任务中定义的环境配置：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hanlyjiang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Gitlab持续集成与持续部署-实例","item":"https://hanlyjiang.github.io/posts/gitlab-chi-xu-ji-cheng-yu-chi-xu-bu-shu-shi-li/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gitlab持续集成与持续部署-实例","name":"Gitlab持续集成与持续部署-实例","description":"本篇文章介绍如何基于Gitlab来配置一个服务集群的自动构建与部署更新，其中服务的更新基于docker来完成，本文主要关注如何完成部署操作，及如何完成gitlab上ci的配置；在完成单一的服务自动部署更新后，我们通过gitlab的include及trigger机制来简化统一部署流程；\n前言 我们需要实现服务的自动构建后的自动更新部署，注意这里我们只需要能做到更新部署的服务即可，服务的初次部署属于低频操作，且和服务器环境相关，需要手动来完成；我们这里假定机器上已经部署好了服务；\n单一项目的自动部署的示例 这里我们首先以一个springboot的服务作为示例，实现了整个自动打包及部署更新的流程；\n效果 提交之后，自动构建jar，并打包docker镜像\n构建完成后，通过gitlab界面，可以触发部署，完成后可以访问对应的环境（详见下方说明）\n触发部署步骤的方式 触发部署有多个入口：\n流水线列表尾部的手动作业按钮\n流水线列表中，点击对应的手动任务，在弹出框中点击运行\n流水线详情中，点击触发部署\n对应手动作业的详情中，点击“触发此手动操作”\n作业列表中对应的部署作业的尾部\n访问部署环境的方式 部署之后，会在gitlab中生成一个环境，在环境的相关界面即可访问对应的服务地址\n在项目的“运维-环境”入口可以查看所有的环境 点击对应环境尾部的链接图标即可访问\n也可以在对应的环境详情页面，点击“查看部署” （注意在部署作业的详情中也可以找到对应环境的入口哦-触发部署步骤的方式的第四中方式的附图）\n实现方式 我们有三个任务：\n构建jar 构建docker镜像 部署服务（通过swarm） 其中构建jar和构建docker镜像是自动完成的，部署步骤则需要手动通过gitlab界面进行触发；\ngitlab-ci.yml 配置 variables: # 配置仓库环境 DOCKER_REGISTRY: zh-registry.colorless.com.cn DOCKER_NAMESPACE: colorless DEPLOY_PATH: /Wksp/colorlessWork/colorless-deploy/deploy/ # 配置镜像服务名 SERVICE_NAME: graphql-token stages: - test - build - build_image - deploy # 引入代码检查任务 #include: # local: ci/gitlab-ci-sonar.yml build:jar: # 部分模块若不使用1.8编译会报错 image: maven:3.6.3-jdk-8 stage: build script: - mvn package - mkdir _archiver - cp target/*.jar _archiver/ - ls -lh _archiver/ artifacts: name: \u0026#34;dist-$CI_PROJECT_NAME-$CI_COMMIT_SHORT_SHA\u0026#34; paths: - _archiver/*.jar # 生成的归档包比较大，我们只保留短时间 expire_in: 1 hours tags: - common-build only: - master - web build:docker: stage: build_image script: # 登录公司的Harbor，注意必须在环境变量配置 HARBOR_PWD - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin # 定义镜像TAG - IMAGE_NAME=$DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA - echo \u0026#34;Docker build options $DOCKER_OPTIONS, set DOCKER_OPTIONS to --no-cache force rebuild all stage\u0026#34; - cp _archiver/*.jar docker/ # build镜像 - JAR_FILE=`ls docker/ | grep -E *.jar` - echo $JAR_FILE - docker build $DOCKER_OPTIONS --build-arg JAR_FILE=$JAR_FILE -t $IMAGE_NAME ./docker/ # 推送镜像 - docker push $IMAGE_NAME - echo \u0026#34;镜像构建完成：$IMAGE_NAME\u0026#34; tags: - docker only: - master - web deploy: stage: deploy script: - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin - cd $DEPLOY_PATH - source deploy.sh - update_service $DOCKER_NAMESPACE $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA environment: name: test_env_deploy url: $APP_URL/ when: manual only: - branches - web tags: - deploy_graphql 注意 deploy 任务中定义的环境配置：\n","keywords":["Gitlab","CICD"],"articleBody":"本篇文章介绍如何基于Gitlab来配置一个服务集群的自动构建与部署更新，其中服务的更新基于docker来完成，本文主要关注如何完成部署操作，及如何完成gitlab上ci的配置；在完成单一的服务自动部署更新后，我们通过gitlab的include及trigger机制来简化统一部署流程；\n前言 我们需要实现服务的自动构建后的自动更新部署，注意这里我们只需要能做到更新部署的服务即可，服务的初次部署属于低频操作，且和服务器环境相关，需要手动来完成；我们这里假定机器上已经部署好了服务；\n单一项目的自动部署的示例 这里我们首先以一个springboot的服务作为示例，实现了整个自动打包及部署更新的流程；\n效果 提交之后，自动构建jar，并打包docker镜像\n构建完成后，通过gitlab界面，可以触发部署，完成后可以访问对应的环境（详见下方说明）\n触发部署步骤的方式 触发部署有多个入口：\n流水线列表尾部的手动作业按钮\n流水线列表中，点击对应的手动任务，在弹出框中点击运行\n流水线详情中，点击触发部署\n对应手动作业的详情中，点击“触发此手动操作”\n作业列表中对应的部署作业的尾部\n访问部署环境的方式 部署之后，会在gitlab中生成一个环境，在环境的相关界面即可访问对应的服务地址\n在项目的“运维-环境”入口可以查看所有的环境 点击对应环境尾部的链接图标即可访问\n也可以在对应的环境详情页面，点击“查看部署” （注意在部署作业的详情中也可以找到对应环境的入口哦-触发部署步骤的方式的第四中方式的附图）\n实现方式 我们有三个任务：\n构建jar 构建docker镜像 部署服务（通过swarm） 其中构建jar和构建docker镜像是自动完成的，部署步骤则需要手动通过gitlab界面进行触发；\ngitlab-ci.yml 配置 variables: # 配置仓库环境 DOCKER_REGISTRY: zh-registry.colorless.com.cn DOCKER_NAMESPACE: colorless DEPLOY_PATH: /Wksp/colorlessWork/colorless-deploy/deploy/ # 配置镜像服务名 SERVICE_NAME: graphql-token stages: - test - build - build_image - deploy # 引入代码检查任务 #include: # local: ci/gitlab-ci-sonar.yml build:jar: # 部分模块若不使用1.8编译会报错 image: maven:3.6.3-jdk-8 stage: build script: - mvn package - mkdir _archiver - cp target/*.jar _archiver/ - ls -lh _archiver/ artifacts: name: \"dist-$CI_PROJECT_NAME-$CI_COMMIT_SHORT_SHA\" paths: - _archiver/*.jar # 生成的归档包比较大，我们只保留短时间 expire_in: 1 hours tags: - common-build only: - master - web build:docker: stage: build_image script: # 登录公司的Harbor，注意必须在环境变量配置 HARBOR_PWD - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin # 定义镜像TAG - IMAGE_NAME=$DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA - echo \"Docker build options $DOCKER_OPTIONS, set DOCKER_OPTIONS to --no-cache force rebuild all stage\" - cp _archiver/*.jar docker/ # build镜像 - JAR_FILE=`ls docker/ | grep -E *.jar` - echo $JAR_FILE - docker build $DOCKER_OPTIONS --build-arg JAR_FILE=$JAR_FILE -t $IMAGE_NAME ./docker/ # 推送镜像 - docker push $IMAGE_NAME - echo \"镜像构建完成：$IMAGE_NAME\" tags: - docker only: - master - web deploy: stage: deploy script: - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin - cd $DEPLOY_PATH - source deploy.sh - update_service $DOCKER_NAMESPACE $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA environment: name: test_env_deploy url: $APP_URL/ when: manual only: - branches - web tags: - deploy_graphql 注意 deploy 任务中定义的环境配置：\nenvironment: name: test_env_deploy url: $APP_URL/ when: manual 通过environment配置，我们可以在gitlab的 “运维-环境” 中生成一条环境信息，一个环境信息即对应一个部署服务；\n定义环境信息，需要配置name和url两个字段，其中name是环境名称，url则应指向服务的地址，该url即是我们在gitlab环境中查看部署时跳转的页面；\n这里的url我们通过变量来进行配置，也可以直接写死；\n注意这里的name不能设置为中文；\n通过将when 设置为 manual ，可以将部署任务设置为手动触发的方式；\n优化改进方案研究 改进目标 我们的一个集群之中有多个服务单元，每个服务单元提交代码更新之后，都需要自动部署更新到对应的环境中。我们可以选择将上面单个项目中的流程在所有项目中都复制一遍，不过：\n重复工作较多，一旦部署脚本发生变化，每个项目都需要单独变化 每个项目都需要配置到部署服务器的runner 所以，我们需要考虑将这个重复的步骤集中起来。\n实际上，打包jar和构建镜像的流程我们也可以考虑优化复用，不过我们这里主要专注于部署的改进。当服务被打包成镜像之后，部署的流程只关注于镜像，无需针对不同的服务进行区分对待，是非常适合提取统一的；\n现状 经过上面的步骤，我们已经可以实现上传代码后自动编译，构建镜像，通过gitlab界面实现部署了。不过项目比较多时，我们每个都如此配置，一旦需要改动，会比较麻烦，我们可以考虑将这些任务提取成公用的脚本，在项目中进行引入。\n现在，我们尝试将这部署任务提取成公共的。\n实际上，上面的部署流程中，我们已经部署更新的流程做了封装，具体脚本如下，在更新服务时，我们只需要使用 update_service 函数即可完成服务的更新及本地yml部署文件的修改；\n# 更新服务 update_service colorless graphql-engine zh-registry.colorless.com.cn/colorless/graphql-engine:1aaa7ad9 deploy.sh 脚本内容：（只关注update_service 的流程即可）\n#!/usr/bin/env bash #set -eo pipefail REGISTRY_ALIYUN=registry.cn-hangzhou.aliyuncs.com/hasura REGISTRY_HARBOR=zh-registry.colorless.com.cn/colorless # 部署服务 STACK_NAME=colorless function getSedOption() { if [ \"$(uname)\" = \"Darwin\" ]; then echo \"-i .bak\" else echo \"-i.bak\" fi } function logInfo() { echo \"--\u003e: $*\" } function logError() { echo \"--\u003eError: $*\" \u003e\u00262 } # 设置部署目录 if [ \"$0\" = \"-bash\" ]; then DEPLOY_DIR=$PWD else DEPLOY_DIR=$( cd $(dirname $0) pwd ) fi echo \"DEPLOY_DIR:$DEPLOY_DIR\" # 使用阿里云的镜像 function use_aliyun_images() { sed \"$(getSedOption)\" \"s|$REGISTRY_HARBOR|$REGISTRY_ALIYUN|g\" $DEPLOY_DIR/*/*.yml } # 使用内网 harbor 镜像 function use_harbor_images() { sed \"$(getSedOption)\" \"s|$REGISTRY_ALIYUN|$REGISTRY_HARBOR|g\" $DEPLOY_DIR/*/*.yml } # 部署单个脚本服务 function deploy() { service=$1 stack_name=$2 if [ -z \"$service\" ]; then echo \"用法：deploy {服务名称} [stack名称]\" echo \" {服务名称} - 可为 hasura，kafka，event_track\" return fi if [ -z \"$stack_name\" ]; then stack_name=$STACK_NAME fi printf \"\\n%s\\n\" \"获取镜像: $service \" grep \"image:\" \"$DEPLOY_DIR/$service/docker-compose.yml\" | sed 's/image://g' | xargs -I {} docker pull {} printf \"\\n%s\\n\" \"启动服务: $service \" docker stack deploy -c \"$DEPLOY_DIR/$service/docker-compose.yml\" $stack_name printf \"\\n\\n\" } function deploy_offline() { service=$1 stack_name=$2 if [ -z \"$service\" ]; then echo \"用法：deploy {服务名称} [stack名称]\" echo \" {服务名称} - 可为 hasura，kafka，event_track\" return fi if [ -z \"$stack_name\" ]; then stack_name=$STACK_NAME fi printf \"\\n%s\\n\" \"启动服务: $service \" docker stack deploy -c \"$DEPLOY_DIR/$service/docker-compose.yml\" $STACK_NAME printf \"\\n\\n\" } # 导出一个脚本中的镜像 function export_images() { service=$1 if [ -z \"$service\" ]; then echo \"用法：deploy {服务名称}\" echo \" {服务名称} - 可为 hasura，kafka，event_track\" return fi printf \"\\n%s\\n\" \"导出镜像: $service \" image_list=$(grep \"image:\" \"$DEPLOY_DIR/$service/docker-compose.yml\" | sed 's/image://g' | awk '{print $1}' | tr \"\\n\" \" \") echo \"docker image save --output=$DEPLOY_DIR/$service.tar $image_list\" docker image save --output=\"$DEPLOY_DIR/$service\".tar \"$image_list\" printf \"\\n\\n\" } # 部署所有服务 # deploy_all [stack_name] # - stack_name ： stack 名称，不传则为 colorless function deploy_all() { stack_name=$1 if [ -z \"$stack_name\" ]; then stack_name=$STACK_NAME fi deploy graphql $stack_name deploy kafka $stack_name deploy \"gpl-datacollection\" $stack_name } # 不pull镜像，部署所有服务 # deploy_all_offline [stack_name] # - stack_name ： stack 名称，不传则为 colorless function deploy_all_offline() { stack_name=$1 if [ -z \"$stack_name\" ]; then stack_name=$STACK_NAME fi deploy_offline graphql $stack_name deploy_offline kafka $stack_name deploy_offline \"gpl-datacollection\" $stack_name } function pull_image() { image=$1 if [ -z $image ]; then logError \"image参数未指定\" return fi docker pull $image } function _usage_update_service() { logInfo \"用法： update_service {stack} {service} {image}\" } # 更新服务，用法如下： # update_service {stack} {service} {image} # update_service colorless graphql-engine zh-registry.colorless.com.cn/colorless/graphql-engine:1aaa7ad9 # 本函数按如下流程执行： # 1. 获取镜像； # 2. 更新服务；如更新失败，则尝试回滚服务； # 3. 如更新成功，则修改本地yml文件； function update_service() { # 要更新的stack stack=$1 # 要更新的服务 service=$2 # 服务的镜像 image=$3 if [ -z \"$stack\" ]; then logError \"stack 参数不能为空\" _usage_update_service return 1 fi if [ -z \"$service\" ]; then logError \"service 参数不能为空\" _usage_update_service return 1 fi if [ -z \"$image\" ]; then logError \"image 参数不能为空\" _usage_update_service return 1 fi logInfo \"获取镜像：$image\" pull_image \"$image\" if [ $? -eq 1 ]; then logError \"镜像获取失败\" return 1 fi service_name=\"${stack}_${service}\" logInfo \"开始更新服务：docker service update $service_name --image=$image\" docker service update \"$service_name\" --image=\"$image\" update_result=$? logInfo \"当前服务状态: \" docker stack services $stack # 更新失败 if [ $update_result -eq 1 ]; then logError \"更新失败，确定是否需要回滚服务\" docker service ls --format=\"{{.Image}}\" | grep -E \"^$image$\" find_image=$? if [ $find_image -eq 0 ]; then logInfo \"开始回滚服务：$service_name\" docker service rollback \"$service_name\" logInfo \"回滚完成，输出服务状态：(可手动确认服务状态)\" docker service ls else logInfo \"无需回滚\" fi # 直接退出 logError \"更新失败，即将退出，请手动检查服务镜像是否正常\" return 1 fi # 更新成功，开始更新本地yml部署脚本 logInfo \"开始更新本地yml部署脚本\" update_service_yaml_config \"$stack\" \"$service\" \"$image\" } # 更新本地的yml文件配置 function update_service_yaml_config() { # 要更新的stack stack=$1 # 要更新的服务 service=$2 # 服务的镜像 image=$3 if [ -z \"$stack\" ]; then logError \"stack 参数不能为空\" return 1 fi if [ -z \"$service\" ]; then logError \"service 参数不能为空\" return 1 fi if [ -z \"$image\" ]; then logError \"image 参数不能为空\" return 1 fi service_name=\"${stack}_${service}\" # 查找需要修改的文件(根据服务名查找，排除arm） # -H 输出匹配的文件路径 # -v 过滤掉 arm # -print0 | xargs -0 用于处理文件名中可能存在的特殊字符 # 这里 /b:/b 的匹配模式 确保有空格的情况下尽可能的匹配到service # 完成后输出类似如下： # ./graphql/docker-compose-20210325.yml: graphql-engine: # ./graphql/docker-compose.yml: graphql-engine: # 获取需要修改的文件列表 # IFS=\" \" read -r -a file_list \u003c\u003c\u003c find . -type f -name \"*.yml\" -print0 | xargs -0 -I {} grep -H \"$service *: *$\" {} | grep -v \"arm\" | awk -F: '{print $1}' | tr \"\\n\" \" \" # file_list=($(find . -type f -name \"*.yml\" -print0 | xargs -0 -I {} grep -H \"$service *: *$\" {} | grep -v \"arm\" | awk -F: '{print $1}' | tr \"\\n\" \" \")) # 上面变量的写法在gitlab-runner上有问题 # for file in \"${file_list[@]}\"; do for file in $(find . -type f -name \"*.yml\" -print0 | xargs -0 -I {} grep -H \"$service *: *$\" {} | grep -v \"arm\" | awk -F: '{print $1}' | tr \"\\n\" \" \"); do logInfo 开始修改文件:\"$file\" # 获取文件中的镜像全名 \" *\" 匹配一个或多个空格 # 注意：这里通过服务名称来查找镜像名称，通过 grep -A 4 多输出四行，然后在这四行中寻找image段，从而获取文件中对应service的image的全名 raw_image=$(grep -A 4 \"$service *: *$\" \"$file\" | grep image | sed 's/.*image: *//g') logInfo \"备份文件: $file.bak\" # cp -f \"$file\" \"$file.bak\" # 开始修改文件 sed \"$(getSedOption)\" \"s|$raw_image|$image|g\" \"$file\" if [ $? -eq 0 ]; then confirm_ed_result=$(grep \"$image\" \"$file\") if [ -n \"$confirm_ed_result\" ]; then logInfo \"修改成功\" logInfo \"服务更新完成\" else logError \"文件修改失败\" fi else logError \"文件修改失败\" fi done } # 导出所有镜像 function export_all_images() { export_images graphql export_images kafka export_images \"gpl-datacollection\" } echo \"导入部署脚本成功\" 调查 观察如下一个具体的deploy的job，我们可以有如下提取方向：\n将整个job都提取出去； 将script段提取出来； 将部署任务集中到一个单独的部署项目，各个服务模块更新后触发部署项目进行部署； deploy: stage: deploy script: - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin - cd $DEPLOY_PATH #- sudo chmod 777 -R $DEPLOY_PATH 需要自行使用root用户添加权限 - echo \"$SERVICE_NAME\" - echo \"$DEPLOY_PATH\" - echo \"$DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA\" - source deploy.sh - update_service $DOCKER_NAMESPACE $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA environment: name: test_env_deploy url: $APP_URL/ when: manual only: - branches - web tags: - deploy_graphql 接下来，我们带着上述两个问题来寻找相关的技术支持 - 即：gitlab能帮助我们做到哪些及什么程度？\n经过简单的调查我们可以知道，gitlabci的配置中，有一个include 的配置可以引入外部的yaml，我们详细了解下这个配置（Keyword reference for the .gitlab-ci.yml file | GitLab）\n而提取脚本是一个比较确定可以实现的事情，所以我们不予调查；\ninclude 用途：\n在ci配置中导入外部的yaml配置； 拆分长的配置，提升可读性； 提取公共的配置，减少重复配置； 拆分放置到中心仓库，在其他项目中引入； 支持的源：\nKeyword Method local 本项目中的文件 file 引入其他项目中的文件 remote 引入远程的URL中的文件（必须能被公开访问到） template 引入Gitlab提供的模板文件 这里我们主要查看file- 即如何引入其他项目中的文件；\n基本用法：（需要使用project指定项目）\n项目的地址是相对于根目录（/）\ninclude: - project: 'my-group/my-project' file: '/templates/.gitlab-ci-template.yml' 指定分支/Tag/提交：(通过ref指定)\ninclude: - project: 'my-group/my-project' ref: main file: '/templates/.gitlab-ci-template.yml' - project: 'my-group/my-project' ref: v1.0.0 file: '/templates/.gitlab-ci-template.yml' - project: 'my-group/my-project' ref: 787123b47f14b552955ca2786bc9542ae66fee5b # Git SHA file: '/templates/.gitlab-ci-template.yml' 同时引入多个文件：（file中使用数组语法）\ninclude: - project: 'my-group/my-project' ref: main file: - '/templates/.builds.yml' - '/templates/.tests.yml' 嵌套引入：\n所有嵌套的includes都在当前目标项目的范围内执行，所以可以使用local (相对于目标项目), project, remote, 或者 template includes。\n可以最多有 100 个 includes；\n不能有重复的include\n在GitLab 12.4 及后续版本中, 解析所有文件的时间被限制在30秒之内，所以可能需要考虑文件的复杂度；\n权限：\n执行人需要具有项目的权限；\nAll nested includes are executed only with the permission of the user, so it’s possible to use project, remote or template includes.\ntrigger gitlab可以使用trigger来触发多项目构建，在gitlab-ci配置中，可以使用trigger来定义一个下游流水线的触发器，当Gitlab启动这个trigger的任务时，会创建一个下游流水线；\n对比于正常的任务，trigger类型的任务只有少量关键字可以使用；\nGitlab中可使用trigger创建两种类型的下游流水线：\n多项目流水线： 触发其他项目的流水线； 子流水线： 触发当前项目的流水线； 多项目流水线的触发任务基本写法：\nrspec: stage: test script: bundle exec rspec staging: stage: deploy trigger: my/deployment 多项目流水线的触发任务复杂写法：\n通过branch指定分支\nrspec: stage: test script: bundle exec rspec staging: stage: deploy trigger: project: my/deployment branch: stable 镜像下流流水线的状态(通过设置strategy: depend,默认情况下，触发器任务会被标记为成功，设置此标记后，则会等待下游流水线执行完成，然后使用下流流水线的状态来标记该触发器任务的状态)\ntrigger_job: trigger: project: my/project strategy: depend 在下游流水线中，也可以获取上游流水线的状态\nupstream_bridge: stage: test needs: pipeline: other/project 子流水线的写法：\n指定项目中的YAML文件的路径即可创建子流水线\ntrigger_job: trigger: include: path/to/child-pipeline.yml 同样的，也可以设置获取下游状态\ntrigger_job: trigger: include: - local: path/to/child-pipeline.yml strategy: depend 可以使用其他项目中的YAML文件来定义子流水线\nchild-pipeline: trigger: include: - project: 'my-group/my-pipeline-library' ref: 'main' file: '/path/to/child-pipeline.yml' 可以使用自动生成的配置来生成子流水线(参考：Parent-child pipelines | GitLab)\ngenerate-config: stage: build script: generate-ci-config \u003e generated-config.yml artifacts: paths: - generated-config.yml child-pipeline: stage: test trigger: include: - artifact: generated-config.yml job: generate-config 整体方案 通过上面的分析，我们可以看到\ngitlab支持通过include来引入外部的脚本，脚本可以来自于本项目，也可以来自于其他项目； 通过trigger可以触发其他项目的流水线或者在本项目中生成一个子流水线，可以选择跟踪子流水线的执行状态； 经过如上分析，我们决定使用如下方案对现有部署需求进行实施：\n每个项目分别定义自己的构建和镜像打包任务； 镜像打包完成后通过trigger来触发colorless部署仓库的部署任务，需要传递自己的信息给部署仓库生成的流水线； 触发任务的定义文件放置到colorless部署仓库中，在各个服务项目中通过include来引入； 优化方案实现 如上所述，我们将部署操作集中到一个单独项目中，而又各个服务项目触发其部署流程，这里我们将这个单独的用于部署的项目称为独立部署项目，将其他服务的项目称之为子服务项目；以下分别说明上述方案中两种项目中的配置方式；\n各子服务项目的配置 gitlab-ci.yml配置 我们将部署任务替换为一个触发任务，并从独立部署项目中引入任务的配置\nstages: - test - build - build_image - auto-build-deploy # 省略其他定义 # 引入触发自动编译部署任务配置 include: - project: 'Deptproduct-project/colorless/colorless-deploy' # ref: master file: '/ci/gitlab-ci-base.yml' 这段配置会从 Deptproduct-project/colorless/colorless-deploy 项目中导入 /ci/gitlab-ci-base.yml 的配置，具体内容如下：\n# 子模块用的公用触发项目，可以在子模块源码中 include trigger:auto-build-deploy: stage: auto-build-deploy variables: TRIGGER_CI_COMMIT_SHORT_SHA: $CI_COMMIT_SHORT_SHA # 配置仓库环境 # 自定义变量必须配置在上游UI界面 DOCKER_REGISTRY: $DOCKER_REGISTRY DOCKER_NAMESPACE: $DOCKER_NAMESPACE HARBOR_PWD: $HARBOR_PWD HARBOR_USER: $HARBOR_USER SERVICE_NAME: $SERVICE_NAME trigger: project: Deptproduct-project/colorless/colorless-deploy 在子项目中的ci配置中include该文件时，会生成一个触发任务，这个触发任务会触发Deptproduct-project/colorless/colorless-deploy这个项目，也就是我们的独立部署项目；\n也就是说会触发我们独立部署项目生成一个流水线，此时流水线读取的就是我们独立部署项目的.gitlab-ci.yml 文件；\nweb UI中CI/CD变量配置 上述的触发任务的配置中，我们定义了几个变量，用于向部署项目的流水线说明我们自身的一些信息\nTRIGGER_CI_COMMIT_SHORT_SHA: $CI_COMMIT_SHORT_SHA DOCKER_REGISTRY: $DOCKER_REGISTRY DOCKER_NAMESPACE: $DOCKER_NAMESPACE HARBOR_PWD: $HARBOR_PWD HARBOR_USER: $HARBOR_USER SERVICE_NAME: $SERVICE_NAME 其中，由我们自行定义的变量（$DOCKER_REGISTRY,DOCKER_NAMESPACE,$HARBOR_PWD,$HARBOR_USER,$SERVICE_NAME）需要在项目/群组的CI的变量中进行配置，在解析此触发任务时才可以读取到；\n独立部署项目的配置 gitlab-ci.yml 配置 variables: # UI界面配置 DEPLOY_PATH DEPLOY_PATH: /Wksp/colorlessWork/colorless-deploy/deploy/ # 部署的stack DOCKER_STACK: colorless deploy: stage: deploy script: - echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin - cd $DEPLOY_PATH - source deploy.sh - update_service $DOCKER_STACK $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$TRIGGER_CI_COMMIT_SHORT_SHA environment: name: test_env_deploy url: $APP_URL/ when: manual tags: - deploy_graphql web UI中CI/CD变量配置 现在，我们有些部署相关的变量需要从子服务项目中提取到当前独立部署项目中来定义，包括：DEPLOY_PATH,DOCKER_STACK,APP_URL，其中DEPLOY_PATH,DOCKER_STACK我们在yml中有定义默认值，可以不在UI界面中进行定义，只需要在UI界面中定义APP_URL即可；\n运行效果说明 每次子服务项目中提交代码，且满足ci配置中定义的条件时，即会生成一个触发任务，执行完前期阶段的任务后，当执行触发任务时，就会触发我们的独立仓库的部署任务。具体界面如下图所示； 点击下游任务即可跳转到我们的独立部署仓库中对应的流水线中； 点击deploy任务的运行按钮，即可进行部署；\n部署完成后，可在独立部署仓库中生成一个部署环境，点击即可前往；\n","wordCount":"1477","inLanguage":"en","datePublished":"2021-05-26T16:12:17Z","dateModified":"2021-05-26T16:12:17Z","author":{"@type":"Person","name":"野生莲藕"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hanlyjiang.github.io/posts/gitlab-chi-xu-ji-cheng-yu-chi-xu-bu-shu-shi-li/"},"publisher":{"@type":"Organization","name":"清水池塘","logo":{"@type":"ImageObject","url":"https://hanlyjiang.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hanlyjiang.github.io/ accesskey=h title="清水池塘 (Alt + H)">清水池塘</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hanlyjiang.github.io/ title=首页><span>首页</span></a></li><li><a href=https://hanlyjiang.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://hanlyjiang.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hanlyjiang.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hanlyjiang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hanlyjiang.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Gitlab持续集成与持续部署-实例</h1><div class=post-meta><span title='2021-05-26 16:12:17 +0000 UTC'>May 26, 2021</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1477 words</span>&nbsp;·&nbsp;<span>野生莲藕</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e5%8d%95%e4%b8%80%e9%a1%b9%e7%9b%ae%e7%9a%84%e8%87%aa%e5%8a%a8%e9%83%a8%e7%bd%b2%e7%9a%84%e7%a4%ba%e4%be%8b aria-label=单一项目的自动部署的示例>单一项目的自动部署的示例</a><ul><li><a href=#%e6%95%88%e6%9e%9c aria-label=效果>效果</a></li><li><a href=#%e8%a7%a6%e5%8f%91%e9%83%a8%e7%bd%b2%e6%ad%a5%e9%aa%a4%e7%9a%84%e6%96%b9%e5%bc%8f aria-label=触发部署步骤的方式>触发部署步骤的方式</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e9%83%a8%e7%bd%b2%e7%8e%af%e5%a2%83%e7%9a%84%e6%96%b9%e5%bc%8f aria-label=访问部署环境的方式>访问部署环境的方式</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f aria-label=实现方式>实现方式</a><ul><li><a href=#gitlab-ciyml-%e9%85%8d%e7%bd%ae aria-label="gitlab-ci.yml 配置">gitlab-ci.yml 配置</a></li></ul></li></ul></li><li><a href=#%e4%bc%98%e5%8c%96%e6%94%b9%e8%bf%9b%e6%96%b9%e6%a1%88%e7%a0%94%e7%a9%b6 aria-label=优化改进方案研究>优化改进方案研究</a><ul><li><a href=#%e6%94%b9%e8%bf%9b%e7%9b%ae%e6%a0%87 aria-label=改进目标>改进目标</a></li><li><a href=#%e7%8e%b0%e7%8a%b6 aria-label=现状>现状</a></li><li><a href=#%e8%b0%83%e6%9f%a5 aria-label=调查>调查</a><ul><li><a href=#include aria-label=include>include</a></li><li><a href=#trigger aria-label=trigger>trigger</a></li></ul></li><li><a href=#%e6%95%b4%e4%bd%93%e6%96%b9%e6%a1%88 aria-label=整体方案>整体方案</a></li></ul></li><li><a href=#%e4%bc%98%e5%8c%96%e6%96%b9%e6%a1%88%e5%ae%9e%e7%8e%b0 aria-label=优化方案实现>优化方案实现</a><ul><li><a href=#%e5%90%84%e5%ad%90%e6%9c%8d%e5%8a%a1%e9%a1%b9%e7%9b%ae%e7%9a%84%e9%85%8d%e7%bd%ae aria-label=各子服务项目的配置>各子服务项目的配置</a><ul><li><a href=#gitlab-ciyml%e9%85%8d%e7%bd%ae aria-label=gitlab-ci.yml配置>gitlab-ci.yml配置</a></li><li><a href=#web-ui%e4%b8%adcicd%e5%8f%98%e9%87%8f%e9%85%8d%e7%bd%ae aria-label="web UI中CI/CD变量配置">web UI中CI/CD变量配置</a></li></ul></li><li><a href=#%e7%8b%ac%e7%ab%8b%e9%83%a8%e7%bd%b2%e9%a1%b9%e7%9b%ae%e7%9a%84%e9%85%8d%e7%bd%ae aria-label=独立部署项目的配置>独立部署项目的配置</a><ul><li><a href=#gitlab-ciyml-%e9%85%8d%e7%bd%ae-1 aria-label="gitlab-ci.yml 配置">gitlab-ci.yml 配置</a></li><li><a href=#web-ui%e4%b8%adcicd%e5%8f%98%e9%87%8f%e9%85%8d%e7%bd%ae-1 aria-label="web UI中CI/CD变量配置">web UI中CI/CD变量配置</a></li></ul></li><li><a href=#%e8%bf%90%e8%a1%8c%e6%95%88%e6%9e%9c%e8%af%b4%e6%98%8e aria-label=运行效果说明>运行效果说明</a></li></ul></li></ul></div></details></div><div class=post-content><p>本篇文章介绍如何基于Gitlab来配置一个服务集群的自动构建与部署更新，其中服务的更新基于docker来完成，本文主要关注如何完成部署操作，及如何完成gitlab上ci的配置；在完成单一的服务自动部署更新后，我们通过gitlab的include及trigger机制来简化统一部署流程；</p><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>我们需要实现服务的自动构建后的自动更新部署，注意这里我们只需要能做到更新部署的服务即可，服务的初次部署属于低频操作，且和服务器环境相关，需要手动来完成；我们这里假定机器上已经部署好了服务；</p><h2 id=单一项目的自动部署的示例>单一项目的自动部署的示例<a hidden class=anchor aria-hidden=true href=#单一项目的自动部署的示例>#</a></h2><p>这里我们首先以一个springboot的服务作为示例，实现了整个自动打包及部署更新的流程；</p><h3 id=效果>效果<a hidden class=anchor aria-hidden=true href=#效果>#</a></h3><ul><li><p>提交之后，自动构建jar，并打包docker镜像</p><p><img alt=202203192258673 loading=lazy src=https://s2.loli.net/2022/05/26/15jIx7oVTpdN2qG.png></p></li><li><p>构建完成后，通过gitlab界面，可以触发部署，完成后可以访问对应的环境（详见下方说明）</p></li></ul><h3 id=触发部署步骤的方式>触发部署步骤的方式<a hidden class=anchor aria-hidden=true href=#触发部署步骤的方式>#</a></h3><p>触发部署有多个入口：</p><ol><li><p>流水线列表尾部的手动作业按钮</p><p><img alt=20210526101412 loading=lazy src=https://s2.loli.net/2022/05/26/H4IPizrx1pOlMwG.png></p></li><li><p>流水线列表中，点击对应的手动任务，在弹出框中点击运行</p><p><img alt=20210526101519 loading=lazy src=https://s2.loli.net/2022/05/26/TN472VCvmxjhHwe.png></p></li><li><p>流水线详情中，点击触发部署</p><p><img alt=202203192259870 loading=lazy src=https://s2.loli.net/2022/05/26/TpsmiNOa5AWVf32.png></p></li><li><p>对应手动作业的详情中，点击“触发此手动操作”</p><p><img alt=202203192300715 loading=lazy src=https://s2.loli.net/2022/05/26/GDTRWdy2iXAP1Le.png></p></li><li><p>作业列表中对应的部署作业的尾部</p><p><img alt=202203192301127 loading=lazy src=https://s2.loli.net/2022/05/26/574YeyxSfMqoaju.png></p></li></ol><h3 id=访问部署环境的方式>访问部署环境的方式<a hidden class=anchor aria-hidden=true href=#访问部署环境的方式>#</a></h3><p>部署之后，会在gitlab中生成一个环境，在环境的相关界面即可访问对应的服务地址</p><ol><li>在项目的“运维-环境”入口可以查看所有的环境</li></ol><p><img alt=20210526101758 loading=lazy src=https://s2.loli.net/2022/05/26/z6jTAhZRkmXGFqe.png></p><ol start=2><li><p>点击对应环境尾部的链接图标即可访问</p><p><img alt=20210526101901 loading=lazy src=https://s2.loli.net/2022/05/26/NHU1YLsjnP8x3ib.png></p></li><li><p>也可以在对应的环境详情页面，点击“查看部署” （注意在部署作业的详情中也可以找到对应环境的入口哦-触发部署步骤的方式的第四中方式的附图）</p><p><img loading=lazy src=https://s2.loli.net/2022/05/26/NHU1YLsjnP8x3ib.png></p></li></ol><h3 id=实现方式>实现方式<a hidden class=anchor aria-hidden=true href=#实现方式>#</a></h3><p>我们有三个任务：</p><ul><li>构建jar</li><li>构建docker镜像</li><li>部署服务（通过swarm）</li></ul><p>其中构建jar和构建docker镜像是自动完成的，部署步骤则需要手动通过gitlab界面进行触发；</p><h4 id=gitlab-ciyml-配置>gitlab-ci.yml 配置<a hidden class=anchor aria-hidden=true href=#gitlab-ciyml-配置>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>variables</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e>#  配置仓库环境</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>DOCKER_REGISTRY</span>: <span style=color:#ae81ff>zh-registry.colorless.com.cn</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>DOCKER_NAMESPACE</span>: <span style=color:#ae81ff>colorless</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>DEPLOY_PATH</span>: <span style=color:#ae81ff>/Wksp/colorlessWork/colorless-deploy/deploy/</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#  配置镜像服务名</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>SERVICE_NAME</span>: <span style=color:#ae81ff>graphql-token</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>stages</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>build</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>build_image</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>deploy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 引入代码检查任务</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  local: ci/gitlab-ci-sonar.yml</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>build:jar</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># 部分模块若不使用1.8编译会报错</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>image</span>: <span style=color:#ae81ff>maven:3.6.3-jdk-8</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>build</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>mvn package</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>mkdir _archiver</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>cp target/*.jar _archiver/</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ls -lh _archiver/</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>artifacts</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;dist-$CI_PROJECT_NAME-$CI_COMMIT_SHORT_SHA&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>_archiver/*.jar</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 生成的归档包比较大，我们只保留短时间</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>expire_in</span>: <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>hours</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>common-build</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>only</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>master</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>build:docker</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>build_image</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 登录公司的Harbor，注意必须在环境变量配置 HARBOR_PWD</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 定义镜像TAG</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>IMAGE_NAME=$DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo &#34;Docker build options $DOCKER_OPTIONS, set DOCKER_OPTIONS to --no-cache force rebuild all stage&#34;</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>cp _archiver/*.jar docker/</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># build镜像</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>JAR_FILE=`ls docker/ | grep -E *.jar`</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo $JAR_FILE</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>docker build $DOCKER_OPTIONS --build-arg JAR_FILE=$JAR_FILE -t $IMAGE_NAME ./docker/</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 推送镜像</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>docker push $IMAGE_NAME</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo &#34;镜像构建完成：$IMAGE_NAME&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>docker</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>only</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>master</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>deploy</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>deploy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>cd $DEPLOY_PATH</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>source deploy.sh</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>update_service $DOCKER_NAMESPACE $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test_env_deploy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>url</span>: <span style=color:#ae81ff>$APP_URL/</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>manual</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>only</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>branches</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>deploy_graphql</span>
</span></span></code></pre></div><p>注意 deploy 任务中定义的环境配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>  <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test_env_deploy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>url</span>: <span style=color:#ae81ff>$APP_URL/</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>manual</span>
</span></span></code></pre></div><ol><li><p>通过environment配置，我们可以在gitlab的 “运维-环境” 中生成一条环境信息，一个环境信息即对应一个部署服务；</p><p>定义环境信息，需要配置name和url两个字段，其中name是环境名称，url则应指向服务的地址，该url即是我们在gitlab环境中查看部署时跳转的页面；</p></li><li><p>这里的url我们通过变量来进行配置，也可以直接写死；</p></li><li><p>注意这里的name不能设置为中文；</p></li><li><p>通过将when 设置为 manual ，可以将部署任务设置为手动触发的方式；</p></li></ol><h2 id=优化改进方案研究>优化改进方案研究<a hidden class=anchor aria-hidden=true href=#优化改进方案研究>#</a></h2><h3 id=改进目标>改进目标<a hidden class=anchor aria-hidden=true href=#改进目标>#</a></h3><p>我们的一个集群之中有多个服务单元，每个服务单元提交代码更新之后，都需要自动部署更新到对应的环境中。我们可以选择将上面单个项目中的流程在所有项目中都复制一遍，不过：</p><ul><li>重复工作较多，一旦部署脚本发生变化，每个项目都需要单独变化</li><li>每个项目都需要配置到部署服务器的runner</li></ul><p>所以，我们需要考虑将这个重复的步骤集中起来。</p><blockquote><p>实际上，打包jar和构建镜像的流程我们也可以考虑优化复用，不过我们这里主要专注于部署的改进。当服务被打包成镜像之后，部署的流程只关注于镜像，无需针对不同的服务进行区分对待，是非常适合提取统一的；</p></blockquote><h3 id=现状>现状<a hidden class=anchor aria-hidden=true href=#现状>#</a></h3><p>经过上面的步骤，我们已经可以实现上传代码后自动编译，构建镜像，通过gitlab界面实现部署了。不过项目比较多时，我们每个都如此配置，一旦需要改动，会比较麻烦，我们可以考虑将这些任务提取成公用的脚本，在项目中进行引入。</p><p>现在，我们尝试将这部署任务提取成公共的。</p><p>实际上，上面的部署流程中，我们已经部署更新的流程做了封装，具体脚本如下，在更新服务时，我们只需要使用 <code>update_service</code> 函数即可完成服务的更新及本地yml部署文件的修改；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 更新服务</span>
</span></span><span style=display:flex><span>update_service colorless graphql-engine zh-registry.colorless.com.cn/colorless/graphql-engine:1aaa7ad9
</span></span></code></pre></div><p>deploy.sh 脚本内容：（只关注update_service 的流程即可）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#set -eo pipefail</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>REGISTRY_ALIYUN<span style=color:#f92672>=</span>registry.cn-hangzhou.aliyuncs.com/hasura
</span></span><span style=display:flex><span>REGISTRY_HARBOR<span style=color:#f92672>=</span>zh-registry.colorless.com.cn/colorless
</span></span><span style=display:flex><span><span style=color:#75715e># 部署服务</span>
</span></span><span style=display:flex><span>STACK_NAME<span style=color:#f92672>=</span>colorless
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> getSedOption<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>uname<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Darwin&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;-i .bak&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;-i.bak&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> logInfo<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;--&gt;: </span>$*<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> logError<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;--&gt;Error: </span>$*<span style=color:#e6db74>&#34;</span> &gt;&amp;<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 设置部署目录</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$0<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;-bash&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  DEPLOY_DIR<span style=color:#f92672>=</span>$PWD
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  DEPLOY_DIR<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>
</span></span><span style=display:flex><span>    cd <span style=color:#66d9ef>$(</span>dirname $0<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>    pwd
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;DEPLOY_DIR:</span>$DEPLOY_DIR<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用阿里云的镜像</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> use_aliyun_images<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  sed <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>getSedOption<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;s|</span>$REGISTRY_HARBOR<span style=color:#e6db74>|</span>$REGISTRY_ALIYUN<span style=color:#e6db74>|g&#34;</span> $DEPLOY_DIR/*/*.yml
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用内网 harbor 镜像</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> use_harbor_images<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  sed <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>getSedOption<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;s|</span>$REGISTRY_ALIYUN<span style=color:#e6db74>|</span>$REGISTRY_HARBOR<span style=color:#e6db74>|g&#34;</span> $DEPLOY_DIR/*/*.yml
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 部署单个脚本服务</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> deploy<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  service<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  stack_name<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$service<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;用法：deploy {服务名称} [stack名称]&#34;</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;     {服务名称} - 可为 hasura，kafka，event_track&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$stack_name<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    stack_name<span style=color:#f92672>=</span>$STACK_NAME
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  printf <span style=color:#e6db74>&#34;\n%s\n&#34;</span> <span style=color:#e6db74>&#34;获取镜像: </span>$service<span style=color:#e6db74> &#34;</span>
</span></span><span style=display:flex><span>  grep <span style=color:#e6db74>&#34;image:&#34;</span> <span style=color:#e6db74>&#34;</span>$DEPLOY_DIR<span style=color:#e6db74>/</span>$service<span style=color:#e6db74>/docker-compose.yml&#34;</span> | sed <span style=color:#e6db74>&#39;s/image://g&#39;</span> | xargs -I <span style=color:#f92672>{}</span> docker pull <span style=color:#f92672>{}</span>
</span></span><span style=display:flex><span>  printf <span style=color:#e6db74>&#34;\n%s\n&#34;</span> <span style=color:#e6db74>&#34;启动服务: </span>$service<span style=color:#e6db74> &#34;</span>
</span></span><span style=display:flex><span>  docker stack deploy -c <span style=color:#e6db74>&#34;</span>$DEPLOY_DIR<span style=color:#e6db74>/</span>$service<span style=color:#e6db74>/docker-compose.yml&#34;</span> $stack_name
</span></span><span style=display:flex><span>  printf <span style=color:#e6db74>&#34;\n\n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> deploy_offline<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  service<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  stack_name<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$service<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;用法：deploy {服务名称} [stack名称]&#34;</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;     {服务名称} - 可为 hasura，kafka，event_track&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$stack_name<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    stack_name<span style=color:#f92672>=</span>$STACK_NAME
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  printf <span style=color:#e6db74>&#34;\n%s\n&#34;</span> <span style=color:#e6db74>&#34;启动服务: </span>$service<span style=color:#e6db74> &#34;</span>
</span></span><span style=display:flex><span>  docker stack deploy -c <span style=color:#e6db74>&#34;</span>$DEPLOY_DIR<span style=color:#e6db74>/</span>$service<span style=color:#e6db74>/docker-compose.yml&#34;</span> $STACK_NAME
</span></span><span style=display:flex><span>  printf <span style=color:#e6db74>&#34;\n\n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 导出一个脚本中的镜像</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> export_images<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  service<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$service<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;用法：deploy {服务名称}&#34;</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;     {服务名称} - 可为 hasura，kafka，event_track&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  printf <span style=color:#e6db74>&#34;\n%s\n&#34;</span> <span style=color:#e6db74>&#34;导出镜像: </span>$service<span style=color:#e6db74> &#34;</span>
</span></span><span style=display:flex><span>  image_list<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>grep <span style=color:#e6db74>&#34;image:&#34;</span> <span style=color:#e6db74>&#34;</span>$DEPLOY_DIR<span style=color:#e6db74>/</span>$service<span style=color:#e6db74>/docker-compose.yml&#34;</span> | sed <span style=color:#e6db74>&#39;s/image://g&#39;</span> | awk <span style=color:#e6db74>&#39;{print $1}&#39;</span> | tr <span style=color:#e6db74>&#34;\n&#34;</span> <span style=color:#e6db74>&#34; &#34;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;docker image save --output=</span>$DEPLOY_DIR<span style=color:#e6db74>/</span>$service<span style=color:#e6db74>.tar </span>$image_list<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  docker image save --output<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$DEPLOY_DIR<span style=color:#e6db74>/</span>$service<span style=color:#e6db74>&#34;</span>.tar <span style=color:#e6db74>&#34;</span>$image_list<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  printf <span style=color:#e6db74>&#34;\n\n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 部署所有服务</span>
</span></span><span style=display:flex><span><span style=color:#75715e># deploy_all [stack_name]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># - stack_name ： stack 名称，不传则为 colorless</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> deploy_all<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  stack_name<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$stack_name<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    stack_name<span style=color:#f92672>=</span>$STACK_NAME
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  deploy graphql $stack_name
</span></span><span style=display:flex><span>  deploy kafka $stack_name
</span></span><span style=display:flex><span>  deploy <span style=color:#e6db74>&#34;gpl-datacollection&#34;</span> $stack_name
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 不pull镜像，部署所有服务</span>
</span></span><span style=display:flex><span><span style=color:#75715e># deploy_all_offline [stack_name]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># - stack_name ： stack 名称，不传则为 colorless</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> deploy_all_offline<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  stack_name<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$stack_name<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    stack_name<span style=color:#f92672>=</span>$STACK_NAME
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  deploy_offline graphql $stack_name
</span></span><span style=display:flex><span>  deploy_offline kafka $stack_name
</span></span><span style=display:flex><span>  deploy_offline <span style=color:#e6db74>&#34;gpl-datacollection&#34;</span> $stack_name
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> pull_image<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  image<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z $image <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;image参数未指定&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  docker pull $image
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> _usage_update_service<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  logInfo <span style=color:#e6db74>&#34;用法： update_service {stack} {service} {image}&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 更新服务，用法如下：</span>
</span></span><span style=display:flex><span><span style=color:#75715e># update_service {stack} {service} {image}</span>
</span></span><span style=display:flex><span><span style=color:#75715e># update_service colorless graphql-engine zh-registry.colorless.com.cn/colorless/graphql-engine:1aaa7ad9</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 本函数按如下流程执行：</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. 获取镜像；</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 更新服务；如更新失败，则尝试回滚服务；</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 如更新成功，则修改本地yml文件；</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> update_service<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 要更新的stack</span>
</span></span><span style=display:flex><span>  stack<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  <span style=color:#75715e># 要更新的服务</span>
</span></span><span style=display:flex><span>  service<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>  <span style=color:#75715e># 服务的镜像</span>
</span></span><span style=display:flex><span>  image<span style=color:#f92672>=</span>$3
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$stack<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;stack 参数不能为空&#34;</span>
</span></span><span style=display:flex><span>    _usage_update_service
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$service<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;service 参数不能为空&#34;</span>
</span></span><span style=display:flex><span>    _usage_update_service
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$image<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;image 参数不能为空&#34;</span>
</span></span><span style=display:flex><span>    _usage_update_service
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  logInfo <span style=color:#e6db74>&#34;获取镜像：</span>$image<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  pull_image <span style=color:#e6db74>&#34;</span>$image<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $? -eq <span style=color:#ae81ff>1</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;镜像获取失败&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  service_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>stack<span style=color:#e6db74>}</span><span style=color:#e6db74>_</span><span style=color:#e6db74>${</span>service<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  logInfo <span style=color:#e6db74>&#34;开始更新服务：docker service update </span>$service_name<span style=color:#e6db74> --image=</span>$image<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  docker service update <span style=color:#e6db74>&#34;</span>$service_name<span style=color:#e6db74>&#34;</span> --image<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$image<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  update_result<span style=color:#f92672>=</span>$?
</span></span><span style=display:flex><span>  logInfo <span style=color:#e6db74>&#34;当前服务状态: &#34;</span>
</span></span><span style=display:flex><span>  docker stack services $stack
</span></span><span style=display:flex><span>  <span style=color:#75715e># 更新失败</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $update_result -eq <span style=color:#ae81ff>1</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;更新失败，确定是否需要回滚服务&#34;</span>
</span></span><span style=display:flex><span>    docker service ls --format<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;{{.Image}}&#34;</span> | grep -E <span style=color:#e6db74>&#34;^</span>$image$<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    find_image<span style=color:#f92672>=</span>$?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $find_image -eq <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>      logInfo <span style=color:#e6db74>&#34;开始回滚服务：</span>$service_name<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>      docker service rollback <span style=color:#e6db74>&#34;</span>$service_name<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>      logInfo <span style=color:#e6db74>&#34;回滚完成，输出服务状态：(可手动确认服务状态)&#34;</span>
</span></span><span style=display:flex><span>      docker service ls
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      logInfo <span style=color:#e6db74>&#34;无需回滚&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 直接退出</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;更新失败，即将退出，请手动检查服务镜像是否正常&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 更新成功，开始更新本地yml部署脚本</span>
</span></span><span style=display:flex><span>  logInfo <span style=color:#e6db74>&#34;开始更新本地yml部署脚本&#34;</span>
</span></span><span style=display:flex><span>  update_service_yaml_config <span style=color:#e6db74>&#34;</span>$stack<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$service<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$image<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 更新本地的yml文件配置</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> update_service_yaml_config<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 要更新的stack</span>
</span></span><span style=display:flex><span>  stack<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  <span style=color:#75715e># 要更新的服务</span>
</span></span><span style=display:flex><span>  service<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>  <span style=color:#75715e># 服务的镜像</span>
</span></span><span style=display:flex><span>  image<span style=color:#f92672>=</span>$3
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$stack<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;stack 参数不能为空&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$service<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;service 参数不能为空&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$image<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    logError <span style=color:#e6db74>&#34;image 参数不能为空&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  service_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>stack<span style=color:#e6db74>}</span><span style=color:#e6db74>_</span><span style=color:#e6db74>${</span>service<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 查找需要修改的文件(根据服务名查找，排除arm）</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># -H 输出匹配的文件路径</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># -v 过滤掉 arm</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># -print0 | xargs -0 用于处理文件名中可能存在的特殊字符</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 这里 /b:/b 的匹配模式 确保有空格的情况下尽可能的匹配到service</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 完成后输出类似如下：</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ./graphql/docker-compose-20210325.yml:  graphql-engine:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ./graphql/docker-compose.yml:  graphql-engine:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 获取需要修改的文件列表</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#   IFS=&#34; &#34; read -r -a file_list &lt;&lt;&lt; find . -type f -name &#34;*.yml&#34; -print0 | xargs -0 -I {} grep -H &#34;$service *: *$&#34; {} | grep -v &#34;arm&#34; | awk -F: &#39;{print $1}&#39; | tr &#34;\n&#34; &#34; &#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  file_list=($(find . -type f -name &#34;*.yml&#34; -print0 | xargs -0 -I {} grep -H &#34;$service *: *$&#34; {} | grep -v &#34;arm&#34; | awk -F: &#39;{print $1}&#39; | tr &#34;\n&#34; &#34; &#34;))</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 上面变量的写法在gitlab-runner上有问题</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  for file in &#34;${file_list[@]}&#34;; do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> file in <span style=color:#66d9ef>$(</span>find . -type f -name <span style=color:#e6db74>&#34;*.yml&#34;</span> -print0 | xargs -0 -I <span style=color:#f92672>{}</span> grep -H <span style=color:#e6db74>&#34;</span>$service<span style=color:#e6db74> *: *</span>$<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>{}</span> | grep -v <span style=color:#e6db74>&#34;arm&#34;</span> | awk -F: <span style=color:#e6db74>&#39;{print $1}&#39;</span> | tr <span style=color:#e6db74>&#34;\n&#34;</span> <span style=color:#e6db74>&#34; &#34;</span><span style=color:#66d9ef>)</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    logInfo 开始修改文件:<span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 获取文件中的镜像全名 &#34; *&#34; 匹配一个或多个空格</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 注意：这里通过服务名称来查找镜像名称，通过 grep -A 4 多输出四行，然后在这四行中寻找image段，从而获取文件中对应service的image的全名</span>
</span></span><span style=display:flex><span>    raw_image<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>grep -A <span style=color:#ae81ff>4</span> <span style=color:#e6db74>&#34;</span>$service<span style=color:#e6db74> *: *</span>$<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span> | grep image | sed <span style=color:#e6db74>&#39;s/.*image: *//g&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>    logInfo <span style=color:#e6db74>&#34;备份文件: </span>$file<span style=color:#e6db74>.bak&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#    cp -f &#34;$file&#34; &#34;$file.bak&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 开始修改文件</span>
</span></span><span style=display:flex><span>    sed <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>getSedOption<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;s|</span>$raw_image<span style=color:#e6db74>|</span>$image<span style=color:#e6db74>|g&#34;</span> <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $? -eq <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>      confirm_ed_result<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>grep <span style=color:#e6db74>&#34;</span>$image<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -n <span style=color:#e6db74>&#34;</span>$confirm_ed_result<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        logInfo <span style=color:#e6db74>&#34;修改成功&#34;</span>
</span></span><span style=display:flex><span>        logInfo <span style=color:#e6db74>&#34;服务更新完成&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        logError <span style=color:#e6db74>&#34;文件修改失败&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      logError <span style=color:#e6db74>&#34;文件修改失败&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 导出所有镜像</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> export_all_images<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  export_images graphql
</span></span><span style=display:flex><span>  export_images kafka
</span></span><span style=display:flex><span>  export_images <span style=color:#e6db74>&#34;gpl-datacollection&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;导入部署脚本成功&#34;</span>
</span></span></code></pre></div><h3 id=调查>调查<a hidden class=anchor aria-hidden=true href=#调查>#</a></h3><p>观察如下一个具体的deploy的job，我们可以有如下提取方向：</p><ol><li>将整个job都提取出去；</li><li>将script段提取出来；</li><li>将部署任务集中到一个单独的部署项目，各个服务模块更新后触发部署项目进行部署；</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>deploy</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>deploy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>cd $DEPLOY_PATH</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#- sudo chmod 777 -R $DEPLOY_PATH   需要自行使用root用户添加权限</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo &#34;$SERVICE_NAME&#34;</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo &#34;$DEPLOY_PATH&#34;</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo &#34;$DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA&#34;</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>source deploy.sh</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>update_service $DOCKER_NAMESPACE $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test_env_deploy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>url</span>: <span style=color:#ae81ff>$APP_URL/</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>manual</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>only</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>branches</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>deploy_graphql</span>
</span></span></code></pre></div><p>接下来，我们带着上述两个问题来寻找相关的技术支持 - 即：gitlab能帮助我们做到哪些及什么程度？</p><p>经过简单的调查我们可以知道，gitlabci的配置中，有一个<code>include</code> 的配置可以引入外部的yaml，我们详细了解下这个配置（<a href=https://docs.gitlab.com/ee/ci/yaml/README.html#include>Keyword reference for the .gitlab-ci.yml file | GitLab</a>）</p><p>而提取脚本是一个比较确定可以实现的事情，所以我们不予调查；</p><h4 id=include><strong>include</strong><a hidden class=anchor aria-hidden=true href=#include>#</a></h4><p><strong>用途：</strong></p><ol><li>在ci配置中导入外部的yaml配置；</li><li>拆分长的配置，提升可读性；</li><li>提取公共的配置，减少重复配置；</li><li>拆分放置到中心仓库，在其他项目中引入；</li></ol><p><strong>支持的源</strong>：</p><table><thead><tr><th style=text-align:left>Keyword</th><th style=text-align:left>Method</th></tr></thead><tbody><tr><td style=text-align:left><a href=https://docs.gitlab.com/ee/ci/yaml/README.html#includelocal><code>local</code></a></td><td style=text-align:left>本项目中的文件</td></tr><tr><td style=text-align:left><a href=https://docs.gitlab.com/ee/ci/yaml/README.html#includefile><code>file</code></a></td><td style=text-align:left>引入其他项目中的文件</td></tr><tr><td style=text-align:left><a href=https://docs.gitlab.com/ee/ci/yaml/README.html#includeremote><code>remote</code></a></td><td style=text-align:left>引入远程的URL中的文件（必须能被公开访问到）</td></tr><tr><td style=text-align:left><a href=https://docs.gitlab.com/ee/ci/yaml/README.html#includetemplate><code>template</code></a></td><td style=text-align:left>引入Gitlab提供的模板文件</td></tr></tbody></table><p>这里我们主要查看<code>file</code>- 即如何引入其他项目中的文件；</p><p><strong>基本用法：</strong>（需要使用project指定项目）</p><p>项目的地址是相对于根目录（<code>/</code>）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>include</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>project</span>: <span style=color:#e6db74>&#39;my-group/my-project&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>file</span>: <span style=color:#e6db74>&#39;/templates/.gitlab-ci-template.yml&#39;</span>
</span></span></code></pre></div><p><strong>指定分支/Tag/提交：</strong>(通过ref指定)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>include</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>project</span>: <span style=color:#e6db74>&#39;my-group/my-project&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ref</span>: <span style=color:#ae81ff>main</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>file</span>: <span style=color:#e6db74>&#39;/templates/.gitlab-ci-template.yml&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>project</span>: <span style=color:#e6db74>&#39;my-group/my-project&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ref</span>: <span style=color:#ae81ff>v1.0.0</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>file</span>: <span style=color:#e6db74>&#39;/templates/.gitlab-ci-template.yml&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>project</span>: <span style=color:#e6db74>&#39;my-group/my-project&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ref</span>: <span style=color:#ae81ff>787123b47f14b552955ca2786bc9542ae66fee5b </span> <span style=color:#75715e># Git SHA</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>file</span>: <span style=color:#e6db74>&#39;/templates/.gitlab-ci-template.yml&#39;</span>
</span></span></code></pre></div><p><strong>同时引入多个文件：</strong>（file中使用数组语法）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>include</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>project</span>: <span style=color:#e6db74>&#39;my-group/my-project&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ref</span>: <span style=color:#ae81ff>main</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>file</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#39;/templates/.builds.yml&#39;</span>
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#39;/templates/.tests.yml&#39;</span>
</span></span></code></pre></div><p><strong>嵌套引入：</strong></p><p>所有嵌套的includes都在当前目标项目的范围内执行，所以可以使用local (相对于目标项目), project, remote, 或者 template includes。</p><ul><li><p>可以最多有 100 个 includes；</p></li><li><p>不能有重复的include</p></li><li><p>在<a href=https://gitlab.com/gitlab-org/gitlab/-/issues/28212>GitLab 12.4</a> 及后续版本中, 解析所有文件的时间被限制在30秒之内，所以可能需要考虑文件的复杂度；</p></li></ul><p><strong>权限：</strong></p><p>执行人需要具有项目的权限；</p><p>All <a href=https://docs.gitlab.com/ee/ci/yaml/README.html#nested-includes>nested includes</a> are executed only with the permission of the user, so it’s possible to use project, remote or template includes.</p><h4 id=trigger>trigger<a hidden class=anchor aria-hidden=true href=#trigger>#</a></h4><p>gitlab可以使用trigger来触发多项目构建，在gitlab-ci配置中，可以使用trigger来定义一个下游流水线的触发器，当Gitlab启动这个trigger的任务时，会创建一个下游流水线；</p><p>对比于正常的任务，trigger类型的任务只有少量关键字可以使用；</p><p>Gitlab中可使用trigger创建两种类型的下游流水线：</p><ol><li>多项目流水线： 触发其他项目的流水线；</li><li>子流水线： 触发当前项目的流水线；</li></ol><p><strong>多项目流水线的触发任务基本写法：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>rspec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>: <span style=color:#ae81ff>bundle exec rspec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>staging</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>deploy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>trigger</span>: <span style=color:#ae81ff>my/deployment</span>
</span></span></code></pre></div><p><strong>多项目流水线的触发任务复杂写法：</strong></p><ul><li><p>通过branch指定分支</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>rspec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>: <span style=color:#ae81ff>bundle exec rspec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>staging</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>deploy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>trigger</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>project</span>: <span style=color:#ae81ff>my/deployment</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>branch</span>: <span style=color:#ae81ff>stable</span>
</span></span></code></pre></div></li><li><p>镜像下流流水线的状态(通过设置<code>strategy: depend</code>,默认情况下，触发器任务会被标记为成功，设置此标记后，则会等待下游流水线执行完成，然后使用下流流水线的状态来标记该触发器任务的状态)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>trigger_job</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>trigger</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>project</span>: <span style=color:#ae81ff>my/project</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>strategy</span>: <span style=color:#ae81ff>depend</span>
</span></span></code></pre></div></li><li><p>在下游流水线中，也可以获取上游流水线的状态</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>upstream_bridge:
</span></span><span style=display:flex><span>  stage: test
</span></span><span style=display:flex><span>  needs:
</span></span><span style=display:flex><span>    pipeline: other/project
</span></span></code></pre></div></li></ul><p><strong>子流水线的写法：</strong></p><ul><li><p>指定项目中的YAML文件的路径即可创建子流水线</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>trigger_job:
</span></span><span style=display:flex><span>  trigger:
</span></span><span style=display:flex><span>    include: path/to/child-pipeline.yml
</span></span></code></pre></div></li><li><p>同样的，也可以设置获取下游状态</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>trigger_job</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>trigger</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>include</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>local</span>: <span style=color:#ae81ff>path/to/child-pipeline.yml</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>strategy</span>: <span style=color:#ae81ff>depend</span>
</span></span></code></pre></div></li><li><p>可以使用其他项目中的YAML文件来定义子流水线</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>child-pipeline</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>trigger</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>include</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>project</span>: <span style=color:#e6db74>&#39;my-group/my-pipeline-library&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ref</span>: <span style=color:#e6db74>&#39;main&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>file</span>: <span style=color:#e6db74>&#39;/path/to/child-pipeline.yml&#39;</span>
</span></span></code></pre></div></li><li><p>可以使用自动生成的配置来生成子流水线(参考：<a href=https://docs.gitlab.com/ee/ci/parent_child_pipelines.html#dynamic-child-pipelines>Parent-child pipelines | GitLab</a>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>generate-config</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>build</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>: <span style=color:#ae81ff>generate-ci-config &gt; generated-config.yml</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>artifacts</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>generated-config.yml</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>child-pipeline</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>trigger</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>include</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>artifact</span>: <span style=color:#ae81ff>generated-config.yml</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>job</span>: <span style=color:#ae81ff>generate-config</span>
</span></span></code></pre></div></li></ul><h3 id=整体方案>整体方案<a hidden class=anchor aria-hidden=true href=#整体方案>#</a></h3><p>通过上面的分析，我们可以看到</p><ul><li>gitlab支持通过<code>include</code>来引入外部的脚本，脚本可以来自于本项目，也可以来自于其他项目；</li><li>通过<code>trigger</code>可以触发其他项目的流水线或者在本项目中生成一个子流水线，可以选择跟踪子流水线的执行状态；</li></ul><p>经过如上分析，我们决定使用如下方案对现有部署需求进行实施：</p><ol><li>每个项目分别定义自己的构建和镜像打包任务；</li><li>镜像打包完成后通过<code>trigger</code>来触发colorless部署仓库的部署任务，需要传递自己的信息给部署仓库生成的流水线；</li><li>触发任务的定义文件放置到colorless部署仓库中，在各个服务项目中通过<code>include</code>来引入；</li></ol><h2 id=优化方案实现>优化方案实现<a hidden class=anchor aria-hidden=true href=#优化方案实现>#</a></h2><p>如上所述，我们将部署操作集中到一个单独项目中，而又各个服务项目触发其部署流程，这里我们将这个单独的用于部署的项目称为独立部署项目，将其他服务的项目称之为子服务项目；以下分别说明上述方案中两种项目中的配置方式；</p><h3 id=各子服务项目的配置>各子服务项目的配置<a hidden class=anchor aria-hidden=true href=#各子服务项目的配置>#</a></h3><h4 id=gitlab-ciyml配置>gitlab-ci.yml配置<a hidden class=anchor aria-hidden=true href=#gitlab-ciyml配置>#</a></h4><p>我们将部署任务替换为一个触发任务，并从独立部署项目中引入任务的配置</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>stages</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>build</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>build_image</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>auto-build-deploy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 省略其他定义</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 引入触发自动编译部署任务配置 </span>
</span></span><span style=display:flex><span><span style=color:#f92672>include</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>project</span>: <span style=color:#e6db74>&#39;Deptproduct-project/colorless/colorless-deploy&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># ref: master</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>file</span>: <span style=color:#e6db74>&#39;/ci/gitlab-ci-base.yml&#39;</span>
</span></span></code></pre></div><p>这段配置会从 <code>Deptproduct-project/colorless/colorless-deploy</code> 项目中导入 <code>/ci/gitlab-ci-base.yml</code> 的配置，具体内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># 子模块用的公用触发项目，可以在子模块源码中 include</span>
</span></span><span style=display:flex><span><span style=color:#f92672>trigger:auto-build-deploy</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>auto-build-deploy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>variables</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>TRIGGER_CI_COMMIT_SHORT_SHA</span>: <span style=color:#ae81ff>$CI_COMMIT_SHORT_SHA</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#  配置仓库环境</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 自定义变量必须配置在上游UI界面</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>DOCKER_REGISTRY</span>: <span style=color:#ae81ff>$DOCKER_REGISTRY</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>DOCKER_NAMESPACE</span>: <span style=color:#ae81ff>$DOCKER_NAMESPACE</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>HARBOR_PWD</span>: <span style=color:#ae81ff>$HARBOR_PWD</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>HARBOR_USER</span>: <span style=color:#ae81ff>$HARBOR_USER</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>SERVICE_NAME</span>: <span style=color:#ae81ff>$SERVICE_NAME</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>trigger</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>project</span>: <span style=color:#ae81ff>Deptproduct-project/colorless/colorless-deploy</span>
</span></span></code></pre></div><p>在子项目中的ci配置中<code>include</code>该文件时，会生成一个触发任务，这个触发任务会触发<code>Deptproduct-project/colorless/colorless-deploy</code>这个项目，也就是我们的独立部署项目；</p><p>也就是说会触发我们独立部署项目生成一个流水线，此时流水线读取的就是我们独立部署项目的<code>.gitlab-ci.yml</code> 文件；</p><h4 id=web-ui中cicd变量配置>web UI中CI/CD变量配置<a hidden class=anchor aria-hidden=true href=#web-ui中cicd变量配置>#</a></h4><p>上述的触发任务的配置中，我们定义了几个变量，用于向部署项目的流水线说明我们自身的一些信息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    <span style=color:#f92672>TRIGGER_CI_COMMIT_SHORT_SHA</span>: <span style=color:#ae81ff>$CI_COMMIT_SHORT_SHA</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>DOCKER_REGISTRY</span>: <span style=color:#ae81ff>$DOCKER_REGISTRY</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>DOCKER_NAMESPACE</span>: <span style=color:#ae81ff>$DOCKER_NAMESPACE</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>HARBOR_PWD</span>: <span style=color:#ae81ff>$HARBOR_PWD</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>HARBOR_USER</span>: <span style=color:#ae81ff>$HARBOR_USER</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>SERVICE_NAME</span>: <span style=color:#ae81ff>$SERVICE_NAME</span>
</span></span></code></pre></div><p>其中，由我们自行定义的变量（<code>$DOCKER_REGISTRY</code>,<code>DOCKER_NAMESPACE</code>,<code>$HARBOR_PWD</code>,<code>$HARBOR_USER</code>,<code>$SERVICE_NAME</code>）需要在项目/群组的CI的变量中进行配置，在解析此触发任务时才可以读取到；</p><p><img alt=202203192303519 loading=lazy src=https://s2.loli.net/2022/05/26/tLyelhx2DPbznmV.png></p><h3 id=独立部署项目的配置>独立部署项目的配置<a hidden class=anchor aria-hidden=true href=#独立部署项目的配置>#</a></h3><h4 id=gitlab-ciyml-配置-1>gitlab-ci.yml 配置<a hidden class=anchor aria-hidden=true href=#gitlab-ciyml-配置-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>variables</span>:
</span></span><span style=display:flex><span><span style=color:#75715e>#  UI界面配置 DEPLOY_PATH</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>DEPLOY_PATH</span>: <span style=color:#ae81ff>/Wksp/colorlessWork/colorless-deploy/deploy/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  部署的stack</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>DOCKER_STACK</span>: <span style=color:#ae81ff>colorless</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>deploy</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>deploy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>echo $HARBOR_PWD | docker login --username=$HARBOR_USER $DOCKER_REGISTRY --password-stdin</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>cd $DEPLOY_PATH</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>source deploy.sh</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>update_service $DOCKER_STACK $SERVICE_NAME $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$SERVICE_NAME:$TRIGGER_CI_COMMIT_SHORT_SHA</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test_env_deploy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>url</span>: <span style=color:#ae81ff>$APP_URL/</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>manual</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>deploy_graphql</span>
</span></span></code></pre></div><h4 id=web-ui中cicd变量配置-1>web UI中CI/CD变量配置<a hidden class=anchor aria-hidden=true href=#web-ui中cicd变量配置-1>#</a></h4><p>现在，我们有些部署相关的变量需要从子服务项目中提取到当前独立部署项目中来定义，包括：<code>DEPLOY_PATH</code>,<code>DOCKER_STACK</code>,<code>APP_URL</code>，其中<code>DEPLOY_PATH</code>,<code>DOCKER_STACK</code>我们在yml中有定义默认值，可以不在UI界面中进行定义，只需要在UI界面中定义APP_URL即可；</p><h3 id=运行效果说明>运行效果说明<a hidden class=anchor aria-hidden=true href=#运行效果说明>#</a></h3><ol><li>每次子服务项目中提交代码，且满足ci配置中定义的条件时，即会生成一个触发任务，执行完前期阶段的任务后，当执行触发任务时，就会触发我们的独立仓库的部署任务。具体界面如下图所示；</li></ol><p><img alt=20210526155720 loading=lazy src=https://s2.loli.net/2022/05/26/dQ9ZWJeE7GOcqYz.png></p><ol start=2><li>点击下游任务即可跳转到我们的独立部署仓库中对应的流水线中；</li></ol><p><img alt=202203192305536 loading=lazy src=https://s2.loli.net/2022/05/26/38HPnbIrW17AiUY.png></p><ol start=3><li><p>点击deploy任务的运行按钮，即可进行部署；</p></li><li><p>部署完成后，可在独立部署仓库中生成一个部署环境，点击即可前往；</p><p><img alt=202203192306371 loading=lazy src=https://s2.loli.net/2022/05/26/Xf8ygsvLGwIzbqE.png></p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://hanlyjiang.github.io/tags/gitlab/>Gitlab</a></li><li><a href=https://hanlyjiang.github.io/tags/cicd/>CICD</a></li></ul><nav class=paginav><a class=prev href=https://hanlyjiang.github.io/posts/jian-hua-android-ku-shang-chuan-dao-maven-cang-ku-de-gradle-pei-zhi/><span class=title>« Prev</span><br><span>简化Android库上传到Maven仓库的gradle配置</span>
</a><a class=next href=https://hanlyjiang.github.io/posts/docker%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%BF%81%E7%A7%BB/><span class=title>Next »</span><br><span>Docker数据目录(/var/lib/docker)迁移</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hanlyjiang.github.io/>清水池塘</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>