<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>依赖注入 on 清水池塘</title>
    <link>http://localhost:1313/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link>
    <description>Recent content in 依赖注入 on 清水池塘</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 06 Mar 2022 15:11:54 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dagger 在Android库(SDK)模块中的使用实践</title>
      <link>http://localhost:1313/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/</link>
      <pubDate>Sun, 06 Mar 2022 15:11:54 +0000</pubDate>
      <guid>http://localhost:1313/posts/dagger-zai-android-ku-sdkmo-kuai-zhong-de-shi-yong-shi-jian/</guid>
      <description>&lt;p&gt;本文主要描述如何使用Dagger解决实际项目中遇到的问题，这两个问题是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何在库（SDK）模块中使用Dagger依赖注入？&lt;/li&gt;
&lt;li&gt;MVP中的Dagger依赖注入如何实现无感注入？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文不会介绍如何使用Dagger，只专注于描述如上两个问题的解决的前因后果及解决方案。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;接手开发一个SDK，大致情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该SDK内部有若干界面，包括Activity，Fragment等&lt;/li&gt;
&lt;li&gt;使用MVP架构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逐渐发现内部依赖混乱，在得空后，遂对其依赖部分进行重构改造。&lt;/p&gt;
&lt;h3 id=&#34;为什么使用依赖注入进行改造&#34;&gt;为什么使用依赖注入进行改造？&lt;/h3&gt;
&lt;p&gt;主要是依赖混乱，单例的滥用导致依赖关系不明显，无法管理，无法测试&lt;/p&gt;
&lt;p&gt;某些对象，我们在很多类中都需要使用，如 Retrofit 的请求对象，代表信息的标识字段等，此时为了避免通过构造函数或者setter方法来传递，就直接起了个单例，还有很多其他类似的情况，最终导致单例有10多个，调用单例 getInstance 的地方更是数不胜数。&lt;/p&gt;
&lt;p&gt;导致我们要对对应的代码进行单元测试做mock操作异常困难，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为依赖关系太不明显，几乎得一行行找才能找到类或方法到底依赖了哪些对象&lt;/li&gt;
&lt;li&gt;同时mock的过程也变得麻烦，由于没有作为类成员，所以无法简单通过mock替换对应成员；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;依赖注入改造的问题点&#34;&gt;依赖注入改造的问题点&lt;/h3&gt;
&lt;p&gt;主要有如下问题：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;之所以提第一个问题，是因为Google 针对Android，在Dagger的基础上针对性的构建了一个Hilt 的依赖注入框架，能够减少Android中直接使用Dagger的模板代码。但是Hilt的使中有要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;所有使用 Hilt 的应用都必须包含一个带有 &lt;code&gt;@HiltAndroidApp&lt;/code&gt; 注释的 &lt;code&gt;Application&lt;/code&gt; 类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考： &lt;a href=&#34;https://developer.android.google.cn/training/dependency-injection/hilt-android&#34;&gt;使用 Hilt 实现依赖项注入  | Android 开发者  | Android Developers (google.cn)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是必须能控制住Application，如上所述，我们作为一个SDK的提供方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是没有机会修改Application的代码的&lt;/li&gt;
&lt;li&gt;而且，我们也不能要求使用方去做这种限制；同时，如果使用方有使用 Hilt 呢，我们的代码是否会对其产生影响？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;故，我们只能直接使用Dagger。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而另外一个问题在于MVP的架构限制，P 层需要持有V层的引用，也就是P依赖V，而V通常是Activity或者Fragment，而Activity及Fragment的创建过程由Android系统控制，所以在使用Dagger时我们需要添加一些模板代码（下方会说明），将 Activity及Fragment对象注入到 Dagger 的依赖图谱中。&lt;/p&gt;
&lt;h2 id=&#34;没有-application-的问题解决&#34;&gt;没有 Application 的问题解决&lt;/h2&gt;
&lt;p&gt;首先，我们要解决的是没有Application的问题，那么没有Application会给我们带来哪些问题呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法使用 Hilt&lt;/li&gt;
&lt;li&gt;无法直接使用 dagger-android&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个问题实际上是类似的，Hilt及Dagger-Android都是用于解决 Android 组件（Activity，Fragment，Service，BroadcastReceiver 等）的依赖注入的。但是他们都要求我们必须使用 Application。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
